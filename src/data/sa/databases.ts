import type { Question } from '../types';

export const databasesQuestions: Question[] = [
  {
    id: 'sa-databases-001',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое первая нормальная форма (1НФ) в реляционных базах данных?',
    options: [
      'Каждый неключевой атрибут функционально зависит от всего первичного ключа',
      'Все атрибуты атомарны (неделимы), таблица не содержит повторяющихся групп',
      'Отсутствие транзитивных зависимостей неключевых атрибутов',
      'Все внешние ключи ссылаются на существующие записи в связанных таблицах',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1НФ) требует, чтобы все значения атрибутов были атомарными — каждая ячейка таблицы содержит одно неделимое значение, а не список или вложенную структуру. Также не должно быть повторяющихся групп столбцов (например, phone1, phone2, phone3 — это нарушение 1НФ). Вариант с функциональной зависимостью от всего первичного ключа — это вторая нормальная форма (2НФ). Отсутствие транзитивных зависимостей — третья нормальная форма (3НФ). Ссылочная целостность внешних ключей — это не нормальная форма, а ограничение целостности (referential integrity).',
  },
  {
    id: 'sa-databases-002',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип SQL JOIN возвращает только те строки, для которых найдено совпадение в обеих таблицах?',
    options: [
      'LEFT JOIN',
      'RIGHT JOIN',
      'INNER JOIN',
      'FULL OUTER JOIN',
    ],
    correctIndex: 2,
    explanation:
      'INNER JOIN возвращает только строки, которые имеют совпадающие значения в обеих соединяемых таблицах. Если для строки из одной таблицы нет соответствия в другой — она не попадёт в результат. LEFT JOIN возвращает все строки из левой таблицы, дополняя их данными из правой (или NULL, если совпадения нет). RIGHT JOIN — аналогично, но для правой таблицы. FULL OUTER JOIN возвращает все строки из обеих таблиц, подставляя NULL при отсутствии совпадений. Выбор типа JOIN зависит от бизнес-требований: например, если нужен список всех клиентов, включая тех, кто ещё ничего не купил, — используется LEFT JOIN от клиентов к заказам.',
  },
  {
    id: 'sa-databases-003',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В чём ключевое различие между операциями UNION и UNION ALL в SQL?',
    options: [
      'UNION объединяет таблицы по горизонтали, UNION ALL — по вертикали',
      'UNION удаляет дубликаты из результата, UNION ALL возвращает все строки, включая дубликаты',
      'UNION ALL работает только с одинаковыми таблицами, UNION — с любыми',
      'UNION ALL сортирует результат автоматически, UNION — нет',
    ],
    correctIndex: 1,
    explanation:
      'UNION и UNION ALL объединяют результаты двух или более SELECT-запросов вертикально (добавляя строки). Ключевое различие: UNION выполняет дедупликацию — удаляет повторяющиеся строки из результата, что требует дополнительной сортировки и сравнения (снижает производительность). UNION ALL возвращает все строки из всех запросов, включая полные дубликаты, и работает быстрее. На практике следует использовать UNION ALL, когда вы уверены, что дубликатов нет, или когда дубликаты допустимы — это значительно эффективнее. Оба оператора требуют одинакового количества столбцов с совместимыми типами данных во всех объединяемых запросах.',
  },
  {
    id: 'sa-databases-004',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните, что такое третья нормальная форма (3НФ) и приведите пример таблицы, которая находится во 2НФ, но нарушает 3НФ. Покажите, как привести её к 3НФ.',
    sampleAnswer:
      'Третья нормальная форма (3НФ) требует, чтобы таблица находилась во 2НФ и не содержала транзитивных зависимостей: каждый неключевой атрибут должен зависеть только от первичного ключа и ни от какого другого неключевого атрибута. Пример нарушения: таблица «Сотрудники» с колонками (employee_id PK, name, department_id, department_name, department_location). Здесь department_name и department_location зависят от department_id, а не напрямую от employee_id — это транзитивная зависимость. Для приведения к 3НФ нужно вынести атрибуты отдела в отдельную таблицу: «Сотрудники» (employee_id PK, name, department_id FK) и «Отделы» (department_id PK, department_name, department_location). Это устраняет аномалии обновления (при переименовании отдела нужно изменить одну запись, а не все строки сотрудников) и аномалии удаления (при увольнении последнего сотрудника отдела информация об отделе не теряется).',
    explanation:
      'Нормализация — процесс устранения избыточности данных. 1НФ: атомарность. 2НФ: отсутствие частичных зависимостей (актуально для составных ключей). 3НФ: отсутствие транзитивных зависимостей. Денормализация (сознательное нарушение НФ) иногда применяется для повышения производительности чтения, но аналитик должен понимать, какие аномалии при этом возникают и как их контролировать (например, через триггеры или application-level логику).',
  },
  {
    id: 'sa-databases-005',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните реляционные (SQL) и нереляционные (NoSQL) базы данных. В каких случаях системный аналитик должен рекомендовать NoSQL-решение? Какие компромиссы при этом возникают?',
    sampleAnswer:
      'Реляционные БД (PostgreSQL, Oracle, MS SQL) обеспечивают ACID-транзакции, строгую схему данных, мощный язык запросов (SQL) и нормализованное хранение. Они оптимальны для систем с чёткой структурой данных, сложными связями между сущностями и требованиями к консистентности (финансовые системы, ERP, CRM). NoSQL-базы делятся на категории: документные (MongoDB) — гибкая схема, вложенные документы; ключ-значение (Redis) — максимальная скорость для простых операций; колоночные (Cassandra, ClickHouse) — аналитика и запись больших объёмов; графовые (Neo4j) — сложные связи и обходы графов. NoSQL рекомендуется когда: (1) схема данных нестабильна и часто меняется; (2) требуется горизонтальное масштабирование на запись; (3) данные по природе не реляционные (графы, документы, временные ряды); (4) нужна низкая задержка при высокой нагрузке с простыми паттернами доступа. Компромиссы (CAP-теорема): большинство NoSQL-систем жертвуют строгой консистентностью ради доступности и устойчивости к разделению сети (eventual consistency). Также: отсутствие JOIN-ов приводит к дублированию данных, ограниченные возможности ad-hoc запросов, необходимость проектировать модель данных под конкретные паттерны запросов (query-driven design).',
    explanation:
      'Выбор типа БД — архитектурное решение с долгосрочными последствиями. Аналитик должен оценить: объём и скорость роста данных, паттерны чтения/записи, требования к консистентности (strong vs eventual), необходимость сложных запросов и JOIN-ов, требования к масштабированию. Нередко оптимальный вариант — polyglot persistence: использование разных типов БД для разных задач в рамках одной системы (например, PostgreSQL для транзакций + Redis для кэша + ClickHouse для аналитики).',
  },
  {
    id: 'sa-databases-006',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'При проектировании ER-модели для системы интернет-магазина связь между сущностями «Заказ» и «Товар» является «многие ко многим». Как правильно реализовать эту связь в реляционной БД?',
    options: [
      'Добавить массив ID товаров в таблицу заказов',
      'Создать промежуточную таблицу (junction table) с внешними ключами на обе сущности',
      'Добавить поле order_id в таблицу товаров',
      'Использовать JSON-поле для хранения списка товаров в заказе',
    ],
    correctIndex: 1,
    explanation:
      'Связь «многие ко многим» в реляционной модели реализуется через промежуточную (ассоциативную, junction/bridge) таблицу, которая содержит внешние ключи на обе связанные сущности. Например: таблица order_items (order_id FK, product_id FK, quantity, price). Первичный ключ — составной (order_id, product_id) или суррогатный. Промежуточная таблица может содержать дополнительные атрибуты связи (количество, цена на момент заказа). Массив ID (вариант 1) и JSON-поле (вариант 4) нарушают 1НФ, затрудняют написание запросов и не позволяют использовать ограничения ссылочной целостности. Добавление order_id в таблицу товаров (вариант 3) превратило бы связь в «один ко многим», что не соответствует требованиям.',
  },
  {
    id: 'sa-databases-007',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какая из перечисленных аномалий устраняется при переходе от ненормализованной таблицы к первой нормальной форме?',
    options: [
      'Транзитивная зависимость',
      'Хранение нескольких значений в одной ячейке (нарушение атомарности)',
      'Частичная зависимость от составного ключа',
      'Циклическая зависимость между таблицами',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1НФ) устраняет нарушение атомарности: ситуацию, когда в одной ячейке хранится несколько значений (например, список телефонов через запятую или вложенная таблица). После приведения к 1НФ каждая ячейка содержит ровно одно атомарное значение. Транзитивная зависимость устраняется при переходе к 3НФ. Частичная зависимость от составного ключа устраняется при переходе к 2НФ. Циклическая зависимость между таблицами — не является проблемой нормализации, а относится к проектированию схемы в целом.',
  },
  {
    id: 'sa-databases-008',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций в SQL используется по умолчанию в большинстве СУБД и предотвращает чтение незафиксированных данных?',
    options: [
      'Read Uncommitted',
      'Read Committed',
      'Repeatable Read',
      'Serializable',
    ],
    correctIndex: 1,
    explanation:
      'Read Committed — уровень изоляции, при котором транзакция видит только данные, зафиксированные другими транзакциями (committed). Это предотвращает «грязное чтение» (dirty read), когда транзакция читает незафиксированные изменения другой транзакции, которая может быть откачена. Read Committed — уровень по умолчанию в PostgreSQL, Oracle, SQL Server. Однако он не защищает от «неповторяемого чтения» (non-repeatable read) — повторный SELECT может вернуть другие данные, если параллельная транзакция успела зафиксировать изменения. Read Uncommitted — минимальная изоляция, допускает грязное чтение. Repeatable Read — гарантирует стабильность прочитанных строк. Serializable — максимальная изоляция, эмулирующая последовательное выполнение.',
  },
  {
    id: 'sa-databases-009',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Для чего используется индекс (INDEX) в реляционной базе данных?',
    options: [
      'Для шифрования данных в таблице',
      'Для ускорения поиска и выборки данных по определённым столбцам',
      'Для автоматического резервного копирования таблицы',
      'Для ограничения доступа к конкретным строкам',
    ],
    correctIndex: 1,
    explanation:
      'Индекс — структура данных, ускоряющая операции поиска и выборки (SELECT, WHERE, JOIN, ORDER BY) по определённым столбцам таблицы. Без индекса СУБД выполняет полное сканирование таблицы (full table scan), проверяя каждую строку. Индекс работает аналогично предметному указателю в книге — позволяет быстро найти нужные данные без перебора. Компромисс: индексы ускоряют чтение, но замедляют запись (INSERT, UPDATE, DELETE), так как при каждом изменении данных индекс тоже должен обновляться. Также индексы занимают дополнительное дисковое пространство. Поэтому индексы создаются только для часто используемых в запросах столбцов.',
  },
  {
    id: 'sa-databases-010',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL-базы данных хранит данные в виде узлов и рёбер, оптимально подходя для моделирования социальных сетей и рекомендательных систем?',
    options: [
      'Документная (Document Store)',
      'Колоночная (Column-Family Store)',
      'Ключ-значение (Key-Value Store)',
      'Графовая (Graph Database)',
    ],
    correctIndex: 3,
    explanation:
      'Графовые базы данных (Neo4j, Amazon Neptune, JanusGraph) хранят данные в виде графа: узлы (nodes) представляют сущности, рёбра (edges) — связи между ними, оба могут иметь свойства. Графовые БД оптимальны для запросов, связанных с обходом графа: «друзья друзей», «кратчайший путь», «рекомендации на основе связей», детекция мошенничества, управление знаниями. Язык запросов — Cypher (Neo4j), Gremlin, SPARQL. Документные БД (MongoDB) хранят JSON/BSON-документы. Колоночные (Cassandra, HBase) оптимизированы для записи и аналитических запросов. Ключ-значение (Redis, DynamoDB) — простейшая модель для кэширования и сессий.',
  },
  {
    id: 'sa-databases-011',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое MVCC (Multi-Version Concurrency Control) и зачем этот механизм используется в базах данных?',
    sampleAnswer:
      'MVCC (Multi-Version Concurrency Control) — механизм управления конкурентным доступом, при котором СУБД хранит несколько версий одной и той же строки данных. Когда транзакция обновляет строку, создаётся новая версия, а старая сохраняется до тех пор, пока она нужна другим активным транзакциям. Чтение данных никогда не блокирует запись, и наоборот — каждая транзакция видит согласованный «снимок» данных на определённый момент времени. Это радикально повышает производительность при параллельной работе множества пользователей. MVCC используется в PostgreSQL, Oracle, MySQL (InnoDB). Например, в PostgreSQL каждая строка имеет атрибуты xmin (ID создавшей транзакции) и xmax (ID удалившей/обновившей транзакции), что позволяет определить видимость версии для конкретной транзакции. Недостаток MVCC — накопление старых версий (bloat), требующее периодической очистки (VACUUM в PostgreSQL).',
    explanation:
      'MVCC решает фундаментальную проблему «читатели блокируют писателей» традиционного блокировочного подхода. Без MVCC SELECT мог бы блокировать UPDATE и наоборот, что критично для высоконагруженных систем. Аналитик должен понимать MVCC для грамотного проектирования транзакционной логики и понимания особенностей разных уровней изоляции.',
  },
  {
    id: 'sa-databases-012',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип индекса наиболее универсален и используется по умолчанию в большинстве реляционных СУБД?',
    options: [
      'Hash-индекс',
      'B-tree (сбалансированное дерево)',
      'Bitmap-индекс',
      'GIN-индекс (Generalized Inverted Index)',
    ],
    correctIndex: 1,
    explanation:
      'B-tree (balanced tree) — наиболее универсальный тип индекса, используемый по умолчанию в PostgreSQL, MySQL, Oracle, SQL Server. B-tree поддерживает операции равенства (=), диапазонные запросы (<, >, BETWEEN), сортировку (ORDER BY) и поиск по префиксу (LIKE \'abc%\'). Данные в B-tree хранятся в отсортированном виде, что обеспечивает логарифмическую сложность поиска O(log n). Hash-индекс оптимален только для точного равенства (=), не поддерживает диапазоны. Bitmap-индекс эффективен для столбцов с малым количеством уникальных значений (пол, статус) в OLAP-системах. GIN-индекс используется для полнотекстового поиска и индексации массивов/JSONB.',
  },
  {
    id: 'sa-databases-013',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какая аномалия при параллельном выполнении транзакций возникает, когда транзакция повторно читает те же данные и получает другой результат из-за фиксации изменений другой транзакцией?',
    options: [
      'Грязное чтение (Dirty Read)',
      'Неповторяемое чтение (Non-Repeatable Read)',
      'Фантомное чтение (Phantom Read)',
      'Потерянное обновление (Lost Update)',
    ],
    correctIndex: 1,
    explanation:
      'Неповторяемое чтение (Non-Repeatable Read) — аномалия, при которой транзакция дважды читает одну и ту же строку и получает разные значения, потому что между чтениями другая транзакция обновила и зафиксировала эту строку. Пример: транзакция A читает баланс = 1000, транзакция B изменяет его на 500 и фиксирует, транзакция A повторно читает баланс = 500. Грязное чтение — чтение незафиксированных данных. Фантомное чтение — появление или исчезновение строк в результате повторного запроса (INSERT/DELETE другой транзакции). Потерянное обновление — две транзакции читают одни данные и перезаписывают друг друга. Уровень Repeatable Read предотвращает неповторяемое чтение.',
  },
  {
    id: 'sa-databases-014',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое polyglot persistence и в каких случаях этот подход оправдан? Приведите пример системы, использующей несколько типов баз данных.',
    sampleAnswer:
      'Polyglot persistence — подход, при котором в рамках одной системы используются разные типы баз данных, каждая из которых оптимальна для своей задачи. Вместо использования одной универсальной СУБД для всех нужд, разные компоненты системы работают с теми хранилищами, которые лучше соответствуют их паттернам доступа к данным. Пример интернет-магазина: PostgreSQL — основная реляционная БД для заказов, пользователей и каталога товаров (ACID-транзакции, сложные запросы); Redis — кэширование сессий пользователей, корзин покупок, часто запрашиваемых данных (низкая латентность, TTL); Elasticsearch — полнотекстовый поиск по каталогу товаров (фасетный поиск, ранжирование); ClickHouse — аналитика и отчётность (быстрые агрегирующие запросы по большим объёмам данных); MongoDB — хранение логов и нетипизированных пользовательских данных (гибкая схема). Подход оправдан, когда система имеет разнородные требования к хранению и обработке данных. Риски: увеличение операционной сложности (нужно администрировать несколько СУБД), сложность обеспечения консистентности между хранилищами.',
    explanation:
      'Polyglot persistence — следствие принципа «right tool for the job». В микросервисной архитектуре каждый сервис может выбрать оптимальную СУБД. Аналитик должен обосновать выбор каждого хранилища через анализ паттернов доступа, объёмов данных и нефункциональных требований (латентность, пропускная способность, консистентность).',
  },
  {
    id: 'sa-databases-015',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой подход к миграции схемы базы данных подразумевает применение последовательных скриптов изменений (версионируемых миграций)?',
    options: [
      'Shadow Database',
      'Versioned Migrations (Flyway, Liquibase)',
      'Database Dump & Restore',
      'Manual DDL Execution',
    ],
    correctIndex: 1,
    explanation:
      'Versioned Migrations — подход, при котором каждое изменение схемы БД описывается отдельным скриптом (миграцией) с порядковым номером или временной меткой. Миграции применяются последовательно, и специальная таблица (например, flyway_schema_history) отслеживает, какие миграции уже применены. Инструменты: Flyway, Liquibase, Alembic (Python), Knex (Node.js). Преимущества: версионирование схемы вместе с кодом (в Git), воспроизводимость (любой разработчик или CI/CD может привести БД к актуальному состоянию), аудит изменений, поддержка rollback-скриптов. Shadow Database — копия БД для тестирования миграций. Dump & Restore — одноразовая операция, не подходит для итеративной разработки. Manual DDL — ручное выполнение SQL, подверженное ошибкам.',
  },
  {
    id: 'sa-databases-016',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций в SQL полностью предотвращает все аномалии параллельного выполнения, но может значительно снизить производительность?',
    options: [
      'Read Committed',
      'Repeatable Read',
      'Serializable',
      'Snapshot Isolation',
    ],
    correctIndex: 2,
    explanation:
      'Serializable — самый строгий уровень изоляции, гарантирующий, что результат параллельного выполнения транзакций эквивалентен некоторому последовательному выполнению. Предотвращает все аномалии: грязное чтение, неповторяемое чтение, фантомное чтение и аномалию сериализации (write skew). Реализация зависит от СУБД: в PostgreSQL Serializable реализован через SSI (Serializable Snapshot Isolation) — оптимистичный подход, который откатывает транзакцию при обнаружении конфликта сериализации. В MySQL — через блокировки промежутков (gap locks). Компромисс: максимальная корректность ценой снижения пропускной способности и увеличения количества откатов. Snapshot Isolation — промежуточный уровень (не входит в стандарт SQL), предотвращает большинство аномалий, но допускает write skew.',
  },
  {
    id: 'sa-databases-017',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите стратегии оптимизации медленных SQL-запросов. Какие инструменты и подходы используются для диагностики проблем производительности?',
    sampleAnswer:
      'Стратегии оптимизации SQL-запросов: (1) Анализ плана выполнения: EXPLAIN ANALYZE (PostgreSQL), EXPLAIN FORMAT=JSON (MySQL) показывают, как СУБД выполняет запрос — сканирование таблиц, используемые индексы, оценки кардинальности, стоимость операций. Ключевое — искать Seq Scan на больших таблицах, Nested Loop на больших выборках, Sort на неиндексированных столбцах. (2) Индексирование: создание индексов по столбцам в WHERE, JOIN, ORDER BY. Составные индексы — учитывать порядок столбцов (leftmost prefix rule). Покрывающие индексы (covering index / INCLUDE) — если все нужные столбцы есть в индексе, таблица не читается. (3) Переписывание запросов: замена подзапросов на JOIN, использование EXISTS вместо IN для коррелированных подзапросов, избегание функций на индексированных столбцах (WHERE UPPER(name) — индекс не используется). (4) Партиционирование: разбиение больших таблиц по диапазону (дата), списку или хешу — СУБД сканирует только нужные партиции (partition pruning). (5) Денормализация: материализованные представления, предвычисленные агрегаты для частых аналитических запросов. (6) Инструменты: pg_stat_statements (PostgreSQL), Performance Schema (MySQL), slow query log, APM-системы (Datadog, New Relic).',
    explanation:
      'Оптимизация запросов — итеративный процесс: измерение → анализ плана выполнения → гипотеза → изменение → повторное измерение. Аналитик должен уметь читать план выполнения и формулировать рекомендации для разработчиков. Частые ошибки: создание индексов «на всё» (замедляет запись), игнорирование статистики таблиц (ANALYZE), оптимизация запросов без понимания бизнес-контекста.',
  },
  {
    id: 'sa-databases-018',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой тип базы данных специально оптимизирован для хранения и анализа данных с временными метками (метрики, IoT-сенсоры, логи)?',
    options: [
      'Документная база данных',
      'Графовая база данных',
      'Time-Series Database (база данных временных рядов)',
      'Колоночное хранилище общего назначения',
    ],
    correctIndex: 2,
    explanation:
      'Time-Series Database (TSDB) — специализированный тип базы данных для хранения и анализа данных временных рядов: последовательностей точек данных, индексированных по времени. Примеры: InfluxDB, TimescaleDB (расширение PostgreSQL), Prometheus, VictoriaMetrics. Оптимизации TSDB: эффективная компрессия (соседние точки часто близки по значению), быстрая запись (append-only), эффективные агрегирующие запросы по временным окнам (средняя температура за час), автоматическое удаление старых данных (retention policy), downsampling (агрегирование старых данных для экономии места). Применение: мониторинг инфраструктуры, IoT-сенсоры, финансовые котировки, телеметрия приложений.',
  },
  {
    id: 'sa-databases-019',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните стратегии миграции баз данных: Big Bang migration и постепенную (incremental) миграцию. Какие риски несёт каждый подход и как их минимизировать?',
    sampleAnswer:
      'Big Bang migration — одномоментный перенос всех данных из старой системы в новую с последующим переключением всех пользователей. Преимущества: простота планирования (один момент переключения), нет необходимости поддерживать синхронизацию между старой и новой системами. Риски: длительный простой (downtime), высокий риск — при неудаче откатить сложно, все ошибки обнаруживаются одновременно. Минимизация: тщательное тестирование на копии prod-данных, rehearsal-миграции, чёткий план отката. Постепенная (incremental) миграция — данные и пользователи переносятся поэтапно, старая и новая системы работают параллельно. Подходы: параллельный запуск (dual write/read), Strangler Fig-паттерн (постепенная замена компонентов), миграция по группам пользователей / модулям. Преимущества: минимальный простой, возможность обнаружить проблемы на ранних этапах, лёгкий откат отдельного этапа. Риски: сложность синхронизации данных между системами (CDC, двойная запись), длительный период поддержки двух систем, консистентность данных. Минимизация: чёткая стратегия синхронизации, мониторинг расхождений, автоматические проверки целостности.',
    explanation:
      'Выбор стратегии миграции зависит от: допустимого downtime, объёма данных, сложности схемы, количества зависимых систем и толерантности бизнеса к рискам. Аналитик играет ключевую роль в планировании миграции: маппинг полей между схемами, правила трансформации данных, обработка некорректных данных, критерии успешности миграции.',
  },
  {
    id: 'sa-databases-020',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип индекса в PostgreSQL оптимален для столбцов с малым количеством уникальных значений (например, пол, статус заказа) в OLAP-сценариях?',
    options: [
      'B-tree индекс',
      'Hash-индекс',
      'BRIN-индекс (Block Range Index)',
      'Bitmap-индекс (через bitmap-scan при комбинировании индексов)',
    ],
    correctIndex: 3,
    explanation:
      'Bitmap-индексирование эффективно для столбцов с низкой кардинальностью (малым количеством уникальных значений). В PostgreSQL нет явного Bitmap-индекса как отдельного типа (в отличие от Oracle), но оптимизатор автоматически использует Bitmap Index Scan — преобразует результаты нескольких B-tree или других индексов в битовые карты, объединяет их (AND/OR) и затем обращается к таблице. Это особенно эффективно при комбинировании условий по нескольким столбцам с низкой кардинальностью. B-tree — универсален, но избыточен для двух-трёх значений. Hash — только для точного равенства. BRIN — эффективен для физически упорядоченных данных (например, временные метки в append-only таблицах).',
  },
  {
    id: 'sa-databases-021',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое внешний ключ (Foreign Key) в реляционной базе данных?',
    options: [
      'Уникальный идентификатор записи в таблице',
      'Столбец или набор столбцов, ссылающийся на первичный ключ другой таблицы',
      'Ключ для шифрования данных',
      'Индекс для ускорения поиска',
    ],
    correctIndex: 1,
    explanation:
      'Внешний ключ (Foreign Key, FK) — столбец или комбинация столбцов, значения которых ссылаются на первичный ключ (или уникальный ключ) другой таблицы. FK обеспечивает ссылочную целостность: нельзя вставить значение FK, не существующее в связанной таблице. Правила ON DELETE/ON UPDATE определяют поведение при удалении/изменении родительской записи: CASCADE (каскадное удаление), SET NULL, RESTRICT (запрет), NO ACTION. FK — основа для реализации связей между сущностями в реляционной модели.',
  },
  {
    id: 'sa-databases-022',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая команда SQL используется для удаления таблицы вместе со всеми её данными и структурой?',
    options: [
      'DELETE FROM table_name',
      'TRUNCATE TABLE table_name',
      'DROP TABLE table_name',
      'REMOVE TABLE table_name',
    ],
    correctIndex: 2,
    explanation:
      'DROP TABLE — DDL-команда, удаляющая таблицу полностью: структуру, данные, индексы, ограничения, триггеры. Операция необратима без резервной копии. DELETE FROM — удаляет строки, но сохраняет структуру таблицы; записывает каждое удаление в журнал транзакций; может быть отменена (ROLLBACK). TRUNCATE — быстро удаляет все строки, сохраняя структуру; сбрасывает счётчики автоинкремента; обычно не записывает построчно в журнал. REMOVE TABLE — не существует в стандартном SQL.',
  },
  {
    id: 'sa-databases-023',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что гарантирует буква «A» (Atomicity) в свойствах ACID-транзакций?',
    options: [
      'Данные всегда остаются в корректном состоянии',
      'Транзакция выполняется полностью или не выполняется совсем',
      'Параллельные транзакции изолированы друг от друга',
      'Результат зафиксированной транзакции сохраняется навсегда',
    ],
    correctIndex: 1,
    explanation:
      'Atomicity (атомарность) гарантирует, что транзакция выполняется как единое целое: либо все операции транзакции успешно завершаются, либо ни одна из них не применяется. При сбое на любом этапе все изменения откатываются (rollback). Пример: перевод денег — списание и зачисление должны выполниться вместе или не выполниться совсем. Consistency — данные остаются в корректном состоянии. Isolation — изоляция параллельных транзакций. Durability — сохранение результата.',
  },
  {
    id: 'sa-databases-024',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните разницу между первичным ключом (Primary Key) и уникальным ключом (Unique Key). Когда использовать каждый?',
    sampleAnswer:
      'Primary Key (PK) — столбец или набор столбцов, однозначно идентифицирующий каждую запись в таблице. Ограничения: только один PK на таблицу, не допускает NULL, автоматически создаётся уникальный индекс. Unique Key (UK) — ограничение уникальности для столбца или набора столбцов. Отличия: может быть несколько UK на таблицу, допускает один NULL (в большинстве СУБД), также создаётся уникальный индекс. Когда использовать PK: для основного идентификатора записи (id, суррогатный ключ). Когда использовать UK: для бизнес-идентификаторов, которые должны быть уникальны, но не являются основным ключом (email пользователя, ИНН организации, артикул товара). Пример: таблица users имеет PK на id (суррогатный ключ) и UK на email (натуральный бизнес-идентификатор).',
    explanation:
      'PK определяет идентичность записи в реляционной модели; FK других таблиц ссылаются на PK. UK обеспечивает уникальность бизнес-атрибутов. Практика: суррогатный PK (id) + UK на натуральные бизнес-идентификаторы — стандартный подход, сочетающий преимущества обоих.',
  },
  {
    id: 'sa-databases-025',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое двухфазный коммит (Two-Phase Commit, 2PC)?',
    options: [
      'Механизм репликации данных между серверами',
      'Протокол координации распределённых транзакций, обеспечивающий атомарность операций на нескольких узлах',
      'Метод резервного копирования базы данных',
      'Алгоритм балансировки нагрузки между репликами',
    ],
    correctIndex: 1,
    explanation:
      'Two-Phase Commit (2PC) — протокол координации распределённых транзакций. Фаза 1 (Prepare): координатор отправляет запрос prepare всем участникам; участники выполняют операции, записывают в журнал, отвечают готовностью к commit или abort. Фаза 2 (Commit/Abort): если все участники готовы — координатор отправляет commit; если хоть один не готов — отправляет abort. 2PC гарантирует атомарность распределённой транзакции, но имеет недостатки: блокирующий протокол (участники ждут решения координатора), single point of failure (координатор), плохо масштабируется. Альтернативы: Saga Pattern, eventual consistency.',
  },
  {
    id: 'sa-databases-026',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Change Data Capture (CDC) в контексте баз данных?',
    options: [
      'Резервное копирование данных',
      'Отслеживание и захват изменений в базе данных для передачи в другие системы',
      'Шифрование данных при передаче',
      'Сжатие данных для уменьшения объёма хранения',
    ],
    correctIndex: 1,
    explanation:
      'Change Data Capture (CDC) — технология отслеживания изменений (INSERT, UPDATE, DELETE) в базе данных и передачи их в другие системы в реальном времени. Методы реализации: чтение transaction log (наиболее эффективный — Debezium), database triggers, timestamp-based polling (менее надёжный). Применение: репликация данных, синхронизация между системами, построение аналитических хранилищ, реализация event-driven архитектуры поверх legacy-БД, обновление поисковых индексов, инвалидация кэшей. CDC — ключевой инструмент для паттерна Transactional Outbox.',
  },
  {
    id: 'sa-databases-027',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн проектирования БД предполагает хранение связанных данных вместе для оптимизации чтения в NoSQL-базах?',
    options: [
      'Нормализация до 3NF',
      'Денормализация и embedding (встраивание)',
      'Шардирование по хэшу',
      'Партиционирование по диапазону',
    ],
    correctIndex: 1,
    explanation:
      'В документо-ориентированных NoSQL-базах (MongoDB, Couchbase) часто применяется embedding (встраивание) — хранение связанных данных внутри одного документа вместо нормализации в отдельные коллекции. Пример: заказ содержит встроенный массив позиций заказа. Преимущества: один запрос вместо JOIN, атомарное обновление документа. Недостатки: дублирование данных, увеличение размера документа, сложность обновления встроенных данных при изменении в источнике. Правило: embedded если данные читаются вместе и редко меняются независимо; reference если данные обновляются независимо или документ становится слишком большим.',
  },
  {
    id: 'sa-databases-028',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Опишите стратегии миграции схемы базы данных в production без простоя (zero-downtime migration).',
    sampleAnswer:
      'Стратегии zero-downtime migration: (1) Expand-Contract Pattern (Parallel Change): Expand — добавляем новый столбец/таблицу, приложение пишет в оба места (старое и новое); Migrate — фоновый процесс мигрирует исторические данные; Contract — после полной миграции и обновления всех клиентов удаляем старую структуру. (2) Backward-Compatible Changes: добавление nullable столбцов, создание новых таблиц — не ломают старый код. (3) Blue-Green Database: две версии схемы, переключение трафика. Сложно для stateful систем. (4) Shadow Writes: запись в обе версии схемы одновременно для валидации. (5) Feature Flags: новый код использует новую схему только после включения флага. Практики: миграции должны быть обратно совместимы (старый код работает с новой схемой); разделять deployment кода и миграции БД; маленькие инкрементальные миграции вместо больших; тестировать миграции на копии production данных; иметь план отката. Инструменты: Flyway, Liquibase, gh-ost (GitHub) для online schema changes в MySQL.',
    explanation:
      'Zero-downtime migrations критичны для систем с высокой доступностью. Ключевой принцип: разделение изменений на backward-compatible шаги. Удаление столбца — три шага: 1) перестать использовать в коде, 2) деплой, 3) удалить столбец. Добавление NOT NULL столбца: добавить nullable → заполнить значениями → сделать NOT NULL.',
  },
  {
    id: 'sa-databases-029',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое deadlock в базе данных?',
    options: [
      'Ситуация, когда транзакция ожидает слишком долго',
      'Взаимная блокировка двух или более транзакций, каждая из которых ждёт ресурс, заблокированный другой',
      'Переполнение журнала транзакций',
      'Сбой при записи на диск',
    ],
    correctIndex: 1,
    explanation:
      'Deadlock (взаимная блокировка) — ситуация, когда две или более транзакции взаимно блокируют друг друга: T1 держит блокировку на ресурс A и ждёт ресурс B; T2 держит блокировку на B и ждёт A. Ни одна транзакция не может продолжиться. СУБД обнаруживает deadlock и автоматически откатывает одну из транзакций (жертву), чтобы другие могли продолжить. Предотвращение: единый порядок обращения к ресурсам, короткие транзакции, минимизация блокировок (оптимистичная блокировка), таймауты.',
  },
  {
    id: 'sa-databases-030',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн обеспечивает согласованность между записью в БД и отправкой сообщения в брокер?',
    options: [
      'Saga Pattern',
      'Two-Phase Commit',
      'Transactional Outbox',
      'Event Sourcing',
    ],
    correctIndex: 2,
    explanation:
      'Transactional Outbox решает проблему dual write: запись в БД и отправка в брокер — две разные операции, не объединяемые в одну транзакцию. Решение: сообщение записывается в специальную таблицу outbox в той же транзакции, что и бизнес-данные. Отдельный процесс (message relay) читает outbox и публикует в брокер. Варианты реализации: polling publisher (периодический опрос), CDC-based (Debezium читает transaction log). Паттерн гарантирует: сообщение будет отправлено если и только если транзакция зафиксирована. 2PC — тяжёлый протокол, плохо масштабируется. Saga — для распределённых транзакций.',
  },
  {
    id: 'sa-databases-031',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое партиционирование таблицы (table partitioning) и какую проблему оно решает?',
    options: [
      'Разделение таблицы по серверам для распределённой обработки',
      'Разделение большой таблицы на логические части (партиции) по заданному ключу для улучшения производительности и управляемости',
      'Создание копий таблицы для резервирования',
      'Шифрование частей таблицы разными ключами',
    ],
    correctIndex: 1,
    explanation:
      'Партиционирование — разделение большой таблицы на меньшие части (партиции) по значению ключа партиционирования. Типы: Range (по диапазону, например, даты), List (по списку значений), Hash (по хэшу ключа). Преимущества: partition pruning (СУБД сканирует только нужные партиции), параллельная обработка партиций, удобное архивирование (DROP PARTITION вместо DELETE), более быстрые операции обслуживания. Применение: большие таблицы с временными данными (логи, транзакции), данные с естественным разделением (по региону, клиенту). Не путать с шардированием — распределением данных по разным серверам.',
  },
  {
    id: 'sa-databases-032',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните оптимистичную и пессимистичную блокировки. Когда использовать каждую?',
    sampleAnswer:
      'Пессимистичная блокировка: транзакция захватывает блокировку на данные перед чтением/изменением и держит её до завершения. Реализация: SELECT ... FOR UPDATE. Преимущества: гарантированная целостность, простая логика. Недостатки: снижение concurrency, риск deadlock, блокировка при длительных операциях. Когда использовать: высокая вероятность конфликтов, критичные финансовые операции, короткие транзакции. Оптимистичная блокировка: транзакция читает данные с версией (version, updated_at), при записи проверяет, что версия не изменилась. Реализация: UPDATE ... WHERE id = ? AND version = ?; если 0 строк обновлено — конфликт. Преимущества: высокая concurrency, нет физических блокировок. Недостатки: необходимость обработки конфликтов (retry, уведомление пользователя), сложнее логика. Когда использовать: низкая вероятность конфликтов, длительные операции (редактирование документа), веб-приложения с формами. Практика: большинство веб-приложений используют оптимистичную блокировку как default.',
    explanation:
      'Выбор типа блокировки зависит от паттернов доступа к данным. Оптимистичная — стандарт для веб-приложений, где пользователь редактирует форму несколько минут. Пессимистичная — для критичных операций с высокой конкуренцией (списание со счёта). ORM-фреймворки (Hibernate, ActiveRecord) поддерживают оба подхода через аннотации или методы.',
  },
  {
    id: 'sa-databases-033',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Write-Ahead Logging (WAL) и зачем он нужен?',
    options: [
      'Логирование запросов для аудита',
      'Механизм записи изменений в журнал до применения к основным данным для обеспечения durability и recovery',
      'Кэширование записей для ускорения',
      'Репликация данных между серверами',
    ],
    correctIndex: 1,
    explanation:
      'Write-Ahead Logging (WAL) — механизм, при котором изменения сначала записываются в журнал (log), и только потом применяются к основным страницам данных. Гарантии: durability (при сбое данные восстанавливаются из WAL), atomicity (незавершённые транзакции откатываются). Применяется в PostgreSQL (pg_wal), MySQL InnoDB (redo log), Oracle (redo log). WAL также используется для репликации (streaming replication в PostgreSQL), point-in-time recovery, CDC. Компромисс: дополнительная запись (write amplification), но критическая защита от потери данных.',
  },
  {
    id: 'sa-databases-034',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип репликации предполагает, что запись происходит на один сервер (master), а чтение может выполняться с нескольких реплик?',
    options: [
      'Multi-Master Replication',
      'Master-Slave (Primary-Replica) Replication',
      'Peer-to-Peer Replication',
      'Synchronous Replication Only',
    ],
    correctIndex: 1,
    explanation:
      'Master-Slave (Primary-Replica) Replication — модель, где один сервер (master/primary) принимает все записи, а изменения реплицируются на один или несколько серверов-реплик (slaves/replicas), с которых выполняется чтение. Преимущества: масштабирование чтения, отказоустойчивость (promotion реплики при сбое master). Недостатки: replication lag (задержка), потенциальная потеря данных при асинхронной репликации. Multi-Master — запись на любой узел, сложнее разрешение конфликтов. Применение: большинство production-систем с нагрузкой read > write.',
  },
  {
    id: 'sa-databases-035',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое NULL в SQL?',
    options: [
      'Значение «ноль»',
      'Пустая строка',
      'Отсутствие значения (unknown/missing)',
      'Ошибка в данных',
    ],
    correctIndex: 2,
    explanation:
      'NULL в SQL означает отсутствие значения — данные неизвестны, не применимы или не заполнены. NULL не равен нулю (0), пустой строке (\'\') или другому NULL. Сравнение с NULL всегда даёт UNKNOWN: WHERE column = NULL не работает, нужно WHERE column IS NULL. Агрегатные функции (SUM, AVG) обычно игнорируют NULL. Для обработки NULL используются функции COALESCE (возвращает первое не-NULL значение), NULLIF, IS NULL, IS NOT NULL. Столбец с NOT NULL constraint не может содержать NULL.',
  },
  {
    id: 'sa-databases-036',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое составной индекс (Composite Index) и как порядок столбцов влияет на его эффективность?',
    options: [
      'Индекс, который сжимает данные',
      'Индекс на несколько столбцов, эффективный для запросов, использующих эти столбцы в порядке их определения в индексе',
      'Индекс, автоматически создаваемый при создании таблицы',
      'Индекс для полнотекстового поиска',
    ],
    correctIndex: 1,
    explanation:
      'Составной (Composite) индекс — индекс на несколько столбцов. Leftmost Prefix Rule: индекс на (A, B, C) эффективен для запросов по A; A и B; A, B и C. НЕ эффективен для запросов только по B или C без A. Порядок важен: индекс (status, created_at) отличается от (created_at, status). Первый столбец должен быть наиболее селективным или чаще используемым в WHERE. Covering Index — составной индекс, содержащий все столбцы запроса (включая SELECT), позволяя выполнить запрос только по индексу без обращения к таблице.',
  },
  {
    id: 'sa-databases-037',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое N+1 проблема при работе с базой данных? Как её избежать?',
    sampleAnswer:
      'N+1 проблема — антипаттерн, когда для получения данных выполняется 1 запрос для списка родительских записей и N дополнительных запросов для связанных данных каждой родительской записи. Пример: получить список заказов (1 запрос), затем для каждого заказа получить клиента (N запросов). При 1000 заказов — 1001 запрос вместо 2. Решения: (1) JOIN — объединить данные в одном запросе: SELECT * FROM orders JOIN customers ON orders.customer_id = customers.id. (2) Eager Loading (ORM) — указать связи для предзагрузки: Order.includes(:customer).all (Rails), @ManyToOne(fetch = FetchType.EAGER) или join fetch (Hibernate). (3) Batch Loading — загрузка связанных данных пакетами: WHERE customer_id IN (1, 2, 3, ...). (4) DataLoader паттерн (GraphQL) — автоматическое батчирование запросов. Обнаружение: мониторинг количества SQL-запросов на HTTP-запрос, ORM-логирование.',
    explanation:
      'N+1 — одна из самых частых причин проблем производительности в приложениях с ORM. Lazy loading удобен для разработки, но опасен в production. Правило: для списков всегда использовать eager loading или явные JOIN. Мониторинг SQL-запросов на каждый endpoint — обязательная практика.',
  },
  {
    id: 'sa-databases-038',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое шардирование (Sharding) базы данных?',
    options: [
      'Разделение таблицы на партиции внутри одного сервера',
      'Горизонтальное распределение данных между несколькими независимыми серверами БД',
      'Репликация данных между серверами',
      'Кэширование часто используемых запросов',
    ],
    correctIndex: 1,
    explanation:
      'Шардирование (Sharding) — горизонтальное масштабирование БД путём распределения данных между несколькими независимыми серверами (шардами). Каждый шард содержит часть данных, определяемую ключом шардирования (shard key). Методы: hash sharding (хэш от ключа), range sharding (диапазоны значений), directory sharding (таблица маршрутизации). Преимущества: масштабирование записи и хранения, распределение нагрузки. Сложности: cross-shard queries и transactions, перебалансировка при добавлении шардов, выбор ключа шардирования. Не путать с партиционированием (одна БД, несколько партиций) и репликацией (копии одних данных).',
  },
  {
    id: 'sa-databases-039',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите подходы к тюнингу производительности PostgreSQL. Какие параметры и метрики анализируются?',
    sampleAnswer:
      'Тюнинг производительности PostgreSQL: (1) Анализ запросов: EXPLAIN ANALYZE для плана выполнения; pg_stat_statements для топа медленных запросов; log_min_duration_statement для логирования медленных запросов. Метрики: Seq Scan vs Index Scan, rows estimated vs actual, time. (2) Индексирование: создание индексов на столбцы в WHERE, JOIN, ORDER BY; анализ pg_stat_user_indexes (неиспользуемые индексы); частичные индексы (CREATE INDEX ... WHERE), expression indexes. (3) Параметры памяти: shared_buffers (25-40% RAM), effective_cache_size (50-75% RAM), work_mem (для сортировок и хэш-таблиц, осторожно — умножается на количество соединений), maintenance_work_mem (для VACUUM, CREATE INDEX). (4) Параллелизм: max_parallel_workers_per_gather, parallel_tuple_cost, parallel_setup_cost. (5) Checkpoints: checkpoint_timeout, checkpoint_completion_target (растянуть I/O). (6) Autovacuum: настройка частоты и агрессивности для предотвращения bloat. (7) Мониторинг: pg_stat_activity (активные сессии), pg_stat_user_tables (seq_scan, idx_scan, dead tuples), pg_stat_bgwriter (checkpoint stats). (8) Connection Pooling: PgBouncer/PgPool для снижения overhead создания соединений.',
    explanation:
      'Тюнинг PostgreSQL — итеративный процесс: измерение → гипотеза → изменение → измерение. Начинать с анализа запросов (pg_stat_statements) — часто 90% проблем решаются правильными индексами. Параметры памяти зависят от характера нагрузки (OLTP vs OLAP). Production-мониторинг обязателен (pgAdmin, Datadog, Prometheus + postgres_exporter).',
  },
  {
    id: 'sa-databases-040',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой оператор SQL используется для группировки строк по значению столбца?',
    options: [
      'ORDER BY',
      'GROUP BY',
      'PARTITION BY',
      'CLUSTER BY',
    ],
    correctIndex: 1,
    explanation:
      'GROUP BY группирует строки с одинаковыми значениями указанных столбцов в сводные строки. Обычно используется с агрегатными функциями: COUNT, SUM, AVG, MAX, MIN. Пример: SELECT department, COUNT(*) FROM employees GROUP BY department — количество сотрудников по отделам. HAVING фильтрует группы (как WHERE для строк). ORDER BY — сортировка результата. PARTITION BY — используется в оконных функциях для разбиения внутри запроса, не влияя на группировку результата.',
  },
  {
    id: 'sa-databases-041',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем отличается синхронная репликация от асинхронной?',
    options: [
      'Синхронная использует TCP, асинхронная — UDP',
      'При синхронной транзакция на master ждёт подтверждения от реплики; при асинхронной — не ждёт',
      'Синхронная работает только внутри одного дата-центра',
      'Асинхронная не поддерживает failover',
    ],
    correctIndex: 1,
    explanation:
      'Синхронная репликация: транзакция на primary считается завершённой только после подтверждения записи хотя бы на одной реплике. Гарантия: данные не потеряются при сбое primary. Недостаток: увеличение latency, зависимость от доступности реплики. Асинхронная репликация: primary подтверждает транзакцию сразу, репликация происходит в фоне. Преимущество: низкая latency. Недостаток: replication lag, возможная потеря данных при сбое primary до репликации. Выбор зависит от требований к durability vs latency.',
  },
  {
    id: 'sa-databases-042',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое materialized view (материализованное представление)?',
    options: [
      'Виртуальная таблица, вычисляемая при каждом запросе',
      'Представление, данные которого физически сохраняются и периодически обновляются',
      'Временная таблица для текущей сессии',
      'Резервная копия таблицы',
    ],
    correctIndex: 1,
    explanation:
      'Materialized View — представление, результат которого физически сохраняется в базе данных как таблица. В отличие от обычного VIEW (вычисляется при каждом запросе), materialized view хранит предвычисленные данные. Преимущества: быстрый доступ к сложным агрегатам, снижение нагрузки на источник. Недостатки: данные могут быть устаревшими, требуется обновление (REFRESH). Применение: аналитические отчёты, кэширование результатов тяжёлых JOIN, денормализация для чтения. PostgreSQL поддерживает REFRESH MATERIALIZED VIEW (полное обновление) и REFRESH MATERIALIZED VIEW CONCURRENTLY (без блокировки чтения).',
  },
  {
    id: 'sa-databases-043',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какая CAP-теорема утверждает о распределённых системах?',
    options: [
      'Распределённая система может обеспечить любые три свойства одновременно',
      'Из трёх свойств — Consistency, Availability, Partition Tolerance — можно обеспечить только два одновременно',
      'Распределённые системы всегда быстрее централизованных',
      'Партиционирование всегда улучшает производительность',
    ],
    correctIndex: 1,
    explanation:
      'CAP-теорема (Eric Brewer) утверждает, что распределённая система не может одновременно обеспечить все три свойства: Consistency (все узлы видят одинаковые данные одновременно), Availability (каждый запрос получает ответ), Partition Tolerance (система работает при разрыве связи между узлами). Поскольку partition tolerance обязателен для распределённых систем, выбор фактически между CP (consistency при partition — отказ недоступным узлам) и AP (availability при partition — eventual consistency). Традиционные РСУБД — CA в рамках одного узла. NoSQL-системы часто выбирают AP (Cassandra, DynamoDB) или CP (MongoDB, HBase).',
  },
  {
    id: 'sa-databases-044',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн Saga для управления распределёнными транзакциями. Какие виды Saga существуют и как они реализуются?',
    sampleAnswer:
      'Saga — паттерн управления распределёнными транзакциями через последовательность локальных транзакций, каждая из которых имеет компенсирующее действие. Вместо ACID-транзакции через 2PC — eventual consistency с гарантированным откатом при сбое. Виды Saga: (1) Choreography-based Saga: каждый сервис знает, какое событие публиковать после своей локальной транзакции; другие сервисы подписаны на события и реагируют. Плюсы: децентрализованность, слабая связанность. Минусы: сложно отследить полный процесс, риск циклических зависимостей. (2) Orchestration-based Saga: центральный оркестратор (Saga Coordinator) управляет последовательностью шагов, вызывая сервисы и обрабатывая ответы. Плюсы: логика процесса в одном месте, проще мониторинг. Минусы: оркестратор — единая точка отказа, сильнее связанность. Реализация компенсаций: каждый шаг имеет compensating action (отмена резервирования, возврат средств). При сбое Saga выполняет компенсации в обратном порядке. Инструменты: Camunda, Temporal, Axon Framework, самописный на Kafka.',
    explanation:
      'Saga — стандартный подход к транзакциям в микросервисах, заменяющий тяжёлый 2PC. Ключевые требования: идемпотентность шагов и компенсаций, наблюдаемость (статус Saga), обработка параллельных конфликтов (semantic lock). Аналитик должен документировать все шаги Saga и их компенсации для каждого бизнес-процесса.',
  },
  {
    id: 'sa-databases-045',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой оператор SQL используется для изменения структуры существующей таблицы?',
    options: [
      'UPDATE',
      'MODIFY',
      'ALTER TABLE',
      'CHANGE TABLE',
    ],
    correctIndex: 2,
    explanation:
      'ALTER TABLE — DDL-команда для изменения структуры существующей таблицы: добавление/удаление/изменение столбцов, добавление/удаление ограничений, изменение типов данных, переименование столбцов и таблицы. Примеры: ALTER TABLE users ADD COLUMN age INT; ALTER TABLE users DROP COLUMN temp; ALTER TABLE users ADD CONSTRAINT uk_email UNIQUE (email). UPDATE — DML-команда для изменения данных в строках, не структуры.',
  },
  {
    id: 'sa-databases-046',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое оконные функции (Window Functions) в SQL?',
    options: [
      'Функции для работы с датами и временем',
      'Функции, выполняющие вычисления над набором строк, связанных с текущей строкой, без группировки',
      'Функции шифрования данных',
      'Функции для создания временных таблиц',
    ],
    correctIndex: 1,
    explanation:
      'Оконные функции (Window Functions, OVER clause) выполняют вычисления над набором строк (окном), связанных с текущей строкой, сохраняя все строки в результате (в отличие от GROUP BY). Синтаксис: function() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE ...). Примеры: ROW_NUMBER() — нумерация строк; RANK(), DENSE_RANK() — ранжирование; LAG(), LEAD() — доступ к предыдущей/следующей строке; SUM() OVER, AVG() OVER — накопительные агрегаты. Применение: нумерация внутри групп, скользящие средние, сравнение с предыдущим значением, top-N внутри категорий.',
  },
  {
    id: 'sa-databases-047',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое connection pooling и зачем он нужен?',
    options: [
      'Механизм шифрования соединений',
      'Повторное использование пула заранее созданных соединений к БД для снижения накладных расходов',
      'Балансировка нагрузки между серверами БД',
      'Кэширование результатов запросов',
    ],
    correctIndex: 1,
    explanation:
      'Connection Pooling — механизм повторного использования соединений к БД из заранее созданного пула. Создание соединения — дорогая операция (TCP handshake, аутентификация, выделение ресурсов на сервере). Пул поддерживает N открытых соединений; приложение берёт соединение из пула, использует и возвращает. Параметры: min/max connections, idle timeout, validation query. Реализации: на уровне приложения (HikariCP, c3p0) или внешний pooler (PgBouncer для PostgreSQL). Без pooling высоконагруженное приложение может исчерпать лимит соединений БД.',
  },
  {
    id: 'sa-databases-048',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое BRIN-индекс в PostgreSQL и когда его использовать?',
    options: [
      'Индекс для полнотекстового поиска',
      'Индекс на основе блоков (Block Range Index), эффективный для физически упорядоченных данных',
      'Индекс для JSON-полей',
      'Индекс для географических данных',
    ],
    correctIndex: 1,
    explanation:
      'BRIN (Block Range Index) — тип индекса PostgreSQL, хранящий сводную информацию (min/max) для диапазонов физических блоков таблицы. Эффективен когда: данные физически упорядочены по индексируемому столбцу (временные метки в append-only таблицах, монотонно растущие ID). Преимущества: очень компактный (в 1000 раз меньше B-tree), быстрое создание, низкие накладные расходы на запись. Недостатки: работает только при физической корреляции данных и порядка значений; менее эффективен для точечных запросов. Применение: таблицы логов, временных рядов, транзакций с timestamp.',
  },
  {
    id: 'sa-databases-049',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Какие стратегии используются для масштабирования баз данных? Сравните вертикальное и горизонтальное масштабирование.',
    sampleAnswer:
      'Вертикальное масштабирование (Scale Up): увеличение мощности одного сервера — больше CPU, RAM, быстрые диски (NVMe SSD). Преимущества: простота, нет изменений в архитектуре, ACID-транзакции работают как есть. Недостатки: физический предел мощности сервера, высокая стоимость топовых конфигураций, single point of failure. Горизонтальное масштабирование (Scale Out): распределение нагрузки между несколькими серверами. Стратегии: (1) Read Replicas — реплики для чтения, master для записи; масштабирует чтение, не запись. (2) Sharding — разделение данных между серверами по ключу; масштабирует и чтение, и запись, но усложняет cross-shard операции. (3) Functional Partitioning — разные данные на разных серверах (users DB, orders DB); естественно для микросервисов. (4) Caching Layer — Redis/Memcached для снижения нагрузки на БД. Преимущества: почти неограниченное масштабирование. Недостатки: сложность архитектуры, distributed transactions, eventual consistency. Рекомендация: начинать с вертикального масштабирования; переходить к горизонтальному когда достигнут предел или требуется high availability.',
    explanation:
      'Масштабирование БД — часто самая сложная часть масштабирования системы. Read replicas — первый шаг для большинства приложений (read-heavy workload). Sharding — крайняя мера, требующая значительных архитектурных изменений. Caching часто даёт 10x улучшение при минимальных изменениях.',
  },
  {
    id: 'sa-databases-050',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое CTE (Common Table Expression) в SQL?',
    options: [
      'Тип данных для хранения временных значений',
      'Временный именованный результат запроса, который можно использовать в основном запросе',
      'Механизм шифрования данных',
      'Ограничение целостности таблицы',
    ],
    correctIndex: 1,
    explanation:
      'CTE (Common Table Expression) — временный именованный набор результатов, определяемый с помощью WITH clause. Существует только в рамках одного запроса. Синтаксис: WITH cte_name AS (SELECT ...) SELECT * FROM cte_name. Преимущества: улучшение читаемости сложных запросов, переиспользование подзапроса, рекурсивные запросы (WITH RECURSIVE) для иерархических данных. Пример рекурсивного CTE: обход дерева категорий, поиск всех подчинённых сотрудника. CTE материализуется (PostgreSQL) или инлайнится (MySQL) — зависит от оптимизатора.',
  },
];
