import type { Question } from '../types';

export const databasesQuestions: Question[] = [
  {
    id: 'sa-databases-001',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое первая нормальная форма (1НФ) в реляционных базах данных?',
    options: [
      'Каждый неключевой атрибут функционально зависит от всего первичного ключа',
      'Все атрибуты атомарны (неделимы), таблица не содержит повторяющихся групп',
      'Отсутствие транзитивных зависимостей неключевых атрибутов',
      'Все внешние ключи ссылаются на существующие записи в связанных таблицах',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1НФ) требует, чтобы все значения атрибутов были атомарными — каждая ячейка таблицы содержит одно неделимое значение, а не список или вложенную структуру. Также не должно быть повторяющихся групп столбцов (например, phone1, phone2, phone3 — это нарушение 1НФ). Вариант с функциональной зависимостью от всего первичного ключа — это вторая нормальная форма (2НФ). Отсутствие транзитивных зависимостей — третья нормальная форма (3НФ). Ссылочная целостность внешних ключей — это не нормальная форма, а ограничение целостности (referential integrity).',
  },
  {
    id: 'sa-databases-002',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип SQL JOIN возвращает только те строки, для которых найдено совпадение в обеих таблицах?',
    options: [
      'LEFT JOIN',
      'RIGHT JOIN',
      'INNER JOIN',
      'FULL OUTER JOIN',
    ],
    correctIndex: 2,
    explanation:
      'INNER JOIN возвращает только строки, которые имеют совпадающие значения в обеих соединяемых таблицах. Если для строки из одной таблицы нет соответствия в другой — она не попадёт в результат. LEFT JOIN возвращает все строки из левой таблицы, дополняя их данными из правой (или NULL, если совпадения нет). RIGHT JOIN — аналогично, но для правой таблицы. FULL OUTER JOIN возвращает все строки из обеих таблиц, подставляя NULL при отсутствии совпадений. Выбор типа JOIN зависит от бизнес-требований: например, если нужен список всех клиентов, включая тех, кто ещё ничего не купил, — используется LEFT JOIN от клиентов к заказам.',
  },
  {
    id: 'sa-databases-003',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В чём ключевое различие между операциями UNION и UNION ALL в SQL?',
    options: [
      'UNION объединяет таблицы по горизонтали, UNION ALL — по вертикали',
      'UNION удаляет дубликаты из результата, UNION ALL возвращает все строки, включая дубликаты',
      'UNION ALL работает только с одинаковыми таблицами, UNION — с любыми',
      'UNION ALL сортирует результат автоматически, UNION — нет',
    ],
    correctIndex: 1,
    explanation:
      'UNION и UNION ALL объединяют результаты двух или более SELECT-запросов вертикально (добавляя строки). Ключевое различие: UNION выполняет дедупликацию — удаляет повторяющиеся строки из результата, что требует дополнительной сортировки и сравнения (снижает производительность). UNION ALL возвращает все строки из всех запросов, включая полные дубликаты, и работает быстрее. На практике следует использовать UNION ALL, когда вы уверены, что дубликатов нет, или когда дубликаты допустимы — это значительно эффективнее. Оба оператора требуют одинакового количества столбцов с совместимыми типами данных во всех объединяемых запросах.',
  },
  {
    id: 'sa-databases-004',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните, что такое третья нормальная форма (3НФ) и приведите пример таблицы, которая находится во 2НФ, но нарушает 3НФ. Покажите, как привести её к 3НФ.',
    sampleAnswer:
      'Третья нормальная форма (3НФ) требует, чтобы таблица находилась во 2НФ и не содержала транзитивных зависимостей: каждый неключевой атрибут должен зависеть только от первичного ключа и ни от какого другого неключевого атрибута. Пример нарушения: таблица «Сотрудники» с колонками (employee_id PK, name, department_id, department_name, department_location). Здесь department_name и department_location зависят от department_id, а не напрямую от employee_id — это транзитивная зависимость. Для приведения к 3НФ нужно вынести атрибуты отдела в отдельную таблицу: «Сотрудники» (employee_id PK, name, department_id FK) и «Отделы» (department_id PK, department_name, department_location). Это устраняет аномалии обновления (при переименовании отдела нужно изменить одну запись, а не все строки сотрудников) и аномалии удаления (при увольнении последнего сотрудника отдела информация об отделе не теряется).',
    explanation:
      'Нормализация — процесс устранения избыточности данных. 1НФ: атомарность. 2НФ: отсутствие частичных зависимостей (актуально для составных ключей). 3НФ: отсутствие транзитивных зависимостей. Денормализация (сознательное нарушение НФ) иногда применяется для повышения производительности чтения, но аналитик должен понимать, какие аномалии при этом возникают и как их контролировать (например, через триггеры или application-level логику).',
  },
  {
    id: 'sa-databases-005',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните реляционные (SQL) и нереляционные (NoSQL) базы данных. В каких случаях системный аналитик должен рекомендовать NoSQL-решение? Какие компромиссы при этом возникают?',
    sampleAnswer:
      'Реляционные БД (PostgreSQL, Oracle, MS SQL) обеспечивают ACID-транзакции, строгую схему данных, мощный язык запросов (SQL) и нормализованное хранение. Они оптимальны для систем с чёткой структурой данных, сложными связями между сущностями и требованиями к консистентности (финансовые системы, ERP, CRM). NoSQL-базы делятся на категории: документные (MongoDB) — гибкая схема, вложенные документы; ключ-значение (Redis) — максимальная скорость для простых операций; колоночные (Cassandra, ClickHouse) — аналитика и запись больших объёмов; графовые (Neo4j) — сложные связи и обходы графов. NoSQL рекомендуется когда: (1) схема данных нестабильна и часто меняется; (2) требуется горизонтальное масштабирование на запись; (3) данные по природе не реляционные (графы, документы, временные ряды); (4) нужна низкая задержка при высокой нагрузке с простыми паттернами доступа. Компромиссы (CAP-теорема): большинство NoSQL-систем жертвуют строгой консистентностью ради доступности и устойчивости к разделению сети (eventual consistency). Также: отсутствие JOIN-ов приводит к дублированию данных, ограниченные возможности ad-hoc запросов, необходимость проектировать модель данных под конкретные паттерны запросов (query-driven design).',
    explanation:
      'Выбор типа БД — архитектурное решение с долгосрочными последствиями. Аналитик должен оценить: объём и скорость роста данных, паттерны чтения/записи, требования к консистентности (strong vs eventual), необходимость сложных запросов и JOIN-ов, требования к масштабированию. Нередко оптимальный вариант — polyglot persistence: использование разных типов БД для разных задач в рамках одной системы (например, PostgreSQL для транзакций + Redis для кэша + ClickHouse для аналитики).',
  },
  {
    id: 'sa-databases-006',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'При проектировании ER-модели для системы интернет-магазина связь между сущностями «Заказ» и «Товар» является «многие ко многим». Как правильно реализовать эту связь в реляционной БД?',
    options: [
      'Добавить массив ID товаров в таблицу заказов',
      'Создать промежуточную таблицу (junction table) с внешними ключами на обе сущности',
      'Добавить поле order_id в таблицу товаров',
      'Использовать JSON-поле для хранения списка товаров в заказе',
    ],
    correctIndex: 1,
    explanation:
      'Связь «многие ко многим» в реляционной модели реализуется через промежуточную (ассоциативную, junction/bridge) таблицу, которая содержит внешние ключи на обе связанные сущности. Например: таблица order_items (order_id FK, product_id FK, quantity, price). Первичный ключ — составной (order_id, product_id) или суррогатный. Промежуточная таблица может содержать дополнительные атрибуты связи (количество, цена на момент заказа). Массив ID (вариант 1) и JSON-поле (вариант 4) нарушают 1НФ, затрудняют написание запросов и не позволяют использовать ограничения ссылочной целостности. Добавление order_id в таблицу товаров (вариант 3) превратило бы связь в «один ко многим», что не соответствует требованиям.',
  },
  {
    id: 'sa-databases-007',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какая из перечисленных аномалий устраняется при переходе от ненормализованной таблицы к первой нормальной форме?',
    options: [
      'Транзитивная зависимость',
      'Хранение нескольких значений в одной ячейке (нарушение атомарности)',
      'Частичная зависимость от составного ключа',
      'Циклическая зависимость между таблицами',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1НФ) устраняет нарушение атомарности: ситуацию, когда в одной ячейке хранится несколько значений (например, список телефонов через запятую или вложенная таблица). После приведения к 1НФ каждая ячейка содержит ровно одно атомарное значение. Транзитивная зависимость устраняется при переходе к 3НФ. Частичная зависимость от составного ключа устраняется при переходе к 2НФ. Циклическая зависимость между таблицами — не является проблемой нормализации, а относится к проектированию схемы в целом.',
  },
  {
    id: 'sa-databases-008',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций в SQL используется по умолчанию в большинстве СУБД и предотвращает чтение незафиксированных данных?',
    options: [
      'Read Uncommitted',
      'Read Committed',
      'Repeatable Read',
      'Serializable',
    ],
    correctIndex: 1,
    explanation:
      'Read Committed — уровень изоляции, при котором транзакция видит только данные, зафиксированные другими транзакциями (committed). Это предотвращает «грязное чтение» (dirty read), когда транзакция читает незафиксированные изменения другой транзакции, которая может быть откачена. Read Committed — уровень по умолчанию в PostgreSQL, Oracle, SQL Server. Однако он не защищает от «неповторяемого чтения» (non-repeatable read) — повторный SELECT может вернуть другие данные, если параллельная транзакция успела зафиксировать изменения. Read Uncommitted — минимальная изоляция, допускает грязное чтение. Repeatable Read — гарантирует стабильность прочитанных строк. Serializable — максимальная изоляция, эмулирующая последовательное выполнение.',
  },
  {
    id: 'sa-databases-009',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Для чего используется индекс (INDEX) в реляционной базе данных?',
    options: [
      'Для шифрования данных в таблице',
      'Для ускорения поиска и выборки данных по определённым столбцам',
      'Для автоматического резервного копирования таблицы',
      'Для ограничения доступа к конкретным строкам',
    ],
    correctIndex: 1,
    explanation:
      'Индекс — структура данных, ускоряющая операции поиска и выборки (SELECT, WHERE, JOIN, ORDER BY) по определённым столбцам таблицы. Без индекса СУБД выполняет полное сканирование таблицы (full table scan), проверяя каждую строку. Индекс работает аналогично предметному указателю в книге — позволяет быстро найти нужные данные без перебора. Компромисс: индексы ускоряют чтение, но замедляют запись (INSERT, UPDATE, DELETE), так как при каждом изменении данных индекс тоже должен обновляться. Также индексы занимают дополнительное дисковое пространство. Поэтому индексы создаются только для часто используемых в запросах столбцов.',
  },
  {
    id: 'sa-databases-010',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL-базы данных хранит данные в виде узлов и рёбер, оптимально подходя для моделирования социальных сетей и рекомендательных систем?',
    options: [
      'Документная (Document Store)',
      'Колоночная (Column-Family Store)',
      'Ключ-значение (Key-Value Store)',
      'Графовая (Graph Database)',
    ],
    correctIndex: 3,
    explanation:
      'Графовые базы данных (Neo4j, Amazon Neptune, JanusGraph) хранят данные в виде графа: узлы (nodes) представляют сущности, рёбра (edges) — связи между ними, оба могут иметь свойства. Графовые БД оптимальны для запросов, связанных с обходом графа: «друзья друзей», «кратчайший путь», «рекомендации на основе связей», детекция мошенничества, управление знаниями. Язык запросов — Cypher (Neo4j), Gremlin, SPARQL. Документные БД (MongoDB) хранят JSON/BSON-документы. Колоночные (Cassandra, HBase) оптимизированы для записи и аналитических запросов. Ключ-значение (Redis, DynamoDB) — простейшая модель для кэширования и сессий.',
  },
  {
    id: 'sa-databases-011',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое MVCC (Multi-Version Concurrency Control) и зачем этот механизм используется в базах данных?',
    sampleAnswer:
      'MVCC (Multi-Version Concurrency Control) — механизм управления конкурентным доступом, при котором СУБД хранит несколько версий одной и той же строки данных. Когда транзакция обновляет строку, создаётся новая версия, а старая сохраняется до тех пор, пока она нужна другим активным транзакциям. Чтение данных никогда не блокирует запись, и наоборот — каждая транзакция видит согласованный «снимок» данных на определённый момент времени. Это радикально повышает производительность при параллельной работе множества пользователей. MVCC используется в PostgreSQL, Oracle, MySQL (InnoDB). Например, в PostgreSQL каждая строка имеет атрибуты xmin (ID создавшей транзакции) и xmax (ID удалившей/обновившей транзакции), что позволяет определить видимость версии для конкретной транзакции. Недостаток MVCC — накопление старых версий (bloat), требующее периодической очистки (VACUUM в PostgreSQL).',
    explanation:
      'MVCC решает фундаментальную проблему «читатели блокируют писателей» традиционного блокировочного подхода. Без MVCC SELECT мог бы блокировать UPDATE и наоборот, что критично для высоконагруженных систем. Аналитик должен понимать MVCC для грамотного проектирования транзакционной логики и понимания особенностей разных уровней изоляции.',
  },
  {
    id: 'sa-databases-012',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип индекса наиболее универсален и используется по умолчанию в большинстве реляционных СУБД?',
    options: [
      'Hash-индекс',
      'B-tree (сбалансированное дерево)',
      'Bitmap-индекс',
      'GIN-индекс (Generalized Inverted Index)',
    ],
    correctIndex: 1,
    explanation:
      'B-tree (balanced tree) — наиболее универсальный тип индекса, используемый по умолчанию в PostgreSQL, MySQL, Oracle, SQL Server. B-tree поддерживает операции равенства (=), диапазонные запросы (<, >, BETWEEN), сортировку (ORDER BY) и поиск по префиксу (LIKE \'abc%\'). Данные в B-tree хранятся в отсортированном виде, что обеспечивает логарифмическую сложность поиска O(log n). Hash-индекс оптимален только для точного равенства (=), не поддерживает диапазоны. Bitmap-индекс эффективен для столбцов с малым количеством уникальных значений (пол, статус) в OLAP-системах. GIN-индекс используется для полнотекстового поиска и индексации массивов/JSONB.',
  },
  {
    id: 'sa-databases-013',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какая аномалия при параллельном выполнении транзакций возникает, когда транзакция повторно читает те же данные и получает другой результат из-за фиксации изменений другой транзакцией?',
    options: [
      'Грязное чтение (Dirty Read)',
      'Неповторяемое чтение (Non-Repeatable Read)',
      'Фантомное чтение (Phantom Read)',
      'Потерянное обновление (Lost Update)',
    ],
    correctIndex: 1,
    explanation:
      'Неповторяемое чтение (Non-Repeatable Read) — аномалия, при которой транзакция дважды читает одну и ту же строку и получает разные значения, потому что между чтениями другая транзакция обновила и зафиксировала эту строку. Пример: транзакция A читает баланс = 1000, транзакция B изменяет его на 500 и фиксирует, транзакция A повторно читает баланс = 500. Грязное чтение — чтение незафиксированных данных. Фантомное чтение — появление или исчезновение строк в результате повторного запроса (INSERT/DELETE другой транзакции). Потерянное обновление — две транзакции читают одни данные и перезаписывают друг друга. Уровень Repeatable Read предотвращает неповторяемое чтение.',
  },
  {
    id: 'sa-databases-014',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое polyglot persistence и в каких случаях этот подход оправдан? Приведите пример системы, использующей несколько типов баз данных.',
    sampleAnswer:
      'Polyglot persistence — подход, при котором в рамках одной системы используются разные типы баз данных, каждая из которых оптимальна для своей задачи. Вместо использования одной универсальной СУБД для всех нужд, разные компоненты системы работают с теми хранилищами, которые лучше соответствуют их паттернам доступа к данным. Пример интернет-магазина: PostgreSQL — основная реляционная БД для заказов, пользователей и каталога товаров (ACID-транзакции, сложные запросы); Redis — кэширование сессий пользователей, корзин покупок, часто запрашиваемых данных (низкая латентность, TTL); Elasticsearch — полнотекстовый поиск по каталогу товаров (фасетный поиск, ранжирование); ClickHouse — аналитика и отчётность (быстрые агрегирующие запросы по большим объёмам данных); MongoDB — хранение логов и нетипизированных пользовательских данных (гибкая схема). Подход оправдан, когда система имеет разнородные требования к хранению и обработке данных. Риски: увеличение операционной сложности (нужно администрировать несколько СУБД), сложность обеспечения консистентности между хранилищами.',
    explanation:
      'Polyglot persistence — следствие принципа «right tool for the job». В микросервисной архитектуре каждый сервис может выбрать оптимальную СУБД. Аналитик должен обосновать выбор каждого хранилища через анализ паттернов доступа, объёмов данных и нефункциональных требований (латентность, пропускная способность, консистентность).',
  },
  {
    id: 'sa-databases-015',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой подход к миграции схемы базы данных подразумевает применение последовательных скриптов изменений (версионируемых миграций)?',
    options: [
      'Shadow Database',
      'Versioned Migrations (Flyway, Liquibase)',
      'Database Dump & Restore',
      'Manual DDL Execution',
    ],
    correctIndex: 1,
    explanation:
      'Versioned Migrations — подход, при котором каждое изменение схемы БД описывается отдельным скриптом (миграцией) с порядковым номером или временной меткой. Миграции применяются последовательно, и специальная таблица (например, flyway_schema_history) отслеживает, какие миграции уже применены. Инструменты: Flyway, Liquibase, Alembic (Python), Knex (Node.js). Преимущества: версионирование схемы вместе с кодом (в Git), воспроизводимость (любой разработчик или CI/CD может привести БД к актуальному состоянию), аудит изменений, поддержка rollback-скриптов. Shadow Database — копия БД для тестирования миграций. Dump & Restore — одноразовая операция, не подходит для итеративной разработки. Manual DDL — ручное выполнение SQL, подверженное ошибкам.',
  },
  {
    id: 'sa-databases-016',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций в SQL полностью предотвращает все аномалии параллельного выполнения, но может значительно снизить производительность?',
    options: [
      'Read Committed',
      'Repeatable Read',
      'Serializable',
      'Snapshot Isolation',
    ],
    correctIndex: 2,
    explanation:
      'Serializable — самый строгий уровень изоляции, гарантирующий, что результат параллельного выполнения транзакций эквивалентен некоторому последовательному выполнению. Предотвращает все аномалии: грязное чтение, неповторяемое чтение, фантомное чтение и аномалию сериализации (write skew). Реализация зависит от СУБД: в PostgreSQL Serializable реализован через SSI (Serializable Snapshot Isolation) — оптимистичный подход, который откатывает транзакцию при обнаружении конфликта сериализации. В MySQL — через блокировки промежутков (gap locks). Компромисс: максимальная корректность ценой снижения пропускной способности и увеличения количества откатов. Snapshot Isolation — промежуточный уровень (не входит в стандарт SQL), предотвращает большинство аномалий, но допускает write skew.',
  },
  {
    id: 'sa-databases-017',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите стратегии оптимизации медленных SQL-запросов. Какие инструменты и подходы используются для диагностики проблем производительности?',
    sampleAnswer:
      'Стратегии оптимизации SQL-запросов: (1) Анализ плана выполнения: EXPLAIN ANALYZE (PostgreSQL), EXPLAIN FORMAT=JSON (MySQL) показывают, как СУБД выполняет запрос — сканирование таблиц, используемые индексы, оценки кардинальности, стоимость операций. Ключевое — искать Seq Scan на больших таблицах, Nested Loop на больших выборках, Sort на неиндексированных столбцах. (2) Индексирование: создание индексов по столбцам в WHERE, JOIN, ORDER BY. Составные индексы — учитывать порядок столбцов (leftmost prefix rule). Покрывающие индексы (covering index / INCLUDE) — если все нужные столбцы есть в индексе, таблица не читается. (3) Переписывание запросов: замена подзапросов на JOIN, использование EXISTS вместо IN для коррелированных подзапросов, избегание функций на индексированных столбцах (WHERE UPPER(name) — индекс не используется). (4) Партиционирование: разбиение больших таблиц по диапазону (дата), списку или хешу — СУБД сканирует только нужные партиции (partition pruning). (5) Денормализация: материализованные представления, предвычисленные агрегаты для частых аналитических запросов. (6) Инструменты: pg_stat_statements (PostgreSQL), Performance Schema (MySQL), slow query log, APM-системы (Datadog, New Relic).',
    explanation:
      'Оптимизация запросов — итеративный процесс: измерение → анализ плана выполнения → гипотеза → изменение → повторное измерение. Аналитик должен уметь читать план выполнения и формулировать рекомендации для разработчиков. Частые ошибки: создание индексов «на всё» (замедляет запись), игнорирование статистики таблиц (ANALYZE), оптимизация запросов без понимания бизнес-контекста.',
  },
  {
    id: 'sa-databases-018',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой тип базы данных специально оптимизирован для хранения и анализа данных с временными метками (метрики, IoT-сенсоры, логи)?',
    options: [
      'Документная база данных',
      'Графовая база данных',
      'Time-Series Database (база данных временных рядов)',
      'Колоночное хранилище общего назначения',
    ],
    correctIndex: 2,
    explanation:
      'Time-Series Database (TSDB) — специализированный тип базы данных для хранения и анализа данных временных рядов: последовательностей точек данных, индексированных по времени. Примеры: InfluxDB, TimescaleDB (расширение PostgreSQL), Prometheus, VictoriaMetrics. Оптимизации TSDB: эффективная компрессия (соседние точки часто близки по значению), быстрая запись (append-only), эффективные агрегирующие запросы по временным окнам (средняя температура за час), автоматическое удаление старых данных (retention policy), downsampling (агрегирование старых данных для экономии места). Применение: мониторинг инфраструктуры, IoT-сенсоры, финансовые котировки, телеметрия приложений.',
  },
  {
    id: 'sa-databases-019',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните стратегии миграции баз данных: Big Bang migration и постепенную (incremental) миграцию. Какие риски несёт каждый подход и как их минимизировать?',
    sampleAnswer:
      'Big Bang migration — одномоментный перенос всех данных из старой системы в новую с последующим переключением всех пользователей. Преимущества: простота планирования (один момент переключения), нет необходимости поддерживать синхронизацию между старой и новой системами. Риски: длительный простой (downtime), высокий риск — при неудаче откатить сложно, все ошибки обнаруживаются одновременно. Минимизация: тщательное тестирование на копии prod-данных, rehearsal-миграции, чёткий план отката. Постепенная (incremental) миграция — данные и пользователи переносятся поэтапно, старая и новая системы работают параллельно. Подходы: параллельный запуск (dual write/read), Strangler Fig-паттерн (постепенная замена компонентов), миграция по группам пользователей / модулям. Преимущества: минимальный простой, возможность обнаружить проблемы на ранних этапах, лёгкий откат отдельного этапа. Риски: сложность синхронизации данных между системами (CDC, двойная запись), длительный период поддержки двух систем, консистентность данных. Минимизация: чёткая стратегия синхронизации, мониторинг расхождений, автоматические проверки целостности.',
    explanation:
      'Выбор стратегии миграции зависит от: допустимого downtime, объёма данных, сложности схемы, количества зависимых систем и толерантности бизнеса к рискам. Аналитик играет ключевую роль в планировании миграции: маппинг полей между схемами, правила трансформации данных, обработка некорректных данных, критерии успешности миграции.',
  },
  {
    id: 'sa-databases-020',
    block: 'sa',
    topic: 'databases',
    topicLabel: 'Базы данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип индекса в PostgreSQL оптимален для столбцов с малым количеством уникальных значений (например, пол, статус заказа) в OLAP-сценариях?',
    options: [
      'B-tree индекс',
      'Hash-индекс',
      'BRIN-индекс (Block Range Index)',
      'Bitmap-индекс (через bitmap-scan при комбинировании индексов)',
    ],
    correctIndex: 3,
    explanation:
      'Bitmap-индексирование эффективно для столбцов с низкой кардинальностью (малым количеством уникальных значений). В PostgreSQL нет явного Bitmap-индекса как отдельного типа (в отличие от Oracle), но оптимизатор автоматически использует Bitmap Index Scan — преобразует результаты нескольких B-tree или других индексов в битовые карты, объединяет их (AND/OR) и затем обращается к таблице. Это особенно эффективно при комбинировании условий по нескольким столбцам с низкой кардинальностью. B-tree — универсален, но избыточен для двух-трёх значений. Hash — только для точного равенства. BRIN — эффективен для физически упорядоченных данных (например, временные метки в append-only таблицах).',
  },
];
