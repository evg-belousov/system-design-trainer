import type { QuizQuestion, OpenQuestion } from '../types';

export const questions: (QuizQuestion | OpenQuestion)[] = [
  {
    id: 'sa-data-modeling-001',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что описывает ER-диаграмма (Entity-Relationship Diagram)?',
    options: [
      'Последовательность обмена сообщениями между системами',
      'Структуру данных: сущности, их атрибуты и связи между ними',
      'Потоки управления в бизнес-процессе',
      'Архитектуру развёртывания компонентов системы',
    ],
    correctIndex: 1,
    explanation:
      'ER-диаграмма (Entity-Relationship Diagram) — инструмент для визуального представления структуры данных предметной области. Она показывает сущности (entities) — объекты, о которых хранится информация; атрибуты (attributes) — характеристики сущностей; и связи (relationships) — отношения между сущностями. Существует несколько нотаций: нотация Чена (оригинальная), нотация «воронья лапка» (Crow\'s Foot, наиболее популярная), IDEF1X, UML Class Diagram. ER-диаграмма является одним из ключевых артефактов системного аналитика при проектировании баз данных.',
  },
  {
    id: 'sa-data-modeling-002',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая кардинальность связи между сущностями «Заказ» и «Строка заказа» наиболее корректна?',
    options: [
      'Один к одному (1:1)',
      'Один ко многим (1:N)',
      'Многие ко многим (M:N)',
      'Нет связи',
    ],
    correctIndex: 1,
    explanation:
      'Связь между «Заказ» и «Строка заказа» — один ко многим (1:N): один заказ содержит одну или несколько строк заказа, а каждая строка принадлежит ровно одному заказу. Строка заказа является слабой (зависимой) сущностью — она не может существовать без заказа. В реляционной модели это реализуется через внешний ключ order_id в таблице order_items, который ссылается на первичный ключ таблицы orders. Связь «один к одному» означала бы, что в заказе ровно одна позиция, что некорректно. Связь «многие ко многим» означала бы, что одна строка может принадлежать нескольким заказам.',
  },
  {
    id: 'sa-data-modeling-003',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое первая нормальная форма (1NF)?',
    options: [
      'Все неключевые атрибуты зависят от всего первичного ключа',
      'Все атрибуты атомарны (неделимы), и таблица не содержит повторяющихся групп',
      'Отсутствуют транзитивные зависимости неключевых атрибутов',
      'Все детерминанты являются потенциальными ключами',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1NF) требует, чтобы: (1) все значения атрибутов были атомарными (неделимыми) — нельзя хранить список значений в одной ячейке; (2) таблица не содержала повторяющихся групп столбцов; (3) каждая строка была уникальной (наличие первичного ключа). Пример нарушения 1NF: столбец «Телефоны» содержит «+7-999-111-11-11, +7-999-222-22-22» — это не атомарное значение. Решение: вынести телефоны в отдельную таблицу. Вторая нормальная форма (2NF) — зависимость от полного ключа. Третья (3NF) — отсутствие транзитивных зависимостей. BCNF — все детерминанты являются потенциальными ключами.',
  },
  {
    id: 'sa-data-modeling-004',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое суррогатный ключ (Surrogate Key)?',
    options: [
      'Ключ, составленный из нескольких бизнес-атрибутов',
      'Искусственно сгенерированный ключ, не имеющий бизнес-смысла (например, автоинкрементный ID)',
      'Внешний ключ, ссылающийся на родительскую таблицу',
      'Ключ, унаследованный из внешней системы',
    ],
    correctIndex: 1,
    explanation:
      'Суррогатный ключ (Surrogate Key) — это искусственно созданный идентификатор, не несущий бизнес-смысла: автоинкрементное число, UUID, sequence. Преимущества: стабильность (не меняется при изменении бизнес-данных), простота (одно поле вместо составного ключа), производительность (компактный, эффективный для индексов и JOIN). Натуральный ключ (Natural Key) — идентификатор из предметной области: ИНН, номер паспорта, email. Преимущества: бизнес-смысл, не требует дополнительного столбца. Недостатки: может меняться (смена фамилии, номера паспорта), может быть составным и длинным. В большинстве проектов используют суррогатные ключи с уникальными индексами на натуральные ключи.',
  },
  {
    id: 'sa-data-modeling-005',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой уровень модели данных описывает сущности и связи предметной области без привязки к конкретной СУБД?',
    options: [
      'Физическая модель',
      'Логическая модель',
      'Концептуальная модель',
      'Инфологическая модель',
    ],
    correctIndex: 2,
    explanation:
      'Концептуальная модель данных — наиболее абстрактный уровень, описывающий ключевые сущности предметной области и их взаимосвязи без деталей реализации. Она не содержит атрибутов, типов данных или ключей — только сущности и связи. Создаётся для коммуникации с бизнес-стейкхолдерами. Логическая модель добавляет атрибуты, типы данных, ключи, нормализацию, но остаётся независимой от конкретной СУБД. Физическая модель — детальная схема для конкретной СУБД: имена таблиц и столбцов, индексы, партиционирование, табличные пространства. Переход от концептуальной к физической — итеративный процесс детализации.',
  },
  {
    id: 'sa-data-modeling-006',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните, что такое ссылочная целостность (Referential Integrity) и почему она важна в реляционных базах данных.',
    sampleAnswer:
      'Ссылочная целостность (Referential Integrity) — ограничение реляционной базы данных, гарантирующее, что каждое значение внешнего ключа (Foreign Key) соответствует существующему значению первичного ключа (Primary Key) в связанной таблице, либо является NULL. Проще говоря, нельзя создать запись, ссылающуюся на несуществующую родительскую запись. Пример: в таблице orders поле customer_id ссылается на таблицу customers. Ссылочная целостность гарантирует, что невозможно создать заказ для несуществующего клиента, а также что нельзя удалить клиента, если у него есть заказы (или можно настроить каскадное удаление). Реализуется через FOREIGN KEY constraint с правилами ON DELETE (CASCADE, SET NULL, RESTRICT, NO ACTION) и ON UPDATE. Важность: предотвращает «сиротские» записи (orphan records), обеспечивает согласованность данных, делает модель данных самодокументируемой — ограничения явно описывают связи между таблицами.',
    explanation:
      'Ссылочная целостность — один из фундаментальных механизмов обеспечения качества данных в РСУБД. Системный аналитик должен при проектировании модели данных явно определять все внешние ключи и правила каскадных операций. В NoSQL-базах данных ссылочная целостность не поддерживается на уровне СУБД и должна обеспечиваться на уровне приложения, что является одним из ключевых компромиссов при выборе NoSQL.',
  },
  {
    id: 'sa-data-modeling-007',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Таблица имеет составной первичный ключ (A, B) и неключевой атрибут C, который зависит только от A, но не от B. Какую нормальную форму нарушает эта таблица?',
    options: [
      'Первую нормальную форму (1NF)',
      'Вторую нормальную форму (2NF)',
      'Третью нормальную форму (3NF)',
      'Нормальную форму Бойса-Кодда (BCNF)',
    ],
    correctIndex: 1,
    explanation:
      'Вторая нормальная форма (2NF) требует, чтобы каждый неключевой атрибут зависел от ВСЕГО первичного ключа, а не от его части. Если атрибут C зависит только от A (части составного ключа A,B), это называется частичной функциональной зависимостью (partial dependency), что нарушает 2NF. Решение: вынести атрибут C в отдельную таблицу с первичным ключом A. Пример: таблица «Оценки студентов» с ключом (StudentID, CourseID) и атрибутом StudentName — StudentName зависит только от StudentID, нарушая 2NF. 2NF актуальна только при составном первичном ключе; таблица с простым ключом автоматически находится в 2NF, если она в 1NF.',
  },
  {
    id: 'sa-data-modeling-008',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое транзитивная зависимость и какую нормальную форму она нарушает?',
    options: [
      'Зависимость части ключа от другой части; нарушает 2NF',
      'Зависимость неключевого атрибута от другого неключевого атрибута через первичный ключ; нарушает 3NF',
      'Зависимость ключа от неключевого атрибута; нарушает BCNF',
      'Многозначная зависимость между атрибутами; нарушает 4NF',
    ],
    correctIndex: 1,
    explanation:
      'Транзитивная зависимость возникает, когда неключевой атрибут C зависит от первичного ключа A не напрямую, а через другой неключевой атрибут B: A → B → C. Это нарушает третью нормальную форму (3NF), которая требует отсутствия транзитивных зависимостей неключевых атрибутов от первичного ключа. Пример: таблица «Сотрудники» с ключом EmployeeID содержит DepartmentID и DepartmentName. DepartmentName зависит от DepartmentID, а не от EmployeeID напрямую — это транзитивная зависимость. Решение: вынести DepartmentName в отдельную таблицу Departments. BCNF ужесточает 3NF: каждый детерминант должен быть потенциальным ключом.',
  },
  {
    id: 'sa-data-modeling-009',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'DFD (Data Flow Diagram) уровня 0 также называется:',
    options: [
      'Детальная диаграмма процессов',
      'Контекстная диаграмма (Context Diagram)',
      'Диаграмма сущностей',
      'Физическая диаграмма данных',
    ],
    correctIndex: 1,
    explanation:
      'DFD уровня 0, или контекстная диаграмма, показывает систему как единый процесс («чёрный ящик») и её взаимодействие с внешними сущностями (external entities). Она определяет границы системы: какие данные входят и выходят, кто является источниками и потребителями данных. DFD уровня 1 декомпозирует систему на основные процессы. DFD уровня 2 и далее — детализация отдельных процессов. Нотации DFD: Yourdon-DeMarco (круги для процессов) и Gane-Sarson (прямоугольники с закруглёнными углами). Элементы DFD: процессы, хранилища данных, внешние сущности и потоки данных. DFD не показывает потоки управления — только данные.',
  },
  {
    id: 'sa-data-modeling-010',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое словарь данных (Data Dictionary) в контексте проектирования данных?',
    options: [
      'Глоссарий бизнес-терминов проекта',
      'Структурированное описание всех элементов данных: таблиц, полей, типов, ограничений, связей и бизнес-определений',
      'Список SQL-запросов к базе данных',
      'Каталог API-эндпоинтов системы',
    ],
    correctIndex: 1,
    explanation:
      'Словарь данных (Data Dictionary) — централизованный репозиторий метаданных, описывающий все элементы данных системы. Для каждого элемента указываются: имя (логическое и физическое), тип данных, размер, допустимые значения (домен), ограничения (NOT NULL, UNIQUE, CHECK), значение по умолчанию, бизнес-описание, источник данных, связи с другими элементами. Data Dictionary обеспечивает единое понимание данных между аналитиками, разработчиками и бизнесом. Он может быть реализован как отдельный документ, раздел SRS, wiki-страница или поддерживаться инструментами управления метаданными (data catalog). В крупных организациях Data Dictionary — часть более широкой дисциплины Data Governance.',
  },
  {
    id: 'sa-data-modeling-011',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните разницу между нормализацией и денормализацией. Когда и почему применяется денормализация?',
    sampleAnswer:
      'Нормализация — процесс организации данных в базе для минимизации избыточности (redundancy) и аномалий модификации (insertion, update, deletion anomalies). Данные разделяются на связанные таблицы по правилам нормальных форм (1NF → 2NF → 3NF → BCNF и далее). Денормализация — намеренное введение контролируемой избыточности для повышения производительности чтения. Это не «ненормализованная» схема, а осознанное отступление от нормальных форм после проведения нормализации. Применяется, когда: (1) частые JOIN-запросы к нескольким таблицам создают bottleneck производительности; (2) требуются быстрые отчёты и аналитические запросы (OLAP-сценарии); (3) данные читаются значительно чаще, чем модифицируются; (4) при проектировании кеша или материализованных представлений. Типичные приёмы: добавление вычисляемых/агрегатных полей, дублирование атрибутов из связанных таблиц, создание сводных таблиц, материализованных представлений. Риски: аномалии обновления (нужно обновлять данные в нескольких местах), увеличение объёма хранения, усложнение логики поддержания согласованности.',
    explanation:
      'Золотое правило: «Нормализуй модель данных, денормализуй только с обоснованием и документированием». Денормализация — это оптимизация, и как любая оптимизация, она должна основываться на измерениях (профилирование запросов, explain plan), а не на предположениях. Аналитик должен документировать каждое решение о денормализации: какая проблема решается, какие риски принимаются, как обеспечивается согласованность.',
  },
  {
    id: 'sa-data-modeling-012',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Как правильно моделировать связь «многие ко многим» (M:N) в реляционной базе данных? Приведите пример.',
    sampleAnswer:
      'Связь «многие ко многим» (M:N) в реляционной модели реализуется через промежуточную (ассоциативную, связующую) таблицу, которая содержит внешние ключи обеих связанных таблиц. Пример: «Студенты» и «Курсы» — один студент может посещать много курсов, один курс могут посещать много студентов. Создаётся таблица student_courses с полями: student_id (FK → students), course_id (FK → courses). Первичный ключ — составной (student_id, course_id). Промежуточная таблица может содержать дополнительные атрибуты связи: дата записи (enrollment_date), оценка (grade), статус. Если дополнительных атрибутов много, таблица становится полноценной сущностью (Enrollment). Важные аспекты: (1) индексы на оба внешних ключа для производительности JOIN; (2) ограничение уникальности для предотвращения дублирования связей; (3) каскадные правила при удалении (обычно CASCADE — при удалении студента удалять его записи, или RESTRICT — запрещать удаление, если есть связи).',
    explanation:
      'M:N — одна из наиболее частых связей в реальных моделях данных. Промежуточная таблица — единственный способ реализации M:N в реляционной модели. Системный аналитик должен определить: является ли промежуточная таблица «чистой» связью (только ключи) или сущностью с собственными атрибутами; какие бизнес-правила ограничивают связь; какие каскадные операции допустимы.',
  },
  {
    id: 'sa-data-modeling-013',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем нормальная форма Бойса-Кодда (BCNF) отличается от третьей нормальной формы (3NF)?',
    options: [
      'BCNF запрещает многозначные зависимости, а 3NF — нет',
      'BCNF требует, чтобы каждый детерминант был потенциальным ключом, что строже, чем 3NF',
      'BCNF применима только к таблицам с составным ключом',
      'Между ними нет разницы, это синонимы',
    ],
    correctIndex: 1,
    explanation:
      'BCNF (Boyce-Codd Normal Form) — усиленная версия 3NF. 3NF допускает ситуацию, когда неключевой атрибут является детерминантом для части потенциального ключа. BCNF требует, чтобы КАЖДЫЙ детерминант (атрибут, от которого функционально зависят другие атрибуты) являлся потенциальным ключом (candidate key). Пример отличия: таблица «Расписание» с атрибутами (Студент, Предмет, Преподаватель), где каждый преподаватель ведёт только один предмет. Ключ: (Студент, Предмет). Зависимость: Преподаватель → Предмет. Преподаватель — детерминант, но не потенциальный ключ, что нарушает BCNF, но допустимо в 3NF (так как Предмет — часть ключа). На практике разница между 3NF и BCNF проявляется редко.',
  },
  {
    id: 'sa-data-modeling-014',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип схемы используется в хранилищах данных, где центральная таблица фактов окружена таблицами измерений?',
    options: [
      'Схема «снежинка» (Snowflake Schema)',
      'Схема «звезда» (Star Schema)',
      'Схема «созвездие» (Galaxy Schema)',
      'Нормализованная схема третьей нормальной формы',
    ],
    correctIndex: 1,
    explanation:
      'Схема «звезда» (Star Schema) — наиболее распространённая модель организации данных в хранилищах данных (Data Warehouse). В центре — таблица фактов (Fact Table), содержащая метрики и внешние ключи. Вокруг — денормализованные таблицы измерений (Dimension Tables): время, продукт, клиент, география. Преимущества: простота запросов (минимум JOIN), высокая производительность OLAP-запросов, понятность для бизнес-пользователей. Схема «снежинка» — вариант звезды, в котором таблицы измерений нормализованы (например, продукт → категория → группа). Схема «созвездие» — несколько таблиц фактов, разделяющих общие измерения. Star Schema предложена Ральфом Кимбаллом как основа методологии Dimensional Modeling.',
  },
  {
    id: 'sa-data-modeling-015',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какая нормальная форма устраняет многозначные зависимости (Multivalued Dependencies)?',
    options: [
      'Третья нормальная форма (3NF)',
      'Нормальная форма Бойса-Кодда (BCNF)',
      'Четвёртая нормальная форма (4NF)',
      'Пятая нормальная форма (5NF)',
    ],
    correctIndex: 2,
    explanation:
      'Четвёртая нормальная форма (4NF) устраняет многозначные зависимости (Multivalued Dependencies, MVD). MVD возникает, когда для одного значения атрибута A существует множество независимых значений атрибутов B и C. Пример: Преподаватель может вести несколько предметов И знать несколько языков — это два независимых множества, их декартово произведение создаёт избыточность. Таблица (Преподаватель, Предмет, Язык) находится в BCNF, но нарушает 4NF. Решение: разделить на две таблицы — (Преподаватель, Предмет) и (Преподаватель, Язык). 5NF (Join Dependency) устраняет ещё более тонкие аномалии, связанные с декомпозицией, которая не сводится к бинарным проекциям.',
  },
  {
    id: 'sa-data-modeling-016',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Вам нужно спроектировать модель данных для аналитического хранилища данных (Data Warehouse) интернет-магазина. Опишите подход к проектированию, выбор между Star и Snowflake Schema, и ключевые решения.',
    sampleAnswer:
      'Проектирование DWH для интернет-магазина по методологии Dimensional Modeling (Ральф Кимбалл): (1) Определение бизнес-процесса — начинаем с ключевого процесса: продажи (orders). (2) Определение гранулярности (grain) — одна строка таблицы фактов = одна строка заказа (order_item). Это самый детальный уровень, позволяющий агрегировать данные любым способом. (3) Таблица фактов fact_sales: order_item_id, order_id, date_key (FK), product_key (FK), customer_key (FK), promotion_key (FK), store_key (FK), quantity, unit_price, discount_amount, total_amount. Метрики: аддитивные (quantity, total_amount — суммируются по всем измерениям), полуаддитивные (account_balance — суммируется не по всем измерениям), неаддитивные (unit_price — нельзя суммировать). (4) Таблицы измерений: dim_date (calendar_date, day_of_week, month, quarter, year, is_holiday), dim_product (product_name, category, subcategory, brand, supplier), dim_customer (name, segment, city, region, registration_date), dim_promotion (promotion_name, type, discount_percent, start_date, end_date). (5) Выбор Star vs Snowflake: для DWH интернет-магазина выбираю Star Schema — денормализованные измерения. Причины: проще запросы для аналитиков (меньше JOIN), лучше производительность OLAP-запросов, современные columnstore-индексы нивелируют избыточность хранения. Snowflake Schema оправдана при очень больших измерениях с частыми обновлениями иерархий или при строгих требованиях к экономии дискового пространства. (6) SCD (Slowly Changing Dimensions): для dim_customer — SCD Type 2 (сохранение истории через суррогатный ключ, даты действия, флаг is_current) для отслеживания изменения сегмента и адреса клиента.',
    explanation:
      'Dimensional Modeling Кимбалла — стандартный подход к проектированию DWH. Ключевые решения аналитика: выбор grain (определяет детализацию), выбор метрик и их аддитивность, стратегия SCD для каждого измерения, выбор Star vs Snowflake. Альтернативный подход — Data Vault (Дэн Линстедт) — нормализованная модель, лучше подходящая для интеграции данных из множества источников, но сложнее для аналитических запросов.',
  },
  {
    id: 'sa-data-modeling-017',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите подход к проектированию модели данных для системы, которая должна работать одновременно с реляционной СУБД (PostgreSQL) и документоориентированной (MongoDB). Как обеспечить согласованность данных?',
    sampleAnswer:
      'Проектирование полиглотной модели данных (Polyglot Persistence): (1) Определение, какие данные хранятся в какой СУБД: PostgreSQL — транзакционные данные с высокими требованиями к целостности (заказы, платежи, пользователи, справочники), сложные связи, отчётность. MongoDB — данные с гибкой/вложенной структурой (каталог товаров с вариативными атрибутами, логи событий, сессии, пользовательские настройки, CMS-контент). (2) Стратегии согласованности: Eventual Consistency через события — при изменении данных в PostgreSQL публикуется событие (через Kafka/RabbitMQ), потребитель обновляет связанные данные в MongoDB. Паттерн Transactional Outbox — запись события в outbox-таблицу в той же транзакции, что и основные данные, затем CDC (Change Data Capture) или polling для доставки. Saga Pattern — для распределённых операций, затрагивающих обе СУБД. (3) Проектирование: создать каноническую модель данных (canonical data model) — единый словарь данных для обеих СУБД, чтобы одни и те же сущности имели согласованные имена и типы. Определить «источник истины» (source of truth) для каждой сущности — одна СУБД владеет данными, вторая хранит копию. Избегать двустороннего обмена одними данными между СУБД — это путь к конфликтам. (4) Мониторинг: реализовать reconciliation-процесс для периодической проверки согласованности данных между СУБД.',
    explanation:
      'Polyglot Persistence — использование разных СУБД для разных типов данных — мощный подход, но с серьёзными операционными издержками. Ключевой принцип: каждая сущность имеет одного «владельца» (source of truth), остальные СУБД хранят проекции. Паттерн Transactional Outbox + CDC (Debezium) — наиболее надёжный способ обеспечения eventual consistency. Системный аналитик должен чётко документировать: границы ответственности каждой СУБД, потоки репликации и гарантии согласованности.',
  },
  {
    id: 'sa-data-modeling-018',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Slowly Changing Dimension (SCD) Type 2 в контексте хранилищ данных?',
    options: [
      'Перезапись текущих значений без сохранения истории',
      'Добавление новой строки для каждого изменения с сохранением полной истории через суррогатный ключ, даты действия и флаг актуальности',
      'Добавление нового столбца для каждого изменённого атрибута',
      'Хранение текущего и предыдущего значений в одной строке',
    ],
    correctIndex: 1,
    explanation:
      'SCD Type 2 — метод сохранения полной истории изменений в таблице измерений. При изменении атрибутов записи: (1) текущая строка помечается как неактуальная (is_current = false, end_date = текущая дата); (2) создаётся новая строка с суррогатным ключом, новыми значениями, start_date = текущая дата, end_date = NULL, is_current = true. Это позволяет связывать факты с состоянием измерения на момент события (point-in-time analysis). SCD Type 1 — перезапись без истории. SCD Type 3 — хранение текущего и предыдущего значений в отдельных столбцах (ограниченная история). SCD Type 6 (Hybrid) — комбинация Type 1, 2 и 3. Выбор типа SCD — одно из ключевых проектных решений при моделировании DWH.',
  },
  {
    id: 'sa-data-modeling-019',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'В чём ключевое отличие схемы «снежинка» (Snowflake) от схемы «звезда» (Star) в хранилище данных?',
    options: [
      'В Snowflake таблица фактов нормализована, а в Star — нет',
      'В Snowflake таблицы измерений нормализованы (разделены на связанные таблицы), а в Star — денормализованы',
      'Snowflake не поддерживает суррогатные ключи',
      'Star Schema не поддерживает иерархии в измерениях',
    ],
    correctIndex: 1,
    explanation:
      'В схеме «звезда» (Star) таблицы измерений денормализованы — все уровни иерархии хранятся в одной таблице (например, dim_product содержит product_name, category, subcategory, brand). В схеме «снежинка» (Snowflake) таблицы измерений нормализованы — иерархии выносятся в отдельные таблицы (dim_product → dim_category → dim_subcategory). Таблица фактов одинакова в обеих схемах. Преимущества Star: простота запросов, меньше JOIN, лучше производительность. Преимущества Snowflake: экономия дискового пространства при больших измерениях, легче обновлять иерархии, лучшая структурированность. На практике Star Schema предпочтительнее для большинства DWH-проектов благодаря простоте и производительности.',
  },
  {
    id: 'sa-data-modeling-020',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Какие факторы вы учитываете при принятии решения о выборе между суррогатными и натуральными ключами для конкретной таблицы? Приведите примеры, когда натуральный ключ предпочтительнее.',
    sampleAnswer:
      'Факторы выбора между суррогатными и натуральными ключами: (1) Стабильность — если натуральный ключ может измениться (фамилия, email, номер телефона), предпочтителен суррогатный. Если ключ стабилен (код ISO страны, ИНН юридического лица), натуральный приемлем. (2) Простота — суррогатный ключ всегда одно поле; натуральный может быть составным (увеличивает размер индексов и FK). (3) Производительность — integer суррогатный ключ компактнее и быстрее для JOIN, чем длинный string натуральный ключ. UUID занимает 16 байт, но плохо подходит для кластерных индексов из-за случайности. (4) Бизнес-смысл — натуральный ключ самодокументирующий (код валюты «USD» понятнее, чем id=42). (5) Интеграция — при обмене данными между системами натуральные ключи позволяют избежать маппинга суррогатных ID. Примеры, когда натуральный ключ предпочтительнее: справочник валют (ISO-код «USD», «EUR»), справочник стран (ISO 3166: «RU», «US»), справочник единиц измерения, таблица настроек (setting_key). Рекомендация: использовать суррогатные ключи для транзакционных и бизнес-сущностей, натуральные — для стабильных справочников небольшого объёма. В обоих случаях добавлять уникальные индексы на натуральные бизнес-идентификаторы.',
    explanation:
      'Выбор типа ключа — одно из наиболее частых проектных решений аналитика. Суррогатные ключи — безопасный выбор по умолчанию, но натуральные ключи для справочников с международными стандартами (ISO) делают модель чище и упрощают интеграцию. В хранилищах данных (DWH) суррогатные ключи обязательны для таблиц измерений с SCD Type 2 — натуральный ключ не уникален при наличии нескольких версий записи.',
  },
];
