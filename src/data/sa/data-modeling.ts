import type { QuizQuestion, OpenQuestion } from '../types';

export const questions: (QuizQuestion | OpenQuestion)[] = [
  {
    id: 'sa-data-modeling-001',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что описывает ER-диаграмма (Entity-Relationship Diagram)?',
    options: [
      'Последовательность обмена сообщениями между системами',
      'Структуру данных: сущности, их атрибуты и связи между ними',
      'Потоки управления в бизнес-процессе',
      'Архитектуру развёртывания компонентов системы',
    ],
    correctIndex: 1,
    explanation:
      'ER-диаграмма (Entity-Relationship Diagram) — инструмент для визуального представления структуры данных предметной области. Она показывает сущности (entities) — объекты, о которых хранится информация; атрибуты (attributes) — характеристики сущностей; и связи (relationships) — отношения между сущностями. Существует несколько нотаций: нотация Чена (оригинальная), нотация «воронья лапка» (Crow\'s Foot, наиболее популярная), IDEF1X, UML Class Diagram. ER-диаграмма является одним из ключевых артефактов системного аналитика при проектировании баз данных.',
  },
  {
    id: 'sa-data-modeling-002',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая кардинальность связи между сущностями «Заказ» и «Строка заказа» наиболее корректна?',
    options: [
      'Один к одному (1:1)',
      'Один ко многим (1:N)',
      'Многие ко многим (M:N)',
      'Нет связи',
    ],
    correctIndex: 1,
    explanation:
      'Связь между «Заказ» и «Строка заказа» — один ко многим (1:N): один заказ содержит одну или несколько строк заказа, а каждая строка принадлежит ровно одному заказу. Строка заказа является слабой (зависимой) сущностью — она не может существовать без заказа. В реляционной модели это реализуется через внешний ключ order_id в таблице order_items, который ссылается на первичный ключ таблицы orders. Связь «один к одному» означала бы, что в заказе ровно одна позиция, что некорректно. Связь «многие ко многим» означала бы, что одна строка может принадлежать нескольким заказам.',
  },
  {
    id: 'sa-data-modeling-003',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое первая нормальная форма (1NF)?',
    options: [
      'Все неключевые атрибуты зависят от всего первичного ключа',
      'Все атрибуты атомарны (неделимы), и таблица не содержит повторяющихся групп',
      'Отсутствуют транзитивные зависимости неключевых атрибутов',
      'Все детерминанты являются потенциальными ключами',
    ],
    correctIndex: 1,
    explanation:
      'Первая нормальная форма (1NF) требует, чтобы: (1) все значения атрибутов были атомарными (неделимыми) — нельзя хранить список значений в одной ячейке; (2) таблица не содержала повторяющихся групп столбцов; (3) каждая строка была уникальной (наличие первичного ключа). Пример нарушения 1NF: столбец «Телефоны» содержит «+7-999-111-11-11, +7-999-222-22-22» — это не атомарное значение. Решение: вынести телефоны в отдельную таблицу. Вторая нормальная форма (2NF) — зависимость от полного ключа. Третья (3NF) — отсутствие транзитивных зависимостей. BCNF — все детерминанты являются потенциальными ключами.',
  },
  {
    id: 'sa-data-modeling-004',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое суррогатный ключ (Surrogate Key)?',
    options: [
      'Ключ, составленный из нескольких бизнес-атрибутов',
      'Искусственно сгенерированный ключ, не имеющий бизнес-смысла (например, автоинкрементный ID)',
      'Внешний ключ, ссылающийся на родительскую таблицу',
      'Ключ, унаследованный из внешней системы',
    ],
    correctIndex: 1,
    explanation:
      'Суррогатный ключ (Surrogate Key) — это искусственно созданный идентификатор, не несущий бизнес-смысла: автоинкрементное число, UUID, sequence. Преимущества: стабильность (не меняется при изменении бизнес-данных), простота (одно поле вместо составного ключа), производительность (компактный, эффективный для индексов и JOIN). Натуральный ключ (Natural Key) — идентификатор из предметной области: ИНН, номер паспорта, email. Преимущества: бизнес-смысл, не требует дополнительного столбца. Недостатки: может меняться (смена фамилии, номера паспорта), может быть составным и длинным. В большинстве проектов используют суррогатные ключи с уникальными индексами на натуральные ключи.',
  },
  {
    id: 'sa-data-modeling-005',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой уровень модели данных описывает сущности и связи предметной области без привязки к конкретной СУБД?',
    options: [
      'Физическая модель',
      'Логическая модель',
      'Концептуальная модель',
      'Инфологическая модель',
    ],
    correctIndex: 2,
    explanation:
      'Концептуальная модель данных — наиболее абстрактный уровень, описывающий ключевые сущности предметной области и их взаимосвязи без деталей реализации. Она не содержит атрибутов, типов данных или ключей — только сущности и связи. Создаётся для коммуникации с бизнес-стейкхолдерами. Логическая модель добавляет атрибуты, типы данных, ключи, нормализацию, но остаётся независимой от конкретной СУБД. Физическая модель — детальная схема для конкретной СУБД: имена таблиц и столбцов, индексы, партиционирование, табличные пространства. Переход от концептуальной к физической — итеративный процесс детализации.',
  },
  {
    id: 'sa-data-modeling-006',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните, что такое ссылочная целостность (Referential Integrity) и почему она важна в реляционных базах данных.',
    sampleAnswer:
      'Ссылочная целостность (Referential Integrity) — ограничение реляционной базы данных, гарантирующее, что каждое значение внешнего ключа (Foreign Key) соответствует существующему значению первичного ключа (Primary Key) в связанной таблице, либо является NULL. Проще говоря, нельзя создать запись, ссылающуюся на несуществующую родительскую запись. Пример: в таблице orders поле customer_id ссылается на таблицу customers. Ссылочная целостность гарантирует, что невозможно создать заказ для несуществующего клиента, а также что нельзя удалить клиента, если у него есть заказы (или можно настроить каскадное удаление). Реализуется через FOREIGN KEY constraint с правилами ON DELETE (CASCADE, SET NULL, RESTRICT, NO ACTION) и ON UPDATE. Важность: предотвращает «сиротские» записи (orphan records), обеспечивает согласованность данных, делает модель данных самодокументируемой — ограничения явно описывают связи между таблицами.',
    explanation:
      'Ссылочная целостность — один из фундаментальных механизмов обеспечения качества данных в РСУБД. Системный аналитик должен при проектировании модели данных явно определять все внешние ключи и правила каскадных операций. В NoSQL-базах данных ссылочная целостность не поддерживается на уровне СУБД и должна обеспечиваться на уровне приложения, что является одним из ключевых компромиссов при выборе NoSQL.',
  },
  {
    id: 'sa-data-modeling-007',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Таблица имеет составной первичный ключ (A, B) и неключевой атрибут C, который зависит только от A, но не от B. Какую нормальную форму нарушает эта таблица?',
    options: [
      'Первую нормальную форму (1NF)',
      'Вторую нормальную форму (2NF)',
      'Третью нормальную форму (3NF)',
      'Нормальную форму Бойса-Кодда (BCNF)',
    ],
    correctIndex: 1,
    explanation:
      'Вторая нормальная форма (2NF) требует, чтобы каждый неключевой атрибут зависел от ВСЕГО первичного ключа, а не от его части. Если атрибут C зависит только от A (части составного ключа A,B), это называется частичной функциональной зависимостью (partial dependency), что нарушает 2NF. Решение: вынести атрибут C в отдельную таблицу с первичным ключом A. Пример: таблица «Оценки студентов» с ключом (StudentID, CourseID) и атрибутом StudentName — StudentName зависит только от StudentID, нарушая 2NF. 2NF актуальна только при составном первичном ключе; таблица с простым ключом автоматически находится в 2NF, если она в 1NF.',
  },
  {
    id: 'sa-data-modeling-008',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое транзитивная зависимость и какую нормальную форму она нарушает?',
    options: [
      'Зависимость части ключа от другой части; нарушает 2NF',
      'Зависимость неключевого атрибута от другого неключевого атрибута через первичный ключ; нарушает 3NF',
      'Зависимость ключа от неключевого атрибута; нарушает BCNF',
      'Многозначная зависимость между атрибутами; нарушает 4NF',
    ],
    correctIndex: 1,
    explanation:
      'Транзитивная зависимость возникает, когда неключевой атрибут C зависит от первичного ключа A не напрямую, а через другой неключевой атрибут B: A → B → C. Это нарушает третью нормальную форму (3NF), которая требует отсутствия транзитивных зависимостей неключевых атрибутов от первичного ключа. Пример: таблица «Сотрудники» с ключом EmployeeID содержит DepartmentID и DepartmentName. DepartmentName зависит от DepartmentID, а не от EmployeeID напрямую — это транзитивная зависимость. Решение: вынести DepartmentName в отдельную таблицу Departments. BCNF ужесточает 3NF: каждый детерминант должен быть потенциальным ключом.',
  },
  {
    id: 'sa-data-modeling-009',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'DFD (Data Flow Diagram) уровня 0 также называется:',
    options: [
      'Детальная диаграмма процессов',
      'Контекстная диаграмма (Context Diagram)',
      'Диаграмма сущностей',
      'Физическая диаграмма данных',
    ],
    correctIndex: 1,
    explanation:
      'DFD уровня 0, или контекстная диаграмма, показывает систему как единый процесс («чёрный ящик») и её взаимодействие с внешними сущностями (external entities). Она определяет границы системы: какие данные входят и выходят, кто является источниками и потребителями данных. DFD уровня 1 декомпозирует систему на основные процессы. DFD уровня 2 и далее — детализация отдельных процессов. Нотации DFD: Yourdon-DeMarco (круги для процессов) и Gane-Sarson (прямоугольники с закруглёнными углами). Элементы DFD: процессы, хранилища данных, внешние сущности и потоки данных. DFD не показывает потоки управления — только данные.',
  },
  {
    id: 'sa-data-modeling-010',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое словарь данных (Data Dictionary) в контексте проектирования данных?',
    options: [
      'Глоссарий бизнес-терминов проекта',
      'Структурированное описание всех элементов данных: таблиц, полей, типов, ограничений, связей и бизнес-определений',
      'Список SQL-запросов к базе данных',
      'Каталог API-эндпоинтов системы',
    ],
    correctIndex: 1,
    explanation:
      'Словарь данных (Data Dictionary) — централизованный репозиторий метаданных, описывающий все элементы данных системы. Для каждого элемента указываются: имя (логическое и физическое), тип данных, размер, допустимые значения (домен), ограничения (NOT NULL, UNIQUE, CHECK), значение по умолчанию, бизнес-описание, источник данных, связи с другими элементами. Data Dictionary обеспечивает единое понимание данных между аналитиками, разработчиками и бизнесом. Он может быть реализован как отдельный документ, раздел SRS, wiki-страница или поддерживаться инструментами управления метаданными (data catalog). В крупных организациях Data Dictionary — часть более широкой дисциплины Data Governance.',
  },
  {
    id: 'sa-data-modeling-011',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните разницу между нормализацией и денормализацией. Когда и почему применяется денормализация?',
    sampleAnswer:
      'Нормализация — процесс организации данных в базе для минимизации избыточности (redundancy) и аномалий модификации (insertion, update, deletion anomalies). Данные разделяются на связанные таблицы по правилам нормальных форм (1NF → 2NF → 3NF → BCNF и далее). Денормализация — намеренное введение контролируемой избыточности для повышения производительности чтения. Это не «ненормализованная» схема, а осознанное отступление от нормальных форм после проведения нормализации. Применяется, когда: (1) частые JOIN-запросы к нескольким таблицам создают bottleneck производительности; (2) требуются быстрые отчёты и аналитические запросы (OLAP-сценарии); (3) данные читаются значительно чаще, чем модифицируются; (4) при проектировании кеша или материализованных представлений. Типичные приёмы: добавление вычисляемых/агрегатных полей, дублирование атрибутов из связанных таблиц, создание сводных таблиц, материализованных представлений. Риски: аномалии обновления (нужно обновлять данные в нескольких местах), увеличение объёма хранения, усложнение логики поддержания согласованности.',
    explanation:
      'Золотое правило: «Нормализуй модель данных, денормализуй только с обоснованием и документированием». Денормализация — это оптимизация, и как любая оптимизация, она должна основываться на измерениях (профилирование запросов, explain plan), а не на предположениях. Аналитик должен документировать каждое решение о денормализации: какая проблема решается, какие риски принимаются, как обеспечивается согласованность.',
  },
  {
    id: 'sa-data-modeling-012',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Как правильно моделировать связь «многие ко многим» (M:N) в реляционной базе данных? Приведите пример.',
    sampleAnswer:
      'Связь «многие ко многим» (M:N) в реляционной модели реализуется через промежуточную (ассоциативную, связующую) таблицу, которая содержит внешние ключи обеих связанных таблиц. Пример: «Студенты» и «Курсы» — один студент может посещать много курсов, один курс могут посещать много студентов. Создаётся таблица student_courses с полями: student_id (FK → students), course_id (FK → courses). Первичный ключ — составной (student_id, course_id). Промежуточная таблица может содержать дополнительные атрибуты связи: дата записи (enrollment_date), оценка (grade), статус. Если дополнительных атрибутов много, таблица становится полноценной сущностью (Enrollment). Важные аспекты: (1) индексы на оба внешних ключа для производительности JOIN; (2) ограничение уникальности для предотвращения дублирования связей; (3) каскадные правила при удалении (обычно CASCADE — при удалении студента удалять его записи, или RESTRICT — запрещать удаление, если есть связи).',
    explanation:
      'M:N — одна из наиболее частых связей в реальных моделях данных. Промежуточная таблица — единственный способ реализации M:N в реляционной модели. Системный аналитик должен определить: является ли промежуточная таблица «чистой» связью (только ключи) или сущностью с собственными атрибутами; какие бизнес-правила ограничивают связь; какие каскадные операции допустимы.',
  },
  {
    id: 'sa-data-modeling-013',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем нормальная форма Бойса-Кодда (BCNF) отличается от третьей нормальной формы (3NF)?',
    options: [
      'BCNF запрещает многозначные зависимости, а 3NF — нет',
      'BCNF требует, чтобы каждый детерминант был потенциальным ключом, что строже, чем 3NF',
      'BCNF применима только к таблицам с составным ключом',
      'Между ними нет разницы, это синонимы',
    ],
    correctIndex: 1,
    explanation:
      'BCNF (Boyce-Codd Normal Form) — усиленная версия 3NF. 3NF допускает ситуацию, когда неключевой атрибут является детерминантом для части потенциального ключа. BCNF требует, чтобы КАЖДЫЙ детерминант (атрибут, от которого функционально зависят другие атрибуты) являлся потенциальным ключом (candidate key). Пример отличия: таблица «Расписание» с атрибутами (Студент, Предмет, Преподаватель), где каждый преподаватель ведёт только один предмет. Ключ: (Студент, Предмет). Зависимость: Преподаватель → Предмет. Преподаватель — детерминант, но не потенциальный ключ, что нарушает BCNF, но допустимо в 3NF (так как Предмет — часть ключа). На практике разница между 3NF и BCNF проявляется редко.',
  },
  {
    id: 'sa-data-modeling-014',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип схемы используется в хранилищах данных, где центральная таблица фактов окружена таблицами измерений?',
    options: [
      'Схема «снежинка» (Snowflake Schema)',
      'Схема «звезда» (Star Schema)',
      'Схема «созвездие» (Galaxy Schema)',
      'Нормализованная схема третьей нормальной формы',
    ],
    correctIndex: 1,
    explanation:
      'Схема «звезда» (Star Schema) — наиболее распространённая модель организации данных в хранилищах данных (Data Warehouse). В центре — таблица фактов (Fact Table), содержащая метрики и внешние ключи. Вокруг — денормализованные таблицы измерений (Dimension Tables): время, продукт, клиент, география. Преимущества: простота запросов (минимум JOIN), высокая производительность OLAP-запросов, понятность для бизнес-пользователей. Схема «снежинка» — вариант звезды, в котором таблицы измерений нормализованы (например, продукт → категория → группа). Схема «созвездие» — несколько таблиц фактов, разделяющих общие измерения. Star Schema предложена Ральфом Кимбаллом как основа методологии Dimensional Modeling.',
  },
  {
    id: 'sa-data-modeling-015',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какая нормальная форма устраняет многозначные зависимости (Multivalued Dependencies)?',
    options: [
      'Третья нормальная форма (3NF)',
      'Нормальная форма Бойса-Кодда (BCNF)',
      'Четвёртая нормальная форма (4NF)',
      'Пятая нормальная форма (5NF)',
    ],
    correctIndex: 2,
    explanation:
      'Четвёртая нормальная форма (4NF) устраняет многозначные зависимости (Multivalued Dependencies, MVD). MVD возникает, когда для одного значения атрибута A существует множество независимых значений атрибутов B и C. Пример: Преподаватель может вести несколько предметов И знать несколько языков — это два независимых множества, их декартово произведение создаёт избыточность. Таблица (Преподаватель, Предмет, Язык) находится в BCNF, но нарушает 4NF. Решение: разделить на две таблицы — (Преподаватель, Предмет) и (Преподаватель, Язык). 5NF (Join Dependency) устраняет ещё более тонкие аномалии, связанные с декомпозицией, которая не сводится к бинарным проекциям.',
  },
  {
    id: 'sa-data-modeling-016',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Вам нужно спроектировать модель данных для аналитического хранилища данных (Data Warehouse) интернет-магазина. Опишите подход к проектированию, выбор между Star и Snowflake Schema, и ключевые решения.',
    sampleAnswer:
      'Проектирование DWH для интернет-магазина по методологии Dimensional Modeling (Ральф Кимбалл): (1) Определение бизнес-процесса — начинаем с ключевого процесса: продажи (orders). (2) Определение гранулярности (grain) — одна строка таблицы фактов = одна строка заказа (order_item). Это самый детальный уровень, позволяющий агрегировать данные любым способом. (3) Таблица фактов fact_sales: order_item_id, order_id, date_key (FK), product_key (FK), customer_key (FK), promotion_key (FK), store_key (FK), quantity, unit_price, discount_amount, total_amount. Метрики: аддитивные (quantity, total_amount — суммируются по всем измерениям), полуаддитивные (account_balance — суммируется не по всем измерениям), неаддитивные (unit_price — нельзя суммировать). (4) Таблицы измерений: dim_date (calendar_date, day_of_week, month, quarter, year, is_holiday), dim_product (product_name, category, subcategory, brand, supplier), dim_customer (name, segment, city, region, registration_date), dim_promotion (promotion_name, type, discount_percent, start_date, end_date). (5) Выбор Star vs Snowflake: для DWH интернет-магазина выбираю Star Schema — денормализованные измерения. Причины: проще запросы для аналитиков (меньше JOIN), лучше производительность OLAP-запросов, современные columnstore-индексы нивелируют избыточность хранения. Snowflake Schema оправдана при очень больших измерениях с частыми обновлениями иерархий или при строгих требованиях к экономии дискового пространства. (6) SCD (Slowly Changing Dimensions): для dim_customer — SCD Type 2 (сохранение истории через суррогатный ключ, даты действия, флаг is_current) для отслеживания изменения сегмента и адреса клиента.',
    explanation:
      'Dimensional Modeling Кимбалла — стандартный подход к проектированию DWH. Ключевые решения аналитика: выбор grain (определяет детализацию), выбор метрик и их аддитивность, стратегия SCD для каждого измерения, выбор Star vs Snowflake. Альтернативный подход — Data Vault (Дэн Линстедт) — нормализованная модель, лучше подходящая для интеграции данных из множества источников, но сложнее для аналитических запросов.',
  },
  {
    id: 'sa-data-modeling-017',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите подход к проектированию модели данных для системы, которая должна работать одновременно с реляционной СУБД (PostgreSQL) и документоориентированной (MongoDB). Как обеспечить согласованность данных?',
    sampleAnswer:
      'Проектирование полиглотной модели данных (Polyglot Persistence): (1) Определение, какие данные хранятся в какой СУБД: PostgreSQL — транзакционные данные с высокими требованиями к целостности (заказы, платежи, пользователи, справочники), сложные связи, отчётность. MongoDB — данные с гибкой/вложенной структурой (каталог товаров с вариативными атрибутами, логи событий, сессии, пользовательские настройки, CMS-контент). (2) Стратегии согласованности: Eventual Consistency через события — при изменении данных в PostgreSQL публикуется событие (через Kafka/RabbitMQ), потребитель обновляет связанные данные в MongoDB. Паттерн Transactional Outbox — запись события в outbox-таблицу в той же транзакции, что и основные данные, затем CDC (Change Data Capture) или polling для доставки. Saga Pattern — для распределённых операций, затрагивающих обе СУБД. (3) Проектирование: создать каноническую модель данных (canonical data model) — единый словарь данных для обеих СУБД, чтобы одни и те же сущности имели согласованные имена и типы. Определить «источник истины» (source of truth) для каждой сущности — одна СУБД владеет данными, вторая хранит копию. Избегать двустороннего обмена одними данными между СУБД — это путь к конфликтам. (4) Мониторинг: реализовать reconciliation-процесс для периодической проверки согласованности данных между СУБД.',
    explanation:
      'Polyglot Persistence — использование разных СУБД для разных типов данных — мощный подход, но с серьёзными операционными издержками. Ключевой принцип: каждая сущность имеет одного «владельца» (source of truth), остальные СУБД хранят проекции. Паттерн Transactional Outbox + CDC (Debezium) — наиболее надёжный способ обеспечения eventual consistency. Системный аналитик должен чётко документировать: границы ответственности каждой СУБД, потоки репликации и гарантии согласованности.',
  },
  {
    id: 'sa-data-modeling-018',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Slowly Changing Dimension (SCD) Type 2 в контексте хранилищ данных?',
    options: [
      'Перезапись текущих значений без сохранения истории',
      'Добавление новой строки для каждого изменения с сохранением полной истории через суррогатный ключ, даты действия и флаг актуальности',
      'Добавление нового столбца для каждого изменённого атрибута',
      'Хранение текущего и предыдущего значений в одной строке',
    ],
    correctIndex: 1,
    explanation:
      'SCD Type 2 — метод сохранения полной истории изменений в таблице измерений. При изменении атрибутов записи: (1) текущая строка помечается как неактуальная (is_current = false, end_date = текущая дата); (2) создаётся новая строка с суррогатным ключом, новыми значениями, start_date = текущая дата, end_date = NULL, is_current = true. Это позволяет связывать факты с состоянием измерения на момент события (point-in-time analysis). SCD Type 1 — перезапись без истории. SCD Type 3 — хранение текущего и предыдущего значений в отдельных столбцах (ограниченная история). SCD Type 6 (Hybrid) — комбинация Type 1, 2 и 3. Выбор типа SCD — одно из ключевых проектных решений при моделировании DWH.',
  },
  {
    id: 'sa-data-modeling-019',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'В чём ключевое отличие схемы «снежинка» (Snowflake) от схемы «звезда» (Star) в хранилище данных?',
    options: [
      'В Snowflake таблица фактов нормализована, а в Star — нет',
      'В Snowflake таблицы измерений нормализованы (разделены на связанные таблицы), а в Star — денормализованы',
      'Snowflake не поддерживает суррогатные ключи',
      'Star Schema не поддерживает иерархии в измерениях',
    ],
    correctIndex: 1,
    explanation:
      'В схеме «звезда» (Star) таблицы измерений денормализованы — все уровни иерархии хранятся в одной таблице (например, dim_product содержит product_name, category, subcategory, brand). В схеме «снежинка» (Snowflake) таблицы измерений нормализованы — иерархии выносятся в отдельные таблицы (dim_product → dim_category → dim_subcategory). Таблица фактов одинакова в обеих схемах. Преимущества Star: простота запросов, меньше JOIN, лучше производительность. Преимущества Snowflake: экономия дискового пространства при больших измерениях, легче обновлять иерархии, лучшая структурированность. На практике Star Schema предпочтительнее для большинства DWH-проектов благодаря простоте и производительности.',
  },
  {
    id: 'sa-data-modeling-020',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Какие факторы вы учитываете при принятии решения о выборе между суррогатными и натуральными ключами для конкретной таблицы? Приведите примеры, когда натуральный ключ предпочтительнее.',
    sampleAnswer:
      'Факторы выбора между суррогатными и натуральными ключами: (1) Стабильность — если натуральный ключ может измениться (фамилия, email, номер телефона), предпочтителен суррогатный. Если ключ стабилен (код ISO страны, ИНН юридического лица), натуральный приемлем. (2) Простота — суррогатный ключ всегда одно поле; натуральный может быть составным (увеличивает размер индексов и FK). (3) Производительность — integer суррогатный ключ компактнее и быстрее для JOIN, чем длинный string натуральный ключ. UUID занимает 16 байт, но плохо подходит для кластерных индексов из-за случайности. (4) Бизнес-смысл — натуральный ключ самодокументирующий (код валюты «USD» понятнее, чем id=42). (5) Интеграция — при обмене данными между системами натуральные ключи позволяют избежать маппинга суррогатных ID. Примеры, когда натуральный ключ предпочтительнее: справочник валют (ISO-код «USD», «EUR»), справочник стран (ISO 3166: «RU», «US»), справочник единиц измерения, таблица настроек (setting_key). Рекомендация: использовать суррогатные ключи для транзакционных и бизнес-сущностей, натуральные — для стабильных справочников небольшого объёма. В обоих случаях добавлять уникальные индексы на натуральные бизнес-идентификаторы.',
    explanation:
      'Выбор типа ключа — одно из наиболее частых проектных решений аналитика. Суррогатные ключи — безопасный выбор по умолчанию, но натуральные ключи для справочников с международными стандартами (ISO) делают модель чище и упрощают интеграцию. В хранилищах данных (DWH) суррогатные ключи обязательны для таблиц измерений с SCD Type 2 — натуральный ключ не уникален при наличии нескольких версий записи.',
  },
  {
    id: 'sa-data-modeling-021',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое домен (Domain) в контексте проектирования данных?',
    options: [
      'Имя веб-сайта',
      'Набор допустимых значений для атрибута (тип данных + ограничения)',
      'Предметная область бизнеса',
      'Сервер базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Домен (Domain) в проектировании данных — набор допустимых значений для атрибута. Включает: базовый тип данных (INTEGER, VARCHAR, DATE), ограничения значений (NOT NULL, CHECK, диапазон), формат (паттерн для строк, точность для чисел). Примеры: домен «Email» — VARCHAR(255), NOT NULL, CHECK (формат email); домен «Возраст» — INTEGER, CHECK (0-150). Использование доменов обеспечивает согласованность типов и ограничений для одинаковых по смыслу атрибутов в разных таблицах. В SQL:1999 домены создаются через CREATE DOMAIN.',
  },
  {
    id: 'sa-data-modeling-022',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип связи между сущностями «Паспорт» и «Человек» наиболее корректен, если каждый человек может иметь только один действующий паспорт?',
    options: [
      'Один к одному (1:1)',
      'Один ко многим (1:N)',
      'Многие ко многим (M:N)',
      'Многие к одному (N:1)',
    ],
    correctIndex: 0,
    explanation:
      'Связь «один к одному» (1:1) означает, что одной записи в таблице A соответствует не более одной записи в таблице B, и наоборот. Применяется когда: данные разделяются по причинам безопасности (PII в отдельной таблице), производительности (редко используемые атрибуты отделяются), или сущность имеет взаимно-однозначное соответствие (человек — действующий паспорт). Реализация: FK с UNIQUE constraint или общий первичный ключ. 1:1 встречается реже, чем 1:N или M:N, и часто сигнализирует о возможности объединения таблиц.',
  },
  {
    id: 'sa-data-modeling-023',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое CHECK constraint в базе данных?',
    options: [
      'Ограничение уникальности значений',
      'Ограничение, проверяющее, что значение атрибута удовлетворяет заданному условию',
      'Ограничение внешнего ключа',
      'Автоматическая проверка прав доступа',
    ],
    correctIndex: 1,
    explanation:
      'CHECK constraint — ограничение целостности, задающее условие, которому должно удовлетворять значение столбца или комбинация столбцов. Примеры: CHECK (age >= 0 AND age <= 150), CHECK (status IN (\'active\', \'inactive\', \'pending\')), CHECK (end_date > start_date). При попытке вставить или обновить данные, нарушающие CHECK, СУБД возвращает ошибку. CHECK реализует бизнес-правила на уровне БД, обеспечивая целостность независимо от приложения.',
  },
  {
    id: 'sa-data-modeling-024',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое нотация Crow\'s Foot и как она отображает кардинальность связей в ER-диаграммах?',
    sampleAnswer:
      'Crow\'s Foot (воронья лапка, IE notation) — популярная нотация для ER-диаграмм, названная по характерному символу. Символы на концах линий связи: Одинарная вертикальная черта (|) — «один», обязательный; Кружок (o) — «ноль», опциональный; «Воронья лапка» (три расходящиеся линии) — «много». Комбинации: |< — «один или много» (1..N, обязательно хотя бы один); o< — «ноль, один или много» (0..N); || — «ровно один» (1..1); o| — «ноль или один» (0..1). Читается от сущности к линии: на стороне «Заказ» стоит |<, на стороне «Товар» — |< → связь M:N (один заказ содержит много товаров, один товар в многих заказах). Crow\'s Foot интуитивна и широко поддерживается инструментами (Lucidchart, draw.io, ER/Studio).',
    explanation:
      'Crow\'s Foot — де-факто стандарт в индустрии благодаря компактности и читаемости. Аналитик должен уметь читать и создавать диаграммы в этой нотации. Альтернативы: нотация Чена (ромбы для связей), IDEF1X (закрашенные/пустые круги), UML (числовые диапазоны).',
  },
  {
    id: 'sa-data-modeling-025',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Temporal Data (временные данные) в контексте моделирования?',
    options: [
      'Данные, которые периодически удаляются',
      'Данные с атрибутами времени, позволяющими отслеживать историю изменений и делать запросы на определённый момент в прошлом',
      'Временные таблицы, существующие только во время сессии',
      'Данные из временных зон',
    ],
    correctIndex: 1,
    explanation:
      'Temporal Data — данные с явным представлением времени, позволяющие отслеживать историю изменений и выполнять point-in-time запросы. Виды: Valid Time (бизнес-время — когда факт истинен в реальном мире), Transaction Time (системное время — когда данные записаны в БД), Bitemporal (оба измерения). Реализация: атрибуты valid_from, valid_to, SCD Type 2 в DWH, temporal tables в SQL:2011 (PostgreSQL, SQL Server, MariaDB). Применение: аудит, отчётность на исторические даты, compliance, анализ изменений.',
  },
  {
    id: 'sa-data-modeling-026',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Master Data Management (MDM)?',
    options: [
      'Система резервного копирования',
      'Дисциплина управления критически важными справочными данными организации для обеспечения единого, достоверного источника',
      'Метод шифрования данных',
      'Инструмент для миграции баз данных',
    ],
    correctIndex: 1,
    explanation:
      'Master Data Management (MDM) — дисциплина, процессы и инструменты для управления критически важными справочными данными (master data): клиенты, продукты, сотрудники, поставщики, локации. Цели: Single Source of Truth (единый источник правды), качество данных, согласованность между системами. Компоненты MDM: golden record (эталонная запись), data stewardship (ответственные за данные), match & merge (дедупликация), data quality rules, data lineage. Стили MDM: Registry (ссылки на источники), Consolidation (копия эталона), Coexistence (двусторонняя синхронизация), Centralized (master как единственный источник). Инструменты: Informatica MDM, IBM InfoSphere, Talend, Reltio.',
  },
  {
    id: 'sa-data-modeling-027',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Data Lineage (происхождение данных)?',
    options: [
      'Версионирование схемы базы данных',
      'Отслеживание жизненного цикла данных: откуда пришли, как трансформировались, куда использовались',
      'Линейный рост объёма данных',
      'Генеалогия владельцев данных',
    ],
    correctIndex: 1,
    explanation:
      'Data Lineage — визуализация и документирование жизненного цикла данных: источники происхождения (откуда данные пришли), трансформации (какие преобразования прошли), использование (где и кем потребляются). Применение: Impact Analysis (что затронет изменение источника?), Root Cause Analysis (откуда ошибка в отчёте?), Compliance (GDPR требует понимать, где персональные данные), Data Governance. Уровни: столбец → таблица → система. Инструменты: Apache Atlas, Collibra, Alation, встроенные возможности ETL-платформ. Lineage может быть получен автоматически (parsing SQL/ETL) или документирован вручную.',
  },
  {
    id: 'sa-data-modeling-028',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните концепцию Data Governance. Какие ключевые элементы она включает?',
    sampleAnswer:
      'Data Governance — система управления данными как стратегическим активом организации. Включает политики, процессы, роли и инструменты для обеспечения качества, безопасности, доступности и соответствия данных требованиям. Ключевые элементы: (1) Роли: Data Owner (владелец — ответственность за качество и использование), Data Steward (стюард — операционное управление), Data Custodian (хранитель — техническая поддержка). (2) Политики: классификация данных (Public, Internal, Confidential, Restricted), retention policies (сроки хранения), access policies, data quality rules. (3) Процессы: управление изменениями метаданных, запросы на доступ, инциденты качества данных. (4) Каталог данных (Data Catalog): реестр всех data assets с метаданными, владельцами, lineage, качеством. (5) Data Quality Management: профилирование, мониторинг метрик качества, remediation. (6) Compliance: соответствие регуляторам (GDPR, HIPAA, PCI DSS). (7) Совет по управлению данными (Data Governance Council): кросс-функциональный орган для принятия решений. Инструменты: Collibra, Alation, Informatica, Atlan.',
    explanation:
      'Data Governance — организационная дисциплина, не только IT-инициатива. Без поддержки бизнеса и ясных ролей governance-программы терпят неудачу. Аналитик участвует в определении бизнес-определений, правил качества и в работе с Data Stewards.',
  },
  {
    id: 'sa-data-modeling-029',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой подход к моделированию хранилищ данных предложен Биллом Инмоном?',
    options: [
      'Dimensional Modeling (Star Schema)',
      'Enterprise Data Warehouse (нормализованная модель с последующей витриной)',
      'Data Vault',
      'Data Lake',
    ],
    correctIndex: 1,
    explanation:
      'Bill Inmon — «отец Data Warehousing». Его подход: построение централизованного Enterprise Data Warehouse (EDW) в нормализованной форме (3NF) как Single Source of Truth. Из EDW строятся Data Marts для конкретных бизнес-направлений. Процесс: Sources → ETL → Normalized EDW → Data Marts. Преимущества: гибкость (EDW можно использовать для любых отчётов), целостность данных. Недостатки: сложность, время на построение. Альтернатива — Dimensional Modeling Ральфа Кимбалла (Star Schema, Data Marts first). Data Vault (Dan Linstedt) — гибридный подход для agile DWH.',
  },
  {
    id: 'sa-data-modeling-030',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Bitemporal Data Model?',
    options: [
      'Модель с двумя таблицами',
      'Модель, отслеживающая два временных измерения: Valid Time (бизнес-время) и Transaction Time (системное время)',
      'Модель для двух временных зон',
      'Модель с двумя версиями схемы',
    ],
    correctIndex: 1,
    explanation:
      'Bitemporal Data Model поддерживает два независимых временных измерения: Valid Time (VT) — когда факт был истинен в реальном мире (бизнес-время); Transaction Time (TT) — когда данные были записаны в систему. Это позволяет отвечать на вопросы: «Какой адрес клиента был 1 января 2020 по состоянию знаний системы на 15 февраля 2020?» Применение: compliance (восстановление отчёта как он выглядел в момент подачи), аудит, исправление ошибок ввода (записи с неверным VT могут быть исправлены, но TT сохраняет историю изменений). Реализация: 4 столбца (valid_from, valid_to, transaction_from, transaction_to) или temporal tables в SQL:2011.',
  },
  {
    id: 'sa-data-modeling-031',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Data Vault — подход к моделированию хранилищ данных?',
    options: [
      'Шифрованное хранилище данных',
      'Методология моделирования DWH, основанная на Hubs (сущности), Links (связи) и Satellites (атрибуты)',
      'Облачное хранилище документов',
      'Система резервного копирования',
    ],
    correctIndex: 1,
    explanation:
      'Data Vault (Dan Linstedt) — методология моделирования DWH, оптимизированная для agile-разработки и интеграции данных из множества источников. Три типа таблиц: Hub — бизнес-ключи сущностей (хэш + натуральный ключ + load date + source), Link — связи между Hubs (хэши связываемых сущностей), Satellite — описательные атрибуты и их история (привязаны к Hub или Link, содержат temporal columns). Преимущества: параллельная загрузка (нет зависимостей между Satellites), полная history, auditable, масштабируемость. Недостатки: сложность запросов (много JOIN), кривая обучения. Data Vault 2.0 добавляет hash keys, Point-in-Time tables для упрощения запросов.',
  },
  {
    id: 'sa-data-modeling-032',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Как проектировать модель данных с учётом требований GDPR? Какие архитектурные решения помогают соответствовать регламенту?',
    sampleAnswer:
      'Архитектурные решения для GDPR-compliant модели данных: (1) Разделение PII: персональные данные (PII) хранятся в отдельных таблицах/сервисах с усиленным контролем доступа. Связь через идентификатор, а не дублирование PII. (2) Data Classification: каждый атрибут классифицирован (PII / sensitive PII / non-PII). Метаданные классификации хранятся в Data Catalog. (3) Right to Erasure (право на удаление): дизайн модели должен позволять удалить все данные субъекта. Решения: soft delete с последующей hard delete, foreign key ON DELETE CASCADE или логика в приложении, pseudonymization вместо удаления для аналитики. (4) Data Portability: возможность экспорта данных субъекта. API или отчёт, возвращающий все данные пользователя. (5) Consent Management: хранение согласий (цель, дата, источник), возможность отзыва. (6) Retention Policies: автоматическое удаление данных после истечения срока хранения. TTL на уровне записей или партиций. (7) Encryption: шифрование PII at rest и in transit. (8) Audit Trail: логирование доступа к персональным данным. (9) Псевдонимизация/Анонимизация: для аналитики и тестовых сред — замена идентификаторов на псевдонимы или необратимое обезличивание. (10) Data Minimization: хранить только необходимые данные.',
    explanation:
      'GDPR влияет на модель данных на всех уровнях. Ключевые принципы: Privacy by Design, Data Minimization, Purpose Limitation. Аналитик должен участвовать в DPIA (Data Protection Impact Assessment) и обеспечить реализуемость прав субъекта (erasure, access, portability) через архитектуру данных.',
  },
  {
    id: 'sa-data-modeling-033',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Metadata Management и какие типы метаданных существуют?',
    options: [
      'Управление данными о размере файлов',
      'Управление «данными о данных»: техническими, бизнес- и операционными метаданными',
      'Управление главными данными',
      'Управление резервными копиями',
    ],
    correctIndex: 1,
    explanation:
      'Metadata Management — управление «данными о данных». Типы метаданных: (1) Технические (Technical): структура таблиц, типы данных, индексы, ключи, ETL-маппинги, lineage. Источники: DDL, ETL-инструменты, СУБД. (2) Бизнес (Business): бизнес-определения атрибутов, владельцы, правила качества, классификация. Источники: Data Stewards, глоссарий. (3) Операционные (Operational): статистика использования, время последнего обновления, объём данных, performance metrics. Источники: логи, мониторинг. Инструменты: Data Catalog (Alation, Collibra), Apache Atlas, облачные сервисы (AWS Glue Catalog). Metadata Management — основа Data Governance, lineage, impact analysis.',
  },
  {
    id: 'sa-data-modeling-034',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн проектирования данных используется для хранения часто запрашиваемых агрегатов без пересчёта?',
    options: [
      'Нормализация до 5NF',
      'Materialized View / Pre-aggregated Table',
      'Шардирование',
      'Партиционирование',
    ],
    correctIndex: 1,
    explanation:
      'Materialized View / Pre-aggregated Table — паттерн денормализации для хранения предвычисленных агрегатов (суммы, средние, количества по измерениям). Вместо вычисления SUM при каждом запросе — хранение готового результата. Требует обновления (refresh) при изменении исходных данных: полное обновление (recreate), инкрементальное (delta), real-time (trigger-based). Применение: отчёты с известными срезами, dashboard KPI, кэширование результатов тяжёлых запросов. Компромисс: скорость чтения vs свежесть данных и стоимость хранения.',
  },
  {
    id: 'sa-data-modeling-035',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое триггер (Trigger) в базе данных?',
    options: [
      'Кнопка запуска процедуры',
      'Хранимая процедура, автоматически выполняющаяся при определённых событиях (INSERT, UPDATE, DELETE)',
      'Индекс для ускорения запросов',
      'Метод резервного копирования',
    ],
    correctIndex: 1,
    explanation:
      'Триггер (Trigger) — объект базы данных, содержащий код (SQL, PL/pgSQL), который автоматически выполняется при наступлении определённого события на таблице: BEFORE/AFTER INSERT, UPDATE, DELETE. Применение: аудит изменений (запись в лог-таблицу), бизнес-правила (проверка сложных ограничений), каскадные обновления, поддержание денормализованных данных. Осторожно: триггеры увеличивают сложность и могут скрыто влиять на производительность и логику. Предпочтительно использовать ограничения (constraints) и логику приложения, а триггеры — для cross-cutting concerns (аудит).',
  },
  {
    id: 'sa-data-modeling-036',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое EAV (Entity-Attribute-Value) модель данных?',
    options: [
      'Модель с тремя нормальными формами',
      'Гибкая модель для хранения сущностей с переменным набором атрибутов в виде строк (entity_id, attribute_name, value)',
      'Модель для шифрования данных',
      'Модель для графовых баз данных',
    ],
    correctIndex: 1,
    explanation:
      'EAV (Entity-Attribute-Value) — модель данных, где атрибуты хранятся как строки (entity_id, attribute_name, attribute_value), а не как столбцы. Преимущества: гибкость (любое количество атрибутов без изменения схемы), подходит для sparse data (много nullable атрибутов). Недостатки: сложность запросов (pivot для получения «нормального» представления), невозможность использовать типизацию и constraints, плохая производительность для аналитических запросов. Применение: CMS, каталоги товаров с переменными характеристиками, конфигурации. Альтернативы: JSON/JSONB столбцы (PostgreSQL, MySQL 5.7+), документоориентированные БД.',
  },
  {
    id: 'sa-data-modeling-037',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните подходы к моделированию иерархий в реляционной базе данных: Adjacency List, Nested Sets, Materialized Path.',
    sampleAnswer:
      'Паттерны моделирования иерархий: (1) Adjacency List: каждая запись хранит ссылку на родителя (parent_id FK). Плюсы: простота реализации и обновления. Минусы: рекурсивные запросы для получения всех потомков/предков (хотя WITH RECURSIVE в SQL решает это). (2) Nested Sets: каждая запись имеет left и right — границы диапазона. Потомки: WHERE left > parent.left AND right < parent.right. Плюсы: очень быстрое чтение поддерева одним запросом. Минусы: дорогие операции вставки/удаления (пересчёт всех границ). Подходит для редко меняющихся иерархий (каталоги). (3) Materialized Path (Path Enumeration): хранение пути от корня как строки (например, «/1/5/12/»). Плюсы: простые запросы потомков (LIKE «/1/5/%»), легко определить уровень вложенности. Минусы: зависимость от формата строки, проблемы с изменением родителя. (4) Closure Table: отдельная таблица со всеми парами предок-потомок. Плюсы: быстрое чтение любых связей. Минусы: много записей, обновление при перемещении узла. Рекомендация: Adjacency List + рекурсивные CTE для большинства случаев; Nested Sets/Closure Table для read-heavy иерархий.',
    explanation:
      'Выбор паттерна зависит от соотношения чтение/запись и типичных запросов. Adjacency List — простой default. Для каталогов с редкими изменениями — Nested Sets или Materialized Path. Для сложных запросов и частых изменений — Closure Table.',
  },
  {
    id: 'sa-data-modeling-038',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Golden Record в контексте Master Data Management?',
    options: [
      'Запись с наибольшим id',
      'Единая, достоверная, согласованная версия записи о сущности, созданная из нескольких источников',
      'Зашифрованная запись',
      'Первая запись в таблице',
    ],
    correctIndex: 1,
    explanation:
      'Golden Record (эталонная запись) — единая, достоверная версия данных о сущности (клиент, продукт), созданная путём слияния и согласования данных из нескольких источников. Процесс создания: Match (сопоставление записей из разных систем по ключам и fuzzy matching), Merge (объединение атрибутов с применением survivorship rules — какому источнику доверять для каждого атрибута). Golden Record хранится в MDM-хабе и распространяется в системы-потребители. Это Single Source of Truth для мастер-данных.',
  },
  {
    id: 'sa-data-modeling-039',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Как проектировать модель данных для multi-tenant (многоарендной) SaaS-системы? Какие подходы существуют?',
    sampleAnswer:
      'Подходы к multi-tenancy в модели данных: (1) Separate Databases: каждый tenant имеет отдельную БД. Плюсы: максимальная изоляция, простая кастомизация схемы, легко backup/restore отдельного tenant. Минусы: накладные расходы на управление множеством БД, сложность cross-tenant аналитики. (2) Shared Database, Separate Schemas: одна БД, отдельная schema (namespace) для каждого tenant. Плюсы: хорошая изоляция, возможность кастомизации схемы, проще чем отдельные БД. Минусы: ограничение количества schemas в некоторых СУБД. (3) Shared Database, Shared Schema: одна БД, одна схема, все таблицы имеют tenant_id. Плюсы: простота, эффективность ресурсов, cross-tenant запросы. Минусы: риск утечки данных при ошибке в WHERE, сложнее изоляция производительности. Требуется Row-Level Security (RLS) или middleware filter. (4) Гибридный: крупные/premium tenants — отдельные БД; мелкие — shared schema. Выбор: enterprise/compliance → Separate DB; startup/cost-sensitive → Shared Schema; middle-ground → Separate Schemas. Всегда: tenant_id в каждом запросе, аудит, RLS где возможно.',
    explanation:
      'Multi-tenancy — критическое архитектурное решение для SaaS. Ошибка в изоляции может привести к утечке данных между tenants. Row-Level Security (PostgreSQL, SQL Server) — мощный механизм: политика автоматически добавляет WHERE tenant_id = current_tenant() к каждому запросу.',
  },
  {
    id: 'sa-data-modeling-040',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое DEFAULT constraint в базе данных?',
    options: [
      'Ограничение, требующее уникальности значений',
      'Значение, автоматически присваиваемое столбцу при вставке, если значение не указано явно',
      'Ограничение внешнего ключа',
      'Значение по умолчанию для всей таблицы',
    ],
    correctIndex: 1,
    explanation:
      'DEFAULT constraint задаёт значение, которое автоматически присваивается столбцу при INSERT, если значение не указано явно. Примеры: created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT \'pending\', is_active BOOLEAN DEFAULT TRUE. DEFAULT упрощает вставку записей и гарантирует наличие значения. Может быть константой, функцией (NOW(), gen_random_uuid()) или выражением.',
  },
  {
    id: 'sa-data-modeling-041',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Data Catalog?',
    options: [
      'Список всех файлов на сервере',
      'Централизованный реестр data assets организации с метаданными, поиском, lineage и governance',
      'Каталог товаров в интернет-магазине',
      'Справочник SQL-команд',
    ],
    correctIndex: 1,
    explanation:
      'Data Catalog — инструмент для обнаружения, понимания и управления данными организации. Функции: инвентаризация data assets (таблицы, файлы, отчёты), поиск (semantic search, tags, filters), метаданные (технические и бизнес-), lineage (откуда данные, куда используются), quality scores, ownership, access requests. Позволяет аналитикам и data scientists находить нужные данные и понимать их смысл. Инструменты: Alation, Collibra, Atlan, DataHub, AWS Glue Catalog, Google Data Catalog. Data Catalog — центральный элемент Data Governance и self-service analytics.',
  },
  {
    id: 'sa-data-modeling-042',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип SCD сохраняет только текущее значение без истории изменений?',
    options: [
      'SCD Type 0 (Retain Original)',
      'SCD Type 1 (Overwrite)',
      'SCD Type 2 (Add New Row)',
      'SCD Type 3 (Add New Column)',
    ],
    correctIndex: 1,
    explanation:
      'SCD Type 1 (Overwrite) — простейший тип: при изменении атрибута старое значение перезаписывается новым. История не сохраняется. Применение: исправление ошибок, атрибуты, история которых не важна (опечатки в имени). Плюсы: простота, нет роста объёма данных. Минусы: невозможность анализа изменений, искажение исторических отчётов. SCD Type 0 — значение никогда не меняется (фиксируется при первой загрузке). SCD Type 2 — полная история через новые строки. SCD Type 3 — текущее и предыдущее значения в разных столбцах.',
  },
  {
    id: 'sa-data-modeling-043',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Data Quality Dimension (измерение качества данных)?',
    options: [
      'Размерность в хранилище данных',
      'Аспект оценки качества данных: точность, полнота, актуальность, согласованность и др.',
      'Физический размер базы данных',
      'Версия схемы данных',
    ],
    correctIndex: 1,
    explanation:
      'Data Quality Dimensions — аспекты, по которым оценивается качество данных: (1) Accuracy (точность) — соответствие реальному миру. (2) Completeness (полнота) — отсутствие пропущенных значений. (3) Consistency (согласованность) — одинаковые данные в разных системах. (4) Timeliness (своевременность) — актуальность данных. (5) Validity (валидность) — соответствие формату и правилам. (6) Uniqueness (уникальность) — отсутствие дубликатов. (7) Integrity (целостность) — корректность связей. Для каждого измерения определяются метрики и целевые значения. Data Quality Management — процесс измерения, мониторинга и улучшения качества по всем измерениям.',
  },
  {
    id: 'sa-data-modeling-044',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Как организовать управление версиями схемы базы данных (Schema Versioning) в production-среде?',
    sampleAnswer:
      'Schema Versioning — практика управления изменениями схемы БД как кодом. Подходы: (1) Versioned Migrations (Flyway, Liquibase, Alembic): каждое изменение — отдельный скрипт с порядковым номером (V1__create_users.sql, V2__add_email_column.sql). Таблица истории (flyway_schema_history) отслеживает применённые миграции. При запуске приложения автоматически применяются новые миграции. (2) State-based (Redgate SQL Compare, Liquibase diff): описывается целевое состояние схемы, инструмент генерирует diff-скрипт. Менее контролируемо, но удобно для legacy. (3) ORM Migrations (Django, Rails): миграции генерируются ORM на основе изменений моделей. Практики: миграции хранятся в Git вместе с кодом; миграции идемпотентны где возможно; backward-compatible changes (добавление nullable столбца) отдельно от breaking (удаление); тестирование миграций на копии prod-данных; rollback-скрипты (down-migrations) для каждой миграции; CI/CD pipeline применяет миграции автоматически. Инструменты: Flyway, Liquibase, Alembic (Python), Knex (Node.js), gh-ost (MySQL online schema change).',
    explanation:
      'Schema Versioning — обязательная практика для профессиональной разработки. Без неё: ручные изменения, расхождение сред, невозможность воспроизвести состояние БД. Миграции должны быть immutable — после применения в production не изменяются.',
  },
  {
    id: 'sa-data-modeling-045',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое VIEW (представление) в базе данных?',
    options: [
      'Физическая копия таблицы',
      'Виртуальная таблица, определяемая SQL-запросом, не хранящая данные физически',
      'Индекс для ускорения запросов',
      'Резервная копия таблицы',
    ],
    correctIndex: 1,
    explanation:
      'VIEW (представление) — виртуальная таблица, определяемая SQL-запросом. Не хранит данные физически — запрос выполняется при каждом обращении к VIEW. Применение: упрощение сложных запросов, абстракция (скрытие структуры таблиц от пользователей), безопасность (ограничение видимых столбцов/строк), совместимость (изменение структуры таблицы без изменения интерфейса). Updatable VIEW — позволяет INSERT/UPDATE/DELETE (с ограничениями). Materialized VIEW — хранит данные физически, требует refresh.',
  },
  {
    id: 'sa-data-modeling-046',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Data Profiling?',
    options: [
      'Создание профиля пользователя в системе',
      'Анализ данных для понимания их структуры, качества и статистических характеристик',
      'Оптимизация производительности запросов',
      'Шифрование конфиденциальных данных',
    ],
    correctIndex: 1,
    explanation:
      'Data Profiling — процесс анализа данных для понимания их характеристик: структура (типы данных, форматы), качество (null percentage, duplicates, outliers), статистика (min, max, mean, distribution, cardinality), связи (foreign key candidates, dependencies). Применение: подготовка к миграции, ETL-разработка, выявление проблем качества, понимание незнакомых данных. Инструменты: Talend, Informatica, Great Expectations, pandas-profiling, встроенные функции СУБД. Data Profiling — первый шаг при работе с новым источником данных.',
  },
  {
    id: 'sa-data-modeling-047',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип таблицы в Dimensional Modeling содержит измеримые бизнес-метрики (факты)?',
    options: [
      'Таблица измерений (Dimension Table)',
      'Таблица фактов (Fact Table)',
      'Таблица мостов (Bridge Table)',
      'Таблица агрегатов (Aggregate Table)',
    ],
    correctIndex: 1,
    explanation:
      'Fact Table (таблица фактов) — центральная таблица в Star/Snowflake Schema, содержащая измеримые числовые метрики (facts/measures): выручка, количество, стоимость. Также содержит foreign keys к таблицам измерений (date_key, product_key, customer_key). Характеристики: много строк (миллионы-миллиарды), относительно мало столбцов, append-mostly. Типы фактов: additive (суммируются по всем измерениям), semi-additive (не по всем — например, баланс счёта не суммируется по времени), non-additive (не суммируются — например, курс валюты). Dimension Tables содержат описательные атрибуты (имя клиента, название продукта).',
  },
  {
    id: 'sa-data-modeling-048',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Factless Fact Table в Dimensional Modeling?',
    options: [
      'Fact Table без primary key',
      'Fact Table без числовых метрик, фиксирующая только события или связи',
      'Пустая таблица',
      'Fact Table с ошибками данных',
    ],
    correctIndex: 1,
    explanation:
      'Factless Fact Table — таблица фактов, содержащая только foreign keys к измерениям без числовых метрик. Два типа: (1) Coverage Fact — фиксирует, что могло произойти (например, какие продукты были в акции в какие дни — даже если не было продаж). (2) Event Fact — фиксирует события (студент посетил лекцию, пользователь вошёл в систему). Единственная «метрика» — неявный COUNT(*). Применение: анализ покрытия, отслеживание событий, M:N связи между измерениями.',
  },
  {
    id: 'sa-data-modeling-049',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'senior',
    type: 'open',
    question: 'Как проектировать модель данных для event sourcing системы? Какие особенности хранения событий необходимо учитывать?',
    sampleAnswer:
      'Модель данных для Event Sourcing: (1) Event Store (хранилище событий): основная таблица events: event_id (UUID, PK), stream_id (идентификатор агрегата), stream_type (тип агрегата), event_type (тип события — OrderCreated, PaymentReceived), event_data (JSON/JSONB — payload события), metadata (JSON — correlation_id, causation_id, user_id), version (порядковый номер события в stream), created_at (timestamp). Индексы: по stream_id + version (уникальный), по event_type, по created_at. (2) Optimistic Concurrency: version используется для оптимистичной блокировки — INSERT с проверкой (stream_id, version) unique. (3) Snapshots: периодические снимки состояния агрегата для оптимизации восстановления (не нужно replay всех событий). Таблица snapshots: stream_id, version, state (JSON), created_at. (4) Projections (Read Models): отдельные денормализованные таблицы для чтения, построенные асинхронно из событий. Пример: orders_view (order_id, customer_name, total, status). (5) Outbox Pattern: события публикуются в message broker через outbox-таблицу для гарантированной доставки. (6) Event Versioning: схема событий эволюционирует; хранить schema_version или использовать upcasters для миграции старых событий.',
    explanation:
      'Event Sourcing требует специфической модели данных: append-only event store, immutable events, projections для чтения. Ключевые вызовы: эволюция схемы событий (нельзя изменить опубликованное событие), snapshots для производительности, eventual consistency между event store и projections.',
  },
  {
    id: 'sa-data-modeling-050',
    block: 'sa',
    topic: 'data-modeling',
    topicLabel: 'Проектирование данных',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Conformed Dimension в контексте корпоративного хранилища данных?',
    options: [
      'Измерение, оптимизированное по производительности',
      'Измерение, используемое идентичным образом в нескольких Data Marts / Fact Tables',
      'Измерение со сложной иерархией',
      'Измерение с encrypted данными',
    ],
    correctIndex: 1,
    explanation:
      'Conformed Dimension (согласованное измерение) — измерение, которое определено и используется идентичным образом в нескольких Data Marts или Fact Tables. Пример: dim_date, dim_customer используются одинаково в Sales Mart, Marketing Mart, Finance Mart. Преимущества: возможность drill-across (анализ across fact tables по общему измерению), единообразие отчётности, Single Source of Truth для справочных данных. Conformed Dimensions — ключевой принцип Kimball Bus Architecture для построения согласованного enterprise DWH из отдельных Data Marts.',
  },
];
