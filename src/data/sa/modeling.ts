import type { Question } from '../types';

export const modelingQuestions: Question[] = [
  {
    id: 'sa-modeling-001',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой элемент BPMN используется для обозначения принятия решения (ветвления потока)?',
    options: [
      'Событие (Event)',
      'Шлюз (Gateway)',
      'Действие (Activity)',
      'Поток сообщений (Message Flow)',
    ],
    correctIndex: 1,
    explanation:
      'Шлюз (Gateway) в нотации BPMN изображается в виде ромба и служит для управления ветвлением и слиянием потоков. Существует несколько типов шлюзов: эксклюзивный (XOR) — выбирается ровно один из исходящих потоков; параллельный (AND) — активируются все исходящие потоки; инклюзивный (OR) — активируются один или несколько потоков в зависимости от условий. Событие (Event) обозначает нечто, что «происходит» в процессе (начало, конец, промежуточные триггеры). Действие (Activity) — это единица работы. Поток сообщений связывает участников (пулы) между собой.',
  },
  {
    id: 'sa-modeling-002',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая UML-диаграмма лучше всего подходит для визуализации последовательности обмена сообщениями между объектами во времени?',
    options: [
      'Диаграмма классов (Class Diagram)',
      'Диаграмма деятельности (Activity Diagram)',
      'Диаграмма последовательности (Sequence Diagram)',
      'Диаграмма компонентов (Component Diagram)',
    ],
    correctIndex: 2,
    explanation:
      'Диаграмма последовательности (Sequence Diagram) показывает взаимодействие объектов, упорядоченное по времени. По вертикальной оси откладывается время, а по горизонтали — участники (lifelines). Стрелки между участниками обозначают сообщения (вызовы, ответы, асинхронные сообщения). Это один из наиболее распространённых инструментов системного аналитика для описания сценариев интеграции и бизнес-логики. Диаграмма деятельности больше подходит для моделирования процессов и алгоритмов, диаграмма классов — для структуры данных и связей, а диаграмма компонентов — для архитектуры развёртывания.',
  },
  {
    id: 'sa-modeling-003',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В BPMN-диаграмме используется параллельный шлюз (AND Gateway) с тремя исходящими ветками. Какое условие необходимо для продолжения процесса после слияния?',
    options: [
      'Достаточно завершения любой одной ветки',
      'Достаточно завершения двух из трёх веток',
      'Необходимо завершение всех трёх веток',
      'Продолжение происходит немедленно без ожидания',
    ],
    correctIndex: 2,
    explanation:
      'Параллельный шлюз (AND Gateway, обозначается знаком «+» внутри ромба) при разветвлении (fork) активирует все исходящие потоки одновременно. При слиянии (join) он ожидает завершения ВСЕХ входящих потоков, прежде чем продолжить выполнение. Это принципиальное отличие от эксклюзивного шлюза (XOR), который при слиянии пропускает первый пришедший токен. Если одна из параллельных веток «зависнет», процесс не сможет продолжиться — это частая ошибка при проектировании бизнес-процессов, и аналитик должен предусматривать таймауты или компенсационные события.',
  },
  {
    id: 'sa-modeling-004',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните разницу между диаграммой деятельности (Activity Diagram) и BPMN-диаграммой бизнес-процесса. В каких ситуациях вы бы предпочли одну другой?',
    sampleAnswer:
      'Диаграмма деятельности UML и BPMN-диаграмма внешне схожи, но имеют разное назначение и выразительность. Activity Diagram — часть стандарта UML, хорошо подходит для моделирования алгоритмов, внутренней логики и потоков данных внутри системы. Она поддерживает разбиение по «дорожкам» (swimlanes), fork/join для параллелизма и различные типы узлов действий. BPMN — специализированная нотация для бизнес-процессов, значительно богаче в части моделирования межорганизационного взаимодействия: пулы и дорожки чётко разделяют участников, потоки сообщений связывают пулы, имеется развитая система событий (таймеры, сигналы, ошибки, эскалация, компенсация). BPMN предпочтительнее, когда процесс охватывает несколько организаций или систем, нужна формальная спецификация для исполнения в BPM-движке, или когда модель будет обсуждаться с бизнес-заказчиком. Activity Diagram удобнее для описания внутренней логики приложения, алгоритмов обработки и в случае, когда команда уже работает в экосистеме UML.',
    explanation:
      'Ключевые отличия: (1) BPMN разделяет участников на пулы с явными потоками сообщений, а UML Activity использует swimlanes; (2) BPMN имеет богатую систему событий (таймеры, сигналы, ошибки, компенсация), в UML Activity события проще; (3) BPMN-модели могут быть исполняемыми в BPM-движках (Camunda, jBPM); (4) UML Activity лучше интегрируется с другими UML-диаграммами в рамках единой модели системы. Системный аналитик должен выбирать нотацию в зависимости от аудитории и задачи.',
  },
  {
    id: 'sa-modeling-005',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы проектируете интеграционный процесс, в котором участвуют три системы: CRM, ERP и платёжный шлюз. Опишите, какие нотации и типы диаграмм вы бы использовали для полного документирования этого процесса и почему.',
    sampleAnswer:
      'Для полного документирования интеграционного процесса между CRM, ERP и платёжным шлюзом я бы использовал следующий набор диаграмм: (1) BPMN-диаграмму процесса верхнего уровня с тремя пулами (по одному на каждую систему), показывающую основной бизнес-процесс, потоки сообщений между системами, обработку ошибок и таймауты. (2) UML Sequence Diagram для каждого ключевого сценария интеграции, детально описывающую порядок вызовов API, форматы сообщений, обработку синхронных и асинхронных ответов, включая alt/loop/opt-фрагменты для ветвлений и циклов. (3) ER-диаграмму для описания структур данных, которыми обмениваются системы, и маппинга полей между моделями данных разных систем. (4) UML Component Diagram для отображения архитектуры интеграционного слоя: адаптеры, очереди сообщений, API Gateway, трансформаторы данных. (5) UML State Machine Diagram для критичных сущностей (например, состояния заказа), жизненный цикл которых затрагивает несколько систем. Выбор обусловлен тем, что каждая нотация решает свою задачу: BPMN — оркестрация процесса, Sequence — детали взаимодействия, ER — структура данных, Component — архитектура, State Machine — жизненный цикл.',
    explanation:
      'Комплексная интеграция требует многоуровневого описания. BPMN хорошо показывает «кто с кем общается» на уровне бизнес-процесса. Sequence Diagram незаменима для спецификации API-контрактов и порядка вызовов. ER-диаграмма обеспечивает согласованность моделей данных. Component Diagram даёт общее видение архитектуры. State Machine помогает отследить согласованность состояний сущности при обработке в нескольких системах. Зрелый аналитик умеет выбирать подходящий уровень абстракции и нотацию для конкретной аудитории: BPMN — для бизнеса, Sequence/Component — для разработчиков, ER — для проектировщиков БД.',
  },
  {
    id: 'sa-modeling-006',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой тип связи в ER-модели означает, что сущность не может существовать без связанной родительской сущности?',
    options: [
      'Неидентифицирующая связь (Non-identifying relationship)',
      'Идентифицирующая связь (Identifying relationship)',
      'Связь «многие ко многим» (Many-to-many)',
      'Рекурсивная связь (Recursive relationship)',
    ],
    correctIndex: 1,
    explanation:
      'Идентифицирующая связь (Identifying relationship) означает, что дочерняя сущность не может быть уникально идентифицирована без ссылки на родительскую. Первичный ключ родителя входит в состав первичного ключа дочерней сущности (а не просто является внешним ключом). Например, «Строка заказа» идентифицируется комбинацией ID заказа и номера строки — без заказа строка не имеет смысла. В нотации IDEF1X идентифицирующая связь изображается сплошной линией, а неидентифицирующая — пунктирной. Неидентифицирующая связь подразумевает, что дочерняя сущность может существовать самостоятельно и имеет собственный независимый первичный ключ.',
  },
  {
    id: 'sa-modeling-007',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой фрагмент (combined fragment) на UML-диаграмме последовательности используется для отображения условного выполнения с двумя альтернативными ветками?',
    options: [
      'loop',
      'opt',
      'alt',
      'par',
    ],
    correctIndex: 2,
    explanation:
      'Фрагмент «alt» (alternative) на диаграмме последовательности позволяет моделировать условное ветвление: диаграмма разделяется на две или более секции, каждая из которых имеет guard-условие. Выполняется та секция, условие которой истинно. Фрагмент «opt» (optional) — частный случай alt с одной веткой (выполняется или нет). «loop» — цикл с условием. «par» — параллельное выполнение нескольких потоков. Правильное использование фрагментов позволяет аналитику точно специфицировать поведение системы, избегая двусмысленности.',
  },
  {
    id: 'sa-modeling-008',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой уровень модели C4 описывает высокоуровневую структуру системы, показывая саму систему и её взаимодействие с пользователями и внешними системами?',
    options: [
      'Component (уровень компонентов)',
      'Container (уровень контейнеров)',
      'System Context (контекст системы)',
      'Code (уровень кода)',
    ],
    correctIndex: 2,
    explanation:
      'Модель C4 (автор — Simon Brown) состоит из четырёх уровней абстракции: (1) System Context — самый верхний уровень, показывает систему как «чёрный ящик» и её взаимодействие с пользователями (actors) и внешними системами. (2) Container — раскрывает систему, показывая контейнеры (веб-приложение, API, БД, очередь сообщений и т.д.) и их взаимосвязи. (3) Component — детализирует конкретный контейнер, показывая его внутренние компоненты (модули, сервисы, контроллеры). (4) Code — самый детальный уровень, обычно соответствует UML-диаграмме классов. На практике уровень Code используется редко — достаточно первых трёх уровней.',
  },
  {
    id: 'sa-modeling-009',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая UML-диаграмма используется для отображения жизненного цикла объекта, описывая состояния и переходы между ними?',
    options: [
      'Диаграмма последовательности (Sequence Diagram)',
      'Диаграмма вариантов использования (Use Case Diagram)',
      'Диаграмма состояний (State Machine Diagram)',
      'Диаграмма объектов (Object Diagram)',
    ],
    correctIndex: 2,
    explanation:
      'Диаграмма состояний (State Machine Diagram, ранее — Statechart Diagram) описывает поведение объекта в терминах состояний, переходов и событий, вызывающих эти переходы. Она показывает жизненный цикл сущности — например, заказ может проходить состояния «Создан» → «Оплачен» → «В доставке» → «Доставлен» / «Отменён». Каждый переход имеет триггер (событие), опциональное условие (guard) и опциональное действие. Диаграмма состояний незаменима для документирования бизнес-сущностей со сложным жизненным циклом, конечных автоматов и протоколов.',
  },
  {
    id: 'sa-modeling-010',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какая UML-диаграмма показывает физическое размещение программных артефактов на аппаратных узлах?',
    options: [
      'Диаграмма компонентов (Component Diagram)',
      'Диаграмма развёртывания (Deployment Diagram)',
      'Диаграмма пакетов (Package Diagram)',
      'Диаграмма классов (Class Diagram)',
    ],
    correctIndex: 1,
    explanation:
      'Диаграмма развёртывания (Deployment Diagram) показывает физическую (или виртуальную) инфраструктуру системы: узлы (серверы, устройства, облачные инстансы), артефакты (war/jar-файлы, контейнеры Docker, исполняемые файлы), развёрнутые на этих узлах, и каналы связи между узлами. Она отвечает на вопрос «где и на чём работает система». Диаграмма компонентов показывает логическую структуру (компоненты и их интерфейсы), но без привязки к физической инфраструктуре. Диаграмма пакетов группирует элементы модели. Диаграмма классов описывает статическую структуру классов и их связи.',
  },
  {
    id: 'sa-modeling-011',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое модель C4 и из каких уровней она состоит? Какую задачу решает каждый уровень?',
    sampleAnswer:
      'Модель C4 — это подход к визуализации архитектуры программного обеспечения, предложенный Саймоном Брауном. Она предлагает четыре уровня абстракции, каждый из которых ориентирован на определённую аудиторию и задачу: (1) System Context — показывает систему как единое целое в окружении пользователей и внешних систем, подходит для обсуждения с бизнес-заказчиками и новыми членами команды. (2) Container — раскрывает внутреннюю структуру системы на уровне развёртываемых единиц (веб-сервер, мобильное приложение, база данных, очередь сообщений), показывая технологии и протоколы взаимодействия. (3) Component — детализирует отдельный контейнер, показывая его внутренние компоненты (контроллеры, сервисы, репозитории). (4) Code — уровень кода (обычно UML-диаграмма классов), применяется редко и только для критически важных участков. Главное преимущество C4 — иерархия абстракций, позволяющая общаться с разными аудиториями на подходящем уровне детализации.',
    explanation:
      'C4 решает проблему «одной огромной диаграммы», предлагая последовательное погружение в детали. На практике достаточно первых двух-трёх уровней. C4 не привязан к конкретной нотации — можно использовать любые инструменты (Structurizr, draw.io, PlantUML). Важно, что C4 не заменяет UML или BPMN, а дополняет их, давая структурированный подход к архитектурной визуализации.',
  },
  {
    id: 'sa-modeling-012',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какая нотация моделирования была создана специально для описания корпоративной архитектуры и является открытым стандартом The Open Group?',
    options: [
      'BPMN',
      'SysML',
      'ArchiMate',
      'UML',
    ],
    correctIndex: 2,
    explanation:
      'ArchiMate — открытый стандарт The Open Group, созданный для моделирования корпоративной архитектуры (Enterprise Architecture). ArchiMate охватывает три слоя: бизнес-слой (бизнес-процессы, роли, сервисы), прикладной слой (приложения, компоненты, интерфейсы) и технологический слой (инфраструктура, сети, устройства). Дополнительно поддерживаются аспекты мотивации (цели, требования, принципы), стратегии и реализации/миграции. ArchiMate часто используется совместно с фреймворком TOGAF. BPMN специализируется на бизнес-процессах. SysML — расширение UML для системной инженерии (не только ПО). UML — универсальная нотация для моделирования ПО.',
  },
  {
    id: 'sa-modeling-013',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое SysML и чем она отличается от стандартного UML?',
    options: [
      'SysML — это устаревшая версия UML 1.x',
      'SysML — это расширение UML для системной инженерии, добавляющее диаграммы требований и параметрические диаграммы',
      'SysML — это альтернативное название для BPMN',
      'SysML — это нотация исключительно для моделирования баз данных',
    ],
    correctIndex: 1,
    explanation:
      'SysML (Systems Modeling Language) — профиль UML, разработанный для нужд системной инженерии. SysML переиспользует часть диаграмм UML (диаграмму деятельности, последовательности, состояний, вариантов использования) и добавляет новые: диаграмму требований (Requirements Diagram) для трассировки требований, параметрическую диаграмму (Parametric Diagram) для моделирования ограничений и уравнений, а также модифицирует диаграмму блоков (Block Definition Diagram) вместо диаграммы классов. SysML применяется в аэрокосмической отрасли, автомобилестроении и других отраслях, где проектируемые системы включают не только ПО, но и аппаратное обеспечение, механические и электрические компоненты.',
  },
  {
    id: 'sa-modeling-014',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'На UML-диаграмме компонентов (Component Diagram) что обозначает символ «леденец» (lollipop) — кружок на палочке?',
    options: [
      'Обязательную зависимость компонента',
      'Предоставляемый интерфейс (provided interface)',
      'Требуемый интерфейс (required interface)',
      'Порт для асинхронного взаимодействия',
    ],
    correctIndex: 1,
    explanation:
      'На диаграмме компонентов UML используется нотация «шар и гнездо» (ball-and-socket): кружок на палочке («леденец», lollipop) обозначает предоставляемый интерфейс (provided interface) — интерфейс, который компонент реализует и предлагает другим. Полукруг («гнездо», socket) обозначает требуемый интерфейс (required interface) — интерфейс, который компонент ожидает получить от другого компонента. Когда «шар» одного компонента соединяется с «гнездом» другого, это показывает зависимость через интерфейс. Эта нотация помогает визуализировать контракты между компонентами и точки интеграции.',
  },
  {
    id: 'sa-modeling-015',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'open',
    question: 'Опишите, в каких ситуациях следует использовать диаграмму последовательности (Sequence Diagram), а в каких — диаграмму коммуникации (Communication Diagram). Чем они отличаются?',
    sampleAnswer:
      'Обе диаграммы относятся к UML-диаграммам взаимодействия и описывают обмен сообщениями между объектами, но акцентируют разные аспекты. Диаграмма последовательности (Sequence Diagram) подчёркивает временной порядок: сообщения упорядочены по вертикальной оси времени, что делает её идеальной для описания пошаговых сценариев API-взаимодействия, use case-реализаций и интеграционных потоков. Она также поддерживает фрагменты (alt, loop, opt, par) для описания ветвлений и циклов. Диаграмма коммуникации (ранее — Collaboration Diagram) делает акцент на структурных связях между объектами: объекты размещены произвольно, а сообщения нумеруются для указания порядка. Она лучше подходит, когда важно показать, «кто с кем связан», а не точный порядок вызовов — например, для обзора архитектуры взаимодействий в рамках подсистемы. На практике Sequence Diagram используется значительно чаще благодаря большей наглядности и поддержке инструментов.',
    explanation:
      'Sequence Diagram и Communication Diagram семантически эквивалентны (могут быть трансформированы друг в друга), но различаются представлением. Sequence Diagram — стандарт де-факто для документирования сценариев в системном анализе. Communication Diagram полезна на этапах мозгового штурма и обсуждения архитектуры, когда временной порядок менее важен, чем понимание топологии взаимодействий.',
  },
  {
    id: 'sa-modeling-016',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой слой ArchiMate описывает бизнес-процессы, бизнес-функции, бизнес-роли и бизнес-сервисы организации?',
    options: [
      'Технологический слой (Technology Layer)',
      'Прикладной слой (Application Layer)',
      'Бизнес-слой (Business Layer)',
      'Слой мотивации (Motivation Layer)',
    ],
    correctIndex: 2,
    explanation:
      'В ArchiMate три основных слоя: бизнес-слой (Business Layer), прикладной слой (Application Layer) и технологический слой (Technology Layer). Бизнес-слой описывает организацию с точки зрения бизнеса: бизнес-процессы, бизнес-функции, бизнес-роли (акторы), бизнес-объекты (сущности предметной области) и бизнес-сервисы, которые организация предоставляет внутренним и внешним потребителям. Прикладной слой описывает приложения и их компоненты, обеспечивающие автоматизацию бизнес-процессов. Технологический слой описывает инфраструктуру (серверы, сети, платформы). Слой мотивации — дополнительный, описывает цели, принципы, требования и драйверы, обосновывающие архитектурные решения.',
  },
  {
    id: 'sa-modeling-017',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень модели C4 показывает внутреннюю структуру отдельного контейнера, разбивая его на компоненты и их взаимосвязи?',
    options: [
      'System Context',
      'Container',
      'Component',
      'Code',
    ],
    correctIndex: 2,
    explanation:
      'Уровень Component (третий уровень C4) раскрывает внутреннюю структуру одного контейнера, показывая его составные компоненты и их взаимодействия. Например, контейнер «API-сервер» может содержать компоненты: AuthController, OrderService, PaymentGatewayAdapter, UserRepository. На этом уровне видно, какие паттерны применяются (MVC, слоистая архитектура, гексагональная архитектура), как организованы зависимости и точки расширения. System Context показывает систему целиком в окружении. Container раскрывает систему на контейнеры. Code — детализирует компонент до уровня классов и методов, но используется крайне редко.',
  },
  {
    id: 'sa-modeling-018',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните подходы к моделированию архитектуры: C4, ArchiMate и «4+1 View Model» Филиппа Крухтена. Когда и для каких целей вы бы выбрали каждый из них?',
    sampleAnswer:
      'C4 (Simon Brown) — лёгкий, прагматичный подход с четырьмя уровнями абстракции (Context, Container, Component, Code). Идеален для команд разработки: быстро создаётся, легко понимается, фокусируется на структуре ПО. Подходит для документирования архитектуры конкретной системы или микросервиса, onboarding-а новых разработчиков. ArchiMate — формальная нотация для корпоративной архитектуры (Enterprise Architecture). Покрывает бизнес-, прикладной и технологический слои, а также аспекты мотивации и миграции. Подходит для крупных организаций с выделенной командой архитекторов, при работе с TOGAF-фреймворком, для анализа влияния изменений на всю организацию. «4+1 View Model» (Крухтен) — описывает архитектуру через пять представлений: логическое (классы, пакеты), процессное (параллелизм, синхронизация), физическое (развёртывание), разработки (организация кода) и сценарии (use cases), объединяющие остальные четыре. Подходит для проектов с жёстким процессом разработки (RUP), когда нужна формальная архитектурная документация для разных стейкхолдеров. Выбор зависит от масштаба (система vs организация), формальности процессов и целевой аудитории.',
    explanation:
      'C4 оптимален для agile-команд и проектов среднего масштаба. ArchiMate — для enterprise-уровня с формальными процессами управления архитектурой. «4+1» — классический академический подход, хорошо интегрированный с RUP, но в чистом виде используется реже. На практике подходы можно комбинировать: C4 для структуры системы, ArchiMate для enterprise-контекста, отдельные UML-диаграммы для детальных сценариев.',
  },
  {
    id: 'sa-modeling-019',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Вам нужно задокументировать архитектуру системы, использующей событийно-ориентированный подход (event-driven architecture). Какие диаграммы и нотации вы выберете и почему?',
    sampleAnswer:
      'Для документирования event-driven архитектуры я бы использовал комбинацию диаграмм: (1) C4 Container Diagram — для общего обзора: показать продюсеров событий, брокер сообщений (Kafka, RabbitMQ), потребителей, хранилища данных и их связи. Каждая стрелка подписывается типом взаимодействия (publish/subscribe, request/reply). (2) UML Sequence Diagram — для детального описания конкретных сценариев: порядок публикации и обработки событий, асинхронные сообщения (пунктирная стрелка), таймауты, компенсационные действия. Фрагменты alt/opt помогут описать обработку ошибок. (3) Каталог событий в табличной форме: имя события, продюсер, потребители, схема (JSON Schema / Avro), топик. (4) UML State Machine Diagram — для ключевых сущностей, состояние которых меняется по событиям (заказ, платёж). (5) Диаграмма потоков данных (Data Flow Diagram) или BPMN — для визуализации потока событий через систему, включая трансформации и фильтрации. Нотация AsyncAPI может дополнить документацию, описывая контракты асинхронных API аналогично OpenAPI для REST.',
    explanation:
      'Event-driven архитектура требует особого подхода к документированию, потому что взаимодействие асинхронно и распределено. Ключевые аспекты: (1) топология потоков событий, (2) контракты событий (schema), (3) порядок и зависимости между событиями, (4) обработка ошибок и идемпотентность. Одной диаграммы недостаточно — нужен набор представлений для разных аудиторий и аспектов.',
  },
  {
    id: 'sa-modeling-020',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип UML-диаграммы наиболее подходит для визуализации внутренней логической структуры системы — её модулей, пакетов и зависимостей между ними?',
    options: [
      'Диаграмма вариантов использования (Use Case Diagram)',
      'Диаграмма пакетов (Package Diagram)',
      'Диаграмма временной шкалы (Timing Diagram)',
      'Диаграмма деятельности (Activity Diagram)',
    ],
    correctIndex: 1,
    explanation:
      'Диаграмма пакетов (Package Diagram) показывает организацию модели в пакеты (пространства имён) и зависимости между ними. Она полезна для визуализации модульной структуры системы, слоёв архитектуры (presentation, business logic, data access), выделения подсистем и управления зависимостями. Стрелки зависимостей показывают, какой пакет «знает» о каком, что помогает контролировать связанность. Диаграмма вариантов использования описывает функциональность с точки зрения пользователя. Timing Diagram показывает изменение состояний во времени. Диаграмма деятельности описывает потоки работы и алгоритмы.',
  },
  {
    id: 'sa-modeling-021',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой элемент UML-диаграммы классов обозначает отношение, при котором один класс «содержит» другой, и время жизни содержимого совпадает с временем жизни контейнера?',
    options: [
      'Ассоциация (Association)',
      'Агрегация (Aggregation)',
      'Композиция (Composition)',
      'Зависимость (Dependency)',
    ],
    correctIndex: 2,
    explanation:
      'Композиция (Composition) — это сильная форма агрегации, при которой часть не может существовать отдельно от целого. Если удаляется объект-контейнер, удаляются и все его части. Обозначается закрашенным ромбом на стороне контейнера. Пример: Заказ и Строки заказа — при удалении заказа удаляются все его строки. Агрегация (пустой ромб) — слабое владение, часть может существовать независимо. Ассоциация — простая связь без владения. Зависимость (пунктирная стрелка) — один элемент использует другой.',
  },
  {
    id: 'sa-modeling-022',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что означает стереотип <<interface>> на UML-диаграмме классов?',
    options: [
      'Класс является абстрактным и не может иметь экземпляров',
      'Класс описывает контракт (набор методов без реализации), который должны реализовать другие классы',
      'Класс представляет пользовательский интерфейс',
      'Класс является точкой входа в приложение',
    ],
    correctIndex: 1,
    explanation:
      'Интерфейс (<<interface>>) в UML — это классификатор, определяющий контракт: набор сигнатур операций (методов) без реализации. Классы, реализующие интерфейс, обязаны предоставить реализацию всех его методов. Связь реализации обозначается пунктирной линией с пустой треугольной стрелкой от класса к интерфейсу. Интерфейсы ключевы для инверсии зависимостей (DIP) и проектирования слабо связанных систем. Абстрактный класс — другая концепция (может содержать реализацию, имя пишется курсивом).',
  },
  {
    id: 'sa-modeling-023',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'На UML-диаграмме последовательности, что означает прямоугольник на линии жизни (lifeline)?',
    options: [
      'Момент создания объекта',
      'Период активации — время, когда объект выполняет операцию',
      'Условие выполнения фрагмента',
      'Асинхронное сообщение',
    ],
    correctIndex: 1,
    explanation:
      'Прямоугольник на линии жизни (Activation Bar, Execution Specification) показывает период, когда объект активен — выполняет операцию или ожидает возврата из вызванного метода. Ширина прямоугольника не имеет значения, важна его высота, соответствующая длительности активации. Вложенные активации (прямоугольник на прямоугольнике) показывают рекурсивные вызовы или вызовы собственных методов. Создание объекта обозначается стрелкой, направленной к заголовку линии жизни. Асинхронное сообщение — открытая стрелка.',
  },
  {
    id: 'sa-modeling-024',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое нотация «воронья лапка» (Crow\'s Foot) и для чего она используется? Какие типы кардинальности она позволяет отображать?',
    sampleAnswer:
      'Нотация «воронья лапка» (Crow\'s Foot, также IE — Information Engineering) — популярная нотация для ER-диаграмм, названная по характерному символу, напоминающему птичью лапку. Кардинальность отображается на концах линий связи: одинарная вертикальная черта — «один» (обязательный), круг — «ноль» (необязательный), «воронья лапка» (три расходящиеся линии) — «много». Комбинации: черта + воронья лапка = «один или много» (1..N); круг + воронья лапка = «ноль, один или много» (0..N); две вертикальные черты = «ровно один» (1..1); круг + черта = «ноль или один» (0..1). Нотация интуитивно понятна и широко поддерживается инструментами (Lucidchart, draw.io, ER/Studio). Альтернативы: нотация Чена (ромбы для связей), IDEF1X (закрашенные/пустые круги), UML.',
    explanation:
      'Crow\'s Foot — де-факто стандарт для ER-диаграмм в индустрии благодаря компактности и читаемости. Аналитик должен уметь читать и создавать диаграммы в этой нотации, а также понимать её ограничения (не отображает атрибуты связей так же наглядно, как нотация Чена).',
  },
  {
    id: 'sa-modeling-025',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн проектирования на UML-диаграмме классов представлен классом с единственным приватным статическим экземпляром и публичным статическим методом getInstance()?',
    options: [
      'Factory Method',
      'Singleton',
      'Observer',
      'Strategy',
    ],
    correctIndex: 1,
    explanation:
      'Singleton — порождающий паттерн, гарантирующий существование только одного экземпляра класса и предоставляющий глобальную точку доступа к нему. На UML-диаграмме классов распознаётся по: приватному конструктору, приватному статическому полю instance того же типа, публичному статическому методу getInstance(). Применяется для логгеров, пулов соединений, конфигураций. Factory Method — создание объектов через метод в подклассах. Observer — подписка на изменения. Strategy — семейство взаимозаменяемых алгоритмов.',
  },
  {
    id: 'sa-modeling-026',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое мета-модель (metamodel) в контексте языков моделирования?',
    options: [
      'Модель предметной области конкретной системы',
      'Модель, описывающая структуру и правила самого языка моделирования',
      'Диаграмма, созданная автоматически из кода',
      'Высокоуровневая архитектурная схема предприятия',
    ],
    correctIndex: 1,
    explanation:
      'Мета-модель — это «модель моделей», описывающая абстрактный синтаксис языка моделирования: какие элементы существуют, какие у них свойства, как они могут быть связаны. Например, мета-модель UML определяет, что Class имеет атрибуты name, visibility, isAbstract, может содержать Property и Operation, связан с другими Class через Association. Мета-модель является основой для инструментов моделирования, трансформаций моделей (M2M), генерации кода (M2T) и валидации. MOF (Meta-Object Facility) — стандарт OMG для определения мета-моделей. Понимание мета-моделей важно для работы с MDA (Model-Driven Architecture).',
  },
  {
    id: 'sa-modeling-027',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой тип диаграммы UML показывает внутреннюю структуру класса, включая его части и соединители между ними?',
    options: [
      'Диаграмма классов (Class Diagram)',
      'Диаграмма компонентов (Component Diagram)',
      'Диаграмма композитной структуры (Composite Structure Diagram)',
      'Диаграмма объектов (Object Diagram)',
    ],
    correctIndex: 2,
    explanation:
      'Диаграмма композитной структуры (Composite Structure Diagram) показывает внутреннюю структуру классификатора (класса, компонента): его части (parts), порты (ports) и соединители (connectors) между ними. Используется для моделирования сложных классов, состоящих из взаимодействующих компонентов, например, подсистем или паттернов. Диаграмма классов показывает статическую структуру классов и их отношения, но не внутреннее устройство. Диаграмма компонентов — архитектурные компоненты и интерфейсы. Диаграмма объектов — снимок объектов в определённый момент времени.',
  },
  {
    id: 'sa-modeling-028',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните концепцию Domain-Driven Design (DDD) в контексте моделирования. Какие ключевые элементы модели предметной области выделяет DDD?',
    sampleAnswer:
      'Domain-Driven Design (DDD) — подход к проектированию сложного ПО, фокусирующийся на модели предметной области как центральном артефакте. Ключевые элементы модели по DDD: (1) Entity — объект с уникальной идентичностью, сохраняющейся на протяжении жизненного цикла (Пользователь, Заказ). (2) Value Object — объект без идентичности, определяемый только своими атрибутами, неизменяемый (Адрес, Деньги, Дата). (3) Aggregate — кластер связанных Entity и Value Objects с единой границей целостности; доступ только через корневую Entity (Aggregate Root). (4) Domain Service — операция, не принадлежащая естественно ни одной Entity (TransferService для перевода между счетами). (5) Repository — абстракция для получения и сохранения Aggregates. (6) Factory — создание сложных Aggregates. (7) Domain Event — значимое событие предметной области (OrderPlaced, PaymentReceived). (8) Bounded Context — граница, в пределах которой модель имеет определённое значение. DDD использует Ubiquitous Language — единый язык между разработчиками и экспертами предметной области.',
    explanation:
      'DDD влияет на моделирование: вместо ER-диаграмм с таблицами создаются модели Aggregates с чёткими границами. UML-диаграммы классов используются для визуализации Entity, Value Objects, Aggregates. Context Map — диаграмма, показывающая отношения между Bounded Contexts (Shared Kernel, Customer-Supplier, Conformist, Anticorruption Layer). Аналитик, применяющий DDD, моделирует бизнес-логику, а не структуру БД.',
  },
  {
    id: 'sa-modeling-029',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой элемент ArchiMate представляет внешнего потребителя услуг организации?',
    options: [
      'Business Actor',
      'Business Role',
      'Business Service',
      'Application Component',
    ],
    correctIndex: 0,
    explanation:
      'Business Actor в ArchiMate представляет внешнюю сущность, способную выполнять поведение — человека, организацию или систему вне рассматриваемого предприятия. Примеры: Клиент, Партнёр, Регулятор. Business Role — внутренняя роль в организации (Менеджер по продажам). Business Service — услуга, предоставляемая организацией (Обработка заказов). Application Component — элемент прикладного слоя (CRM-система). ArchiMate разделяет активную структуру (кто делает), поведение (что делается) и пассивную структуру (над чем делается) на каждом слое.',
  },
  {
    id: 'sa-modeling-030',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое профиль UML (UML Profile)?',
    options: [
      'Конфигурация инструмента моделирования для конкретного пользователя',
      'Механизм расширения UML для адаптации к конкретной предметной области через стереотипы, теговые значения и ограничения',
      'Шаблон документа для описания UML-моделей',
      'Набор готовых диаграмм для типовых систем',
    ],
    correctIndex: 1,
    explanation:
      'UML Profile — стандартный механизм расширения UML для адаптации к конкретным доменам без изменения мета-модели. Профиль определяет: стереотипы (<<stereotype>>) — расширение элементов новым «типом», теговые значения (tagged values) — дополнительные свойства элементов, ограничения (constraints) — правила валидации на OCL. Примеры профилей: SysML — для системной инженерии, MARTE — для встраиваемых систем реального времени, SoaML — для сервис-ориентированной архитектуры. Профили позволяют сохранить совместимость с UML-инструментами, добавляя доменно-специфическую семантику.',
  },
  {
    id: 'sa-modeling-031',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'open',
    question: 'Как обеспечить согласованность моделей, созданных в разных нотациях (например, BPMN для процессов, UML для системы, ArchiMate для архитектуры)? Какие практики и инструменты помогают в этом?',
    sampleAnswer:
      'Обеспечение согласованности разнородных моделей — ключевая задача в крупных проектах. Практики: (1) Единый репозиторий моделей — хранение всех моделей в одном инструменте или связанных инструментах с общим каталогом элементов (Enterprise Architect, Sparx EA, ARIS, Mega). (2) Общий глоссарий и словарь данных — единые имена и определения сущностей, ролей, систем используются во всех нотациях. (3) Трассируемость между моделями — явные связи между элементами разных моделей: BPMN User Task → UML Use Case → ArchiMate Application Service. (4) Правила именования — стандартизованные соглашения для всех типов элементов. (5) Регулярные ревью согласованности — проверка, что изменения в одной модели отражены в связанных. (6) Model-to-model трансформации — автоматическая генерация одних моделей из других (BPMN → UML Sequence Diagram). Инструменты: Enterprise Architect (поддержка BPMN, UML, ArchiMate в одном проекте), Archi + связка с другими инструментами, специализированные EA-платформы (LeanIX, Ardoq). Ключевой принцип — определить «источник истины» для каждого аспекта и направление синхронизации.',
    explanation:
      'Мультинотационное моделирование неизбежно в enterprise-проектах. Главный риск — расхождение моделей и «бумажная» архитектура, не соответствующая реальности. Роль аналитика — поддерживать живые, актуальные модели через интеграцию с процессами разработки (model-as-code, генерация из кода, автоматические проверки).',
  },
  {
    id: 'sa-modeling-032',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень абстракции MOF (Meta-Object Facility) содержит конкретные модели, созданные пользователем (например, диаграмму классов конкретной системы)?',
    options: [
      'M0 — уровень экземпляров (runtime-данные)',
      'M1 — уровень моделей',
      'M2 — уровень мета-моделей',
      'M3 — уровень мета-мета-модели',
    ],
    correctIndex: 1,
    explanation:
      'MOF (Meta-Object Facility) — стандарт OMG, определяющий четырёхуровневую архитектуру моделирования: M0 — реальные объекты (экземпляры классов в runtime, данные в БД); M1 — модели (диаграмма классов вашей системы, конкретная BPMN-диаграмма); M2 — мета-модели (спецификация UML, описывающая, что такое Class, Attribute, Association); M3 — мета-мета-модель MOF (описывает, как создавать мета-модели). Понимание MOF важно для работы с трансформациями моделей (QVT), DSL и генерацией кода.',
  },
  {
    id: 'sa-modeling-033',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'В нотации IDEF1X, что означает закрашенный кружок на конце связи?',
    options: [
      'Опциональная связь (0 или более)',
      'Обязательная связь «один» на стороне родителя',
      'Обязательная связь «много» (one-to-many, mandatory)',
      'Идентифицирующая связь',
    ],
    correctIndex: 2,
    explanation:
      'IDEF1X — нотация ER-моделирования, разработанная для стандартизации моделей данных в госструктурах США. Обозначения кардинальности: закрашенный кружок (solid dot) — обязательная связь «много» (one-or-more); пустой кружок (empty circle) — опциональная связь «много» (zero-or-more); отсутствие символа — «один». Идентифицирующая связь (сплошная линия) означает, что FK входит в PK дочерней сущности. Неидентифицирующая связь (пунктирная линия) — FK не входит в PK. IDEF1X менее интуитивна, чем Crow\'s Foot, но используется в некоторых отраслях и инструментах (ERwin).',
  },
  {
    id: 'sa-modeling-034',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое OCL (Object Constraint Language) и для чего он используется?',
    options: [
      'Язык программирования для создания UML-диаграмм',
      'Декларативный язык для описания ограничений и инвариантов в UML-моделях',
      'Протокол обмена данными между инструментами моделирования',
      'Формат экспорта диаграмм в XML',
    ],
    correctIndex: 1,
    explanation:
      'OCL (Object Constraint Language) — формальный декларативный язык, дополняющий UML. Позволяет описывать ограничения, которые невозможно выразить графически: инварианты классов (context Person inv: age >= 0), предусловия и постусловия операций (context Account::withdraw(amount) pre: amount <= balance), начальные значения, производные атрибуты, тела запросов. OCL — ключевая часть UML-спецификации и используется в MDA для трансформаций и валидации моделей. Навигация по ассоциациям: self.orders->select(o | o.total > 1000)->size() > 0.',
  },
  {
    id: 'sa-modeling-035',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы работаете над проектом, где используются разные инструменты моделирования (Confluence для документации, draw.io для диаграмм, отдельная ER-tool для БД). Как обеспечить интероперабельность и синхронизацию моделей?',
    sampleAnswer:
      'Стратегия обеспечения интероперабельности в гетерогенной среде: (1) Определить «источник истины» для каждого типа модели: ER-диаграммы — ER-tool (или схема БД как код), архитектурные диаграммы — draw.io/Structurizr, процессы — Confluence/BPMN-tool. (2) Использовать model-as-code подход где возможно: PlantUML/Mermaid для UML-диаграмм (хранятся в Git, версионируются, рендерятся в Confluence); Structurizr DSL для C4-моделей; DBML/Prisma Schema для ER-моделей; решения генерируют визуальные диаграммы из текстового описания. (3) Автоматизировать синхронизацию: CI/CD pipeline генерирует диаграммы из кода и публикует в Confluence; reverse engineering из БД обновляет ER-модель; API инструментов для синхронизации элементов. (4) Централизованный глоссарий: единый справочник терминов и сущностей в Confluence, на который ссылаются все диаграммы. (5) Соглашения о именовании: единые имена сущностей во всех моделях для ручной трассировки. (6) Регулярные ревью: периодическая сверка моделей разных инструментов на согласованность. Компромисс: полная автоматическая синхронизация редко достижима, но model-as-code + автогенерация значительно снижают расхождения.',
    explanation:
      'Гетерогенная среда моделирования — реальность большинства организаций. Идеальный вариант — единый EA-инструмент — часто недостижим из-за стоимости, кривой обучения и различных предпочтений команд. Подход model-as-code (PlantUML, Mermaid, Structurizr DSL) решает проблему версионирования и ревью моделей, интегрируя их в developer workflow.',
  },
  {
    id: 'sa-modeling-036',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой формат обмена моделями является стандартом OMG для экспорта/импорта UML-моделей между инструментами?',
    options: [
      'JSON-LD',
      'XMI (XML Metadata Interchange)',
      'GraphML',
      'YAML',
    ],
    correctIndex: 1,
    explanation:
      'XMI (XML Metadata Interchange) — стандарт OMG для обмена метаданными в формате XML. XMI позволяет сериализовать UML-модели (и любые модели, соответствующие MOF) в XML-документ для переноса между инструментами. На практике интероперабельность XMI между разными инструментами ограничена из-за различий в интерпретации стандарта и проприетарных расширений. Альтернативы: проприетарные форматы инструментов, model-as-code (PlantUML, Structurizr DSL). JSON-LD — формат связанных данных. GraphML — формат для графов.',
  },
  {
    id: 'sa-modeling-037',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните концепцию Model-Driven Development (MDD) и Model-Driven Architecture (MDA). Какие преимущества и ограничения имеет этот подход?',
    sampleAnswer:
      'Model-Driven Development (MDD) — подход к разработке, где модели являются основными артефактами, а не просто документацией. Model-Driven Architecture (MDA) — конкретная реализация MDD от OMG. Ключевые концепции MDA: (1) CIM (Computation Independent Model) — модель предметной области без технических деталей. (2) PIM (Platform Independent Model) — модель системы без привязки к платформе. (3) PSM (Platform Specific Model) — модель с деталями конкретной платформы (Java, .NET, DB). (4) Трансформации M2M (model-to-model) между уровнями и M2T (model-to-text) для генерации кода. Преимущества: повышение уровня абстракции, переиспользование моделей для разных платформ, автоматизация рутинной генерации кода, формальная верификация моделей. Ограничения: высокий порог входа, сложность инструментария, генерируемый код часто требует доработки, плохо подходит для agile с частыми изменениями, трудно поддерживать синхронизацию модель-код при изменениях в обоих направлениях. Современный тренд — «лёгкий» MDD: model-as-code (PlantUML), генерация API по OpenAPI-спецификации, Infrastructure-as-Code.',
    explanation:
      'MDA в чистом виде не получила массового распространения из-за сложности и негибкости. Однако идеи MDD живы в современных практиках: OpenAPI-first (генерация серверного/клиентского кода по спецификации API), GraphQL SDL, Terraform/Pulumi для инфраструктуры, ORM-генераторы. Аналитик может применять элементы MDD точечно — там, где генерация даёт ощутимый выигрыш.',
  },
  {
    id: 'sa-modeling-038',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой элемент на UML-диаграмме вариантов использования обозначает внешнего пользователя или систему, взаимодействующую с моделируемой системой?',
    options: [
      'Вариант использования (Use Case)',
      'Актор (Actor)',
      'Система (System)',
      'Связь включения (Include)',
    ],
    correctIndex: 1,
    explanation:
      'Актор (Actor) — внешняя сущность (пользователь, роль, внешняя система), взаимодействующая с системой. Изображается человечком («stick figure») или прямоугольником со стереотипом <<actor>>. Актор находится вне границы системы и инициирует или участвует в вариантах использования. Примеры: Покупатель, Администратор, Платёжная система. Вариант использования (Use Case) — эллипс внутри системы, описывающий функциональность. Include/Extend — отношения между вариантами использования.',
  },
  {
    id: 'sa-modeling-039',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что означает пунктирная стрелка с надписью <<include>> между двумя вариантами использования на UML-диаграмме?',
    options: [
      'Один вариант использования является альтернативой другого',
      'Базовый вариант использования обязательно включает поведение включаемого',
      'Один вариант использования опционально расширяет другой',
      'Варианты использования выполняются параллельно',
    ],
    correctIndex: 1,
    explanation:
      'Отношение <<include>> означает, что базовый вариант использования обязательно включает поведение другого (включаемого) варианта использования. Стрелка направлена от базового к включаемому. Используется для выделения общего поведения, используемого несколькими вариантами использования. Пример: «Оформить заказ» includes «Авторизоваться». Отношение <<extend>> — опциональное расширение базового варианта при определённом условии (стрелка направлена от расширяющего к базовому).',
  },
  {
    id: 'sa-modeling-040',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'На диаграмме состояний UML, что обозначает закрашенный кружок?',
    options: [
      'Конечное состояние',
      'Начальное псевдосостояние',
      'Состояние выбора (Choice)',
      'Историческое состояние',
    ],
    correctIndex: 1,
    explanation:
      'Начальное псевдосостояние (Initial Pseudostate) обозначается закрашенным кружком. От него исходит переход к первому реальному состоянию объекта. В каждом регионе диаграммы состояний может быть только одно начальное псевдосостояние. Конечное состояние — закрашенный кружок в кольце («бычий глаз»). Choice — ромб для условного ветвления. Историческое состояние (H или H*) — запоминание последнего активного состояния перед выходом из композитного состояния.',
  },
  {
    id: 'sa-modeling-041',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое «swimlane» (дорожка) на UML-диаграмме деятельности?',
    options: [
      'Вертикальная или горизонтальная полоса, разделяющая действия по ответственным исполнителям или подсистемам',
      'Переход между состояниями',
      'Область для размещения комментариев',
      'Контейнер для группировки связанных диаграмм',
    ],
    correctIndex: 0,
    explanation:
      'Swimlane (дорожка, раздел) — визуальный элемент на диаграмме деятельности, разделяющий действия по ответственности: ролям, подразделениям, системам или компонентам. Каждое действие размещается на дорожке того исполнителя, который его выполняет. Дорожки могут быть вертикальными или горизонтальными, вложенными (двумерная сетка для Role × System). Swimlanes делают диаграмму самодокументируемой: видно, кто за что отвечает, и где происходит передача ответственности (переход потока между дорожками).',
  },
  {
    id: 'sa-modeling-042',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните нотации UML Class Diagram и ER-диаграммы для моделирования структуры данных. Когда предпочтительнее использовать каждую?',
    sampleAnswer:
      'UML Class Diagram и ER-диаграмма решают схожую задачу — моделирование структуры данных — но с разных точек зрения. ER-диаграмма (Entity-Relationship): фокус на данных и их хранении; ориентирована на реляционные БД; показывает сущности, атрибуты, связи с кардинальностью; не отображает методы/поведение; нотации: Crow\'s Foot, Chen, IDEF1X. Предпочтительна для: проектирования схемы реляционной БД, коммуникации с DBA, документирования физической модели данных. UML Class Diagram: фокус на объектно-ориентированном дизайне; показывает классы, атрибуты, методы, отношения (наследование, композиция, агрегация, реализация интерфейсов); поддерживает стереотипы, видимость, абстрактные классы, интерфейсы. Предпочтительна для: дизайна доменной модели (DDD), проектирования объектной структуры приложения, документирования API и библиотек классов, когда важно показать поведение (методы). Пересечение: логическая модель данных может быть представлена обеими нотациями. На практике ER используется для уровня БД, Class Diagram — для уровня приложения.',
    explanation:
      'Выбор нотации зависит от аудитории и цели. Для коммуникации с бизнесом и DBA — ER-диаграмма в Crow\'s Foot. Для обсуждения с разработчиками объектной модели — UML Class Diagram. В DDD-проектах доменная модель обычно описывается через UML-классы с Entity, Value Object, Aggregate, а физическая схема БД — через ER.',
  },
  {
    id: 'sa-modeling-043',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой тип отношения в ArchiMate обозначает, что один элемент «обслуживает» или предоставляет услуги другому?',
    options: [
      'Composition',
      'Serving (ранее Used By)',
      'Triggering',
      'Flow',
    ],
    correctIndex: 1,
    explanation:
      'Serving (ранее Used By) — структурное отношение в ArchiMate, показывающее, что один элемент предоставляет свою функциональность другому. Стрелка направлена от обслуживающего к обслуживаемому элементу. Пример: Application Service «Авторизация» serves Business Process «Оформление заказа». Composition — часть-целое. Triggering — один элемент инициирует другой (причинно-следственная связь во времени). Flow — передача чего-либо (данных, материалов) между элементами.',
  },
  {
    id: 'sa-modeling-044',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'В чём ключевое отличие диаграммы объектов (Object Diagram) от диаграммы классов (Class Diagram) в UML?',
    options: [
      'Диаграмма объектов показывает только интерфейсы, а диаграмма классов — реализации',
      'Диаграмма объектов показывает конкретные экземпляры классов с их значениями в определённый момент времени',
      'Диаграмма объектов не поддерживает связи между элементами',
      'Диаграмма объектов используется только для тестирования',
    ],
    correctIndex: 1,
    explanation:
      'Object Diagram — «снимок» системы в определённый момент времени, показывающий конкретные объекты (экземпляры классов) и их связи. Имена объектов подчёркнуты и записываются как objectName:ClassName. Атрибуты показаны с конкретными значениями. Class Diagram — статическая структура на уровне типов (классов), без конкретных значений. Object Diagram полезна для: иллюстрации примеров работы системы, валидации модели классов на конкретных сценариях, документирования конфигураций.',
  },
  {
    id: 'sa-modeling-045',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Какие диаграммы и нотации вы бы использовали для документирования микросервисной архитектуры? Обоснуйте выбор для каждого аспекта.',
    sampleAnswer:
      'Документирование микросервисной архитектуры требует многоуровневого подхода: (1) Общая архитектура (System Context, Container): C4 Model — System Context для внешнего контекста (пользователи, внешние системы), Container Diagram для сервисов, баз данных, брокеров сообщений, API Gateway. Инструменты: Structurizr, IcePanel. (2) Взаимодействие между сервисами: UML Sequence Diagram — для конкретных сценариев (синхронные вызовы, асинхронные сообщения); AsyncAPI + OpenAPI — формальные спецификации API. (3) Структура данных: ER-диаграмма (Crow\'s Foot) — для каждого сервиса своя схема данных; важно показать границы владения данными (database-per-service). (4) Потоки событий: Event Storming результаты (sticky notes → Event Flow Diagram); BPMN — для оркестрированных процессов (Saga). (5) Инфраструктура: UML Deployment Diagram или облачная нотация (AWS/Azure icons) — для Kubernetes, облачных сервисов. (6) Доменная модель: Context Map (DDD) — для Bounded Contexts и их отношений; UML Class Diagram — для агрегатов внутри контекста. (7) Мониторинг и observability: Distributed tracing diagram (сервис → сервис с latency). Ключевой принцип — не создавать монструозную диаграмму, а использовать иерархию: от общего (C4 Context) к частному (Sequence Diagram конкретного сценария).',
    explanation:
      'Микросервисная архитектура требует баланса между полнотой документации и её поддерживаемостью. C4 Model идеально подходит благодаря уровням абстракции. Формальные спецификации API (OpenAPI, AsyncAPI) служат и документацией, и контрактом. Event Storming — отличный способ совместного моделирования с командой. Главное — документация должна быть живой, интегрированной в процесс разработки.',
  },
  {
    id: 'sa-modeling-046',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип связи в UML обозначается сплошной линией с пустой треугольной стрелкой?',
    options: [
      'Ассоциация',
      'Зависимость',
      'Наследование (Generalization)',
      'Реализация',
    ],
    correctIndex: 2,
    explanation:
      'Наследование (Generalization) в UML обозначается сплошной линией с пустой (незакрашенной) треугольной стрелкой, направленной от подкласса к суперклассу. Подкласс наследует атрибуты и операции суперкласса. Пример: класс «Менеджер» наследует от класса «Сотрудник». Ассоциация — сплошная линия без наконечника или с простыми стрелками. Зависимость — пунктирная линия с открытой стрелкой. Реализация (интерфейса) — пунктирная линия с пустой треугольной стрелкой.',
  },
  {
    id: 'sa-modeling-047',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое PlantUML и в чём его основное преимущество перед графическими редакторами диаграмм?',
    options: [
      'Коммерческий инструмент для создания 3D-моделей',
      'Текстовый язык для описания UML-диаграмм, позволяющий версионировать модели в Git и автоматизировать генерацию',
      'Библиотека компонентов для Figma',
      'Плагин для тестирования UML-моделей',
    ],
    correctIndex: 1,
    explanation:
      'PlantUML — открытый инструмент, позволяющий описывать UML-диаграммы (и другие: C4, ER, Gantt) в текстовом формате и генерировать из них изображения. Преимущества: версионирование в Git (diff, merge, history), автоматизация (генерация в CI/CD, из комментариев в коде), интеграция с IDE и документацией (Confluence, Markdown), воспроизводимость, отсутствие привязки к проприетарным форматам. Недостатки: ограниченный контроль над layout, кривая обучения синтаксиса. Альтернативы: Mermaid, Structurizr DSL.',
  },
  {
    id: 'sa-modeling-048',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'middle',
    type: 'quiz',
    question: 'На диаграмме последовательности UML, что означает символ «X» в конце линии жизни?',
    options: [
      'Ошибка в процессе выполнения',
      'Уничтожение объекта (destruction)',
      'Асинхронное сообщение',
      'Точка синхронизации',
    ],
    correctIndex: 1,
    explanation:
      'Символ «X» (крест) в конце линии жизни обозначает уничтожение объекта (destruction occurrence). После этого момента объект более не существует и не может получать сообщения. Уничтожение может произойти в результате сообщения (стрелка к «X») или самостоятельно. Не каждый объект явно уничтожается на диаграмме — это показывается только когда важно для понимания сценария (например, освобождение ресурсов, завершение сессии).',
  },
  {
    id: 'sa-modeling-049',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы используете Event Storming для моделирования сложного бизнес-домена. Опишите процесс и артефакты, которые создаются в ходе сессии.',
    sampleAnswer:
      'Event Storming — воркшоп-техника коллаборативного моделирования, созданная Альберто Брандолини. Процесс: (1) Big Picture Event Storming (2-4 часа): собираются эксперты домена, разработчики, аналитики; на большой стене размещаются оранжевые стикеры с доменными событиями (Domain Events) в прошедшем времени («Заказ создан», «Платёж получен»); события располагаются на временной шкале слева направо. (2) Добавление команд и акторов: синие стикеры — команды (Commands), инициирующие события; жёлтые — акторы (кто инициирует команду); розовые — внешние системы. (3) Выявление агрегатов: жёлтые крупные стикеры — агрегаты (Aggregates), группирующие связанные команды и события. (4) Выявление политик: сиреневые стикеры — политики/бизнес-правила, связывающие события и команды («Когда Платёж получен, тогда Отправить заказ»). (5) Выделение Bounded Contexts: группировка связанных агрегатов в контексты с чёткими границами. (6) Выявление проблем: красные/розовые стикеры для вопросов, неясностей, рисков. Артефакты: фото стены (primary artifact), цифровая версия в Miro/Mural, Context Map, Event Flow Diagram, список агрегатов и событий для реализации. Event Storming — отличный input для DDD-моделирования и проектирования event-driven архитектуры.',
    explanation:
      'Event Storming решает проблему knowledge elicitation: эксперты домена передают знания разработчикам в процессе совместной работы, а не через документ. Результат — общее понимание домена и язык (Ubiquitous Language). Техника особенно эффективна для legacy-систем (выявление скрытой логики) и новых продуктов (формирование модели с нуля).',
  },
  {
    id: 'sa-modeling-050',
    block: 'sa',
    topic: 'modeling',
    topicLabel: 'Нотации моделирования',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Archimate Viewpoint и зачем он нужен?',
    options: [
      'Конкретная диаграмма, созданная в инструменте моделирования',
      'Предопределённый набор допустимых элементов и отношений ArchiMate для конкретной цели или аудитории',
      'Версия модели в системе контроля версий',
      'Экспортированный PDF-файл с моделью',
    ],
    correctIndex: 1,
    explanation:
      'ArchiMate Viewpoint — предопределённая «точка зрения» на архитектуру, определяющая: какие элементы и отношения допустимы, для какой аудитории предназначена, какие вопросы отвечает. Примеры viewpoints: Organization Viewpoint (бизнес-роли и акторы), Application Cooperation Viewpoint (взаимодействие приложений), Infrastructure Viewpoint (технологическая инфраструктура), Layered Viewpoint (все три слоя вместе). Viewpoints помогают создавать целенаправленные диаграммы для конкретной аудитории (бизнес, IT, инфраструктура) вместо одной перегруженной модели. Стандарт ArchiMate определяет более 20 viewpoints.',
  },
];
