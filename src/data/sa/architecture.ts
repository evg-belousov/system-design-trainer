import type { Question } from '../types';

export const architectureQuestions: Question[] = [
  {
    id: 'sa-architecture-001',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой архитектурный стиль API использует HTTP-методы (GET, POST, PUT, DELETE) для операций над ресурсами, идентифицируемыми по URL?',
    options: [
      'SOAP',
      'REST',
      'GraphQL',
      'gRPC',
    ],
    correctIndex: 1,
    explanation:
      'REST (Representational State Transfer) — архитектурный стиль, основанный на принципах работы с ресурсами через стандартные HTTP-методы. Каждый ресурс имеет уникальный URI. GET — получение, POST — создание, PUT — полное обновление, PATCH — частичное обновление, DELETE — удаление. REST не является протоколом (в отличие от SOAP) — это набор архитектурных ограничений: stateless, uniform interface, client-server, cacheable, layered system. SOAP — протокол обмена структурированными сообщениями на базе XML с WSDL-описанием. GraphQL позволяет клиенту запрашивать именно те данные, которые ему нужны. gRPC использует Protocol Buffers и HTTP/2 для высокопроизводительного RPC.',
  },
  {
    id: 'sa-architecture-002',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое XSD в контексте веб-сервисов?',
    options: [
      'Протокол передачи данных поверх HTTP',
      'Язык описания структуры XML-документов (XML Schema Definition)',
      'Формат сериализации данных, альтернатива JSON',
      'Инструмент автоматического тестирования API',
    ],
    correctIndex: 1,
    explanation:
      'XSD (XML Schema Definition) — язык описания структуры XML-документа. XSD-схема определяет допустимые элементы и атрибуты, их типы данных, ограничения (минимальные/максимальные значения, паттерны, перечисления), обязательность полей, вложенность и порядок элементов. В контексте SOAP-сервисов XSD используется внутри WSDL для описания типов данных запросов и ответов. Это позволяет автоматически валидировать XML-сообщения и генерировать код клиентских/серверных заглушек. XSD также широко применяется в корпоративных интеграциях для формализации форматов обмена данными между системами.',
  },
  {
    id: 'sa-architecture-003',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какое ключевое преимущество асинхронного взаимодействия через брокер сообщений (например, Kafka, RabbitMQ) по сравнению с синхронным REST-вызовом?',
    options: [
      'Гарантия доставки сообщения в реальном времени',
      'Снижение связанности (coupling) между сервисами и возможность обработки пиковых нагрузок',
      'Более простая отладка и трассировка запросов',
      'Автоматическая типизация данных без необходимости в схемах',
    ],
    correctIndex: 1,
    explanation:
      'Асинхронное взаимодействие через брокер сообщений обеспечивает слабую связанность (loose coupling): отправитель не знает о получателе и не ждёт его ответа. Это даёт несколько преимуществ: (1) Temporal decoupling — сервис-получатель может быть временно недоступен, сообщение сохранится в очереди. (2) Сглаживание пиковых нагрузок (load leveling) — брокер буферизирует сообщения, получатель обрабатывает их в своём темпе. (3) Масштабируемость — можно добавлять потребителей для параллельной обработки. (4) Возможность fan-out — одно сообщение могут получить несколько подписчиков. Недостатки: усложнение отладки, eventual consistency, необходимость обработки дублей (идемпотентность) и мониторинга очередей.',
  },
  {
    id: 'sa-architecture-004',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните SOAP и REST с точки зрения системного аналитика. В каких сценариях вы бы рекомендовали использование SOAP, а в каких — REST?',
    sampleAnswer:
      'REST предпочтителен для публичных API, мобильных приложений, микросервисных архитектур — везде, где важна простота, скорость разработки и гибкость формата данных (JSON). REST легче документировать (OpenAPI/Swagger), тестировать и кэшировать. SOAP рекомендуется для корпоративных интеграций, где критичны: (1) формальный контракт (WSDL + XSD обеспечивает строгую типизацию и автогенерацию кода); (2) встроенные стандарты безопасности (WS-Security для шифрования и подписи на уровне сообщения); (3) надёжная доставка (WS-ReliableMessaging); (4) транзакционность (WS-AtomicTransaction); (5) работа поверх разных транспортов (не только HTTP, но и JMS, SMTP). Типичные SOAP-сценарии: банковские системы, государственные сервисы, ERP-интеграции. При выборе аналитик должен учитывать требования к безопасности, существующий ландшафт (legacy-системы часто поддерживают только SOAP), компетенции команды и нефункциональные требования.',
    explanation:
      'Ключевые критерии выбора: (1) Строгость контракта — SOAP через WSDL/XSD, REST через OpenAPI (менее строго). (2) Безопасность — SOAP имеет WS-Security на уровне сообщения, REST полагается на HTTPS и OAuth. (3) Транспорт — REST привязан к HTTP, SOAP транспортно-независим. (4) Производительность — REST с JSON компактнее XML-конвертов SOAP. (5) Экосистема — REST доминирует в современных архитектурах, SOAP — в enterprise-legacy.',
  },
  {
    id: 'sa-architecture-005',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы проектируете систему, в которой микросервис заказов должен взаимодействовать с микросервисом оплаты и микросервисом склада. Опишите подходы к оркестрации и хореографии, их плюсы и минусы, и предложите паттерн обеспечения консистентности данных.',
    sampleAnswer:
      'Оркестрация: выделяется центральный сервис-оркестратор (например, сервис заказов), который последовательно вызывает сервис оплаты и сервис склада, управляя всей логикой процесса. Плюсы: логика процесса сосредоточена в одном месте, легче понимать и отлаживать. Минусы: оркестратор становится единой точкой отказа и бутылочным горлышком, сильная связанность. Хореография: каждый сервис реагирует на события других сервисов через брокер сообщений. Сервис заказов публикует событие «Заказ создан», сервис оплаты подписан на него и после обработки публикует «Оплата выполнена», сервис склада реагирует резервированием товара. Плюсы: слабая связанность, лучшая масштабируемость. Минусы: бизнес-логика распределена, сложнее отслеживать полный процесс, риск «зацикливания» событий. Для обеспечения консистентности рекомендуется паттерн Saga: каждый шаг имеет компенсирующее действие. Если оплата прошла, но резервирование на складе не удалось — выполняется возврат средств (компенсация). Saga может быть реализована как в стиле оркестрации (Saga-координатор), так и хореографии (через события). Дополнительно необходимы: идемпотентность обработчиков, Outbox-паттерн для надёжной публикации событий, корреляционные идентификаторы для трассировки.',
    explanation:
      'Оркестрация vs хореография — фундаментальный выбор в микросервисной архитектуре. Оркестрация проще для линейных процессов с небольшим количеством участников. Хореография масштабируется лучше, но требует зрелой инфраструктуры (distributed tracing, мониторинг событий). Паттерн Saga заменяет распределённые ACID-транзакции, обеспечивая eventual consistency. Аналитик должен документировать как «счастливый путь», так и все компенсирующие действия для каждого шага процесса.',
  },
  {
    id: 'sa-architecture-006',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн интеграции обеспечивает надёжную публикацию события в брокер сообщений вместе с сохранением данных в БД в рамках одной логической транзакции?',
    options: [
      'Circuit Breaker',
      'Transactional Outbox',
      'API Gateway',
      'Service Mesh',
    ],
    correctIndex: 1,
    explanation:
      'Паттерн Transactional Outbox решает проблему dual write: когда сервису нужно одновременно обновить свою БД и отправить сообщение в брокер, но эти два действия не могут быть объединены в одну ACID-транзакцию. Решение: событие записывается в специальную таблицу outbox в той же БД в рамках той же транзакции, что и бизнес-данные. Отдельный процесс (relay/poller или CDC — Change Data Capture, например, Debezium) читает записи из outbox и публикует их в брокер. Это гарантирует, что событие будет отправлено тогда и только тогда, когда бизнес-данные успешно сохранены. Circuit Breaker предотвращает каскадные отказы. API Gateway — единая точка входа. Service Mesh — инфраструктурный слой для межсервисного взаимодействия.',
  },
  {
    id: 'sa-architecture-007',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой HTTP-метод в REST API является идемпотентным и используется для полной замены ресурса?',
    options: [
      'POST',
      'PATCH',
      'PUT',
      'DELETE',
    ],
    correctIndex: 2,
    explanation:
      'PUT — идемпотентный HTTP-метод, который заменяет ресурс целиком. Повторный вызов PUT с теми же данными даёт тот же результат (идемпотентность). POST не является идемпотентным — каждый вызов может создавать новый ресурс. PATCH — частичное обновление, формально не обязан быть идемпотентным (хотя на практике часто реализуется таким образом). DELETE также идемпотентен — повторное удаление уже удалённого ресурса не меняет состояние системы. Понимание идемпотентности критично для проектирования устойчивых API: при сетевых сбоях клиент может безопасно повторять идемпотентные запросы без риска дублирования данных.',
  },
  {
    id: 'sa-architecture-008',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое API Gateway в микросервисной архитектуре?',
    options: [
      'База данных, общая для всех микросервисов',
      'Единая точка входа для клиентских запросов, выполняющая маршрутизацию, аутентификацию и агрегацию',
      'Сервис, отвечающий за развёртывание микросервисов в продакшн',
      'Инструмент для автоматического тестирования API',
    ],
    correctIndex: 1,
    explanation:
      'API Gateway — паттерн микросервисной архитектуры, представляющий единую точку входа для всех клиентских запросов. Основные функции: маршрутизация запросов к соответствующим микросервисам, аутентификация и авторизация, rate limiting (ограничение частоты запросов), агрегация ответов от нескольких сервисов, кэширование, трансформация протоколов (например, REST для внешних клиентов, gRPC для внутреннего взаимодействия), логирование и мониторинг. Популярные реализации: Kong, NGINX, AWS API Gateway, Spring Cloud Gateway. API Gateway скрывает внутреннюю структуру микросервисов от клиентов и упрощает работу фронтенд-разработчиков.',
  },
  {
    id: 'sa-architecture-009',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Webhook?',
    options: [
      'Специальный тип базы данных для хранения событий',
      'HTTP-обратный вызов: сервер отправляет HTTP-запрос на заранее указанный URL при наступлении события',
      'Протокол двусторонней связи поверх TCP (аналог WebSocket)',
      'Метод шифрования данных в REST API',
    ],
    correctIndex: 1,
    explanation:
      'Webhook — это механизм обратного вызова (callback) через HTTP. Вместо того чтобы клиент периодически опрашивал сервер на наличие новых данных (polling), сервер сам отправляет HTTP POST-запрос на заранее зарегистрированный URL клиента при наступлении определённого события. Например, платёжный шлюз отправляет webhook в интернет-магазин при успешной оплате. Преимущества: реальное время получения уведомлений, экономия ресурсов (нет лишних запросов). Важные аспекты проектирования: верификация подписи (HMAC), идемпотентность обработки (webhook может быть доставлен повторно), обработка ошибок и retry-политика, таймауты.',
  },
  {
    id: 'sa-architecture-010',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой интеграционный подход предполагает централизованную шину, через которую проходят все сообщения между системами?',
    options: [
      'Точка-точка (Point-to-Point)',
      'Enterprise Service Bus (ESB)',
      'Shared Database',
      'File Transfer',
    ],
    correctIndex: 1,
    explanation:
      'Enterprise Service Bus (ESB) — интеграционный паттерн, в котором все системы подключаются к централизованной шине сообщений. ESB берёт на себя маршрутизацию, трансформацию форматов данных, оркестрацию и мониторинг. Преимущества: снижение количества прямых связей между системами (вместо N*(N-1)/2 связей — N подключений к шине), централизованное управление интеграциями. Недостатки: единая точка отказа, сложность поддержки, риск превращения в «монолитный интеграционный слой». В современных архитектурах ESB часто заменяют более легковесными решениями — API Gateway, брокеры сообщений (Kafka, RabbitMQ) или Service Mesh.',
  },
  {
    id: 'sa-architecture-011',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните разницу между ETL и ELT. Когда применяется каждый подход?',
    sampleAnswer:
      'ETL (Extract, Transform, Load) — классический подход к интеграции данных: данные извлекаются из источников (Extract), трансформируются в промежуточном слое (Transform) — очищаются, агрегируются, приводятся к целевой схеме — и затем загружаются в хранилище (Load). Трансформация происходит ДО загрузки, обычно на выделенном ETL-сервере. Подходит, когда целевое хранилище имеет ограниченные вычислительные ресурсы (традиционные DWH), нужна сложная бизнес-логика трансформации. ELT (Extract, Load, Transform) — данные извлекаются и загружаются в целевое хранилище «как есть» (в сыром виде), а трансформация выполняется уже внутри хранилища средствами его движка. Подходит для облачных хранилищ с эластичными вычислительными ресурсами (BigQuery, Snowflake, ClickHouse), когда нужно хранить исторические сырые данные и применять разные трансформации по мере необходимости (schema-on-read). ELT стал доминирующим подходом в современных data-платформах благодаря масштабируемости облачных хранилищ.',
    explanation:
      'Ключевое различие — где происходит трансформация: вне хранилища (ETL) или внутри него (ELT). ETL — зрелый подход с развитой экосистемой инструментов (Informatica, Talend, SSIS). ELT лучше использует ресурсы облачных хранилищ (dbt, Dataform). Аналитик должен учитывать объёмы данных, требования к латентности, доступные инструменты и навыки команды.',
  },
  {
    id: 'sa-architecture-012',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем SOA (сервис-ориентированная архитектура) принципиально отличается от микросервисной архитектуры?',
    options: [
      'SOA не использует сетевое взаимодействие между сервисами',
      'В микросервисах каждый сервис имеет собственное хранилище данных, а в SOA сервисы часто разделяют общую БД',
      'SOA поддерживает только синхронное взаимодействие, микросервисы — только асинхронное',
      'Микросервисы не могут использовать брокеры сообщений',
    ],
    correctIndex: 1,
    explanation:
      'Хотя SOA и микросервисы разделяют идею декомпозиции на сервисы, ключевые различия: (1) Размер сервисов — SOA-сервисы обычно крупнее и охватывают целый бизнес-домен, микросервисы более гранулярные. (2) Данные — в микросервисной архитектуре строго соблюдается принцип «database per service», каждый сервис владеет своими данными; в SOA сервисы часто разделяют общую БД. (3) Интеграция — SOA часто использует ESB для оркестрации и тяжёлые стандарты (WS-*, SOAP); микросервисы предпочитают лёгкие протоколы (REST, gRPC) и «умные эндпоинты, глупые каналы». (4) Развёртывание — микросервисы разворачиваются независимо, SOA-сервисы могут иметь связанные циклы релизов. (5) Управление — SOA предполагает централизованное управление (governance), микросервисы — децентрализованное.',
  },
  {
    id: 'sa-architecture-013',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн интеграции предполагает, что сервисы реагируют на события, публикуемые другими сервисами, без прямых вызовов между ними?',
    options: [
      'Request-Reply',
      'Shared Database',
      'Event-Driven (Publish-Subscribe)',
      'Remote Procedure Call (RPC)',
    ],
    correctIndex: 2,
    explanation:
      'Event-Driven интеграция по модели Publish-Subscribe предполагает, что сервис-продюсер публикует событие (например, «Заказ создан») в брокер сообщений, не зная, кто его обработает. Сервисы-подписчики получают событие и реагируют на него: сервис уведомлений отправляет email, сервис аналитики обновляет статистику, сервис склада резервирует товар. Преимущества: минимальная связанность (продюсер не зависит от потребителей), лёгкость добавления новых подписчиков без изменения продюсера. Недостатки: eventual consistency, сложность отладки и трассировки, необходимость мониторинга очередей. Request-Reply — синхронный вызов с ожиданием ответа. RPC — удалённый вызов процедуры. Shared Database — интеграция через общую БД.',
  },
  {
    id: 'sa-architecture-014',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое ADR (Architecture Decision Record) и зачем он нужен? Какие ключевые разделы должен содержать ADR?',
    sampleAnswer:
      'ADR (Architecture Decision Record) — документ, фиксирующий значимое архитектурное решение: что было решено, почему и какие альтернативы рассматривались. ADR создаёт «институциональную память» проекта: через год новый член команды сможет понять, почему была выбрана PostgreSQL, а не MongoDB, или почему коммуникация между сервисами идёт через Kafka, а не REST. Ключевые разделы ADR: (1) Title — краткое описание решения. (2) Status — предложено / принято / отклонено / заменено. (3) Context — контекст и проблема, которую нужно решить. (4) Decision — само решение. (5) Consequences — последствия (плюсы и минусы), компромиссы. (6) Alternatives Considered — рассмотренные альтернативы с обоснованием отказа. ADR обычно хранятся в репозитории проекта (docs/adr/) и нумеруются последовательно. Популярные шаблоны: Michael Nygard, MADR.',
    explanation:
      'ADR решает проблему «утерянного контекста»: без документирования причин архитектурных решений команда рискует повторно обсуждать одни и те же вопросы или отменять обоснованные решения. ADR не заменяет архитектурную документацию, а дополняет её, фокусируясь на «почему», а не «как». Аналитик часто выступает инициатором и автором ADR, особенно для решений, затрагивающих интеграции и модель данных.',
  },
  {
    id: 'sa-architecture-015',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой фреймворк корпоративной архитектуры включает ADM (Architecture Development Method) как центральный процесс разработки архитектуры?',
    options: [
      'Zachman Framework',
      'TOGAF',
      'FEAF',
      'DoDAF',
    ],
    correctIndex: 1,
    explanation:
      'TOGAF (The Open Group Architecture Framework) — один из наиболее широко используемых фреймворков корпоративной архитектуры. Его центральный компонент — ADM (Architecture Development Method) — итеративный процесс из нескольких фаз: предварительная подготовка, определение видения архитектуры, бизнес-архитектура, архитектура информационных систем, технологическая архитектура, возможности и решения, планирование миграции, управление реализацией, управление изменениями. TOGAF также включает континуум предприятия (Enterprise Continuum), репозиторий архитектуры и набор эталонных моделей. Zachman Framework — классификационная схема (матрица) артефактов архитектуры. FEAF — федеральный фреймворк (США). DoDAF — фреймворк министерства обороны США.',
  },
  {
    id: 'sa-architecture-016',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн помогает предотвратить каскадные отказы в распределённой системе, прекращая вызовы к неработающему сервису на определённое время?',
    options: [
      'Retry Pattern',
      'Bulkhead Pattern',
      'Circuit Breaker',
      'Sidecar Pattern',
    ],
    correctIndex: 2,
    explanation:
      'Circuit Breaker (автоматический выключатель) — паттерн устойчивости, предотвращающий каскадные отказы. Работает по аналогии с электрическим автоматом: (1) Closed — запросы проходят нормально, сбои подсчитываются. (2) Open — при достижении порога сбоев цепь «размыкается»: запросы к проблемному сервису немедленно отклоняются без фактического вызова (fail fast), возвращается fallback-ответ. (3) Half-Open — через настраиваемый интервал пропускается пробный запрос; если успешен — цепь замыкается, если нет — остаётся открытой. Retry Pattern — повторные попытки (может усугубить проблему без Circuit Breaker). Bulkhead — изоляция ресурсов (пулы потоков, connection pools) для предотвращения распространения сбоя. Sidecar — вспомогательный контейнер рядом с основным сервисом.',
  },
  {
    id: 'sa-architecture-017',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните SOAP и REST с технической точки зрения: протоколы, форматы данных, описание контракта, безопасность, надёжность. В каком случае SOAP до сих пор является предпочтительным выбором?',
    sampleAnswer:
      'Техническое сравнение: (1) Протокол: SOAP — полноценный протокол со строгой спецификацией конверта (Envelope, Header, Body, Fault); REST — архитектурный стиль поверх HTTP, использующий стандартные HTTP-методы и статус-коды. (2) Формат данных: SOAP — исключительно XML; REST — JSON (основной), XML, YAML, бинарные форматы. (3) Контракт: SOAP — WSDL + XSD (строго типизированный, позволяет автогенерацию кода); REST — OpenAPI/Swagger (менее строгий, описывается постфактум). (4) Безопасность: SOAP — WS-Security (шифрование и подпись на уровне сообщения, работает через любого посредника); REST — HTTPS + OAuth 2.0 (безопасность на уровне транспорта). (5) Надёжность: SOAP — WS-ReliableMessaging (гарантированная доставка, порядок сообщений); REST — нет встроенного механизма, реализуется на уровне приложения. (6) Транзакции: SOAP — WS-AtomicTransaction; REST — нет стандарта. SOAP предпочтителен: банковские и финансовые системы, государственные сервисы (СМЭВ), интеграция с legacy-системами, когда требуется подпись на уровне сообщения или гарантированная доставка.',
    explanation:
      'SOAP остаётся актуальным в enterprise-среде, где критичны формальные контракты, безопасность на уровне сообщения и интеграция с legacy. REST доминирует в публичных API, мобильных приложениях и микросервисах. Аналитик должен понимать оба подхода и рекомендовать выбор на основе конкретных требований, а не моды.',
  },
  {
    id: 'sa-architecture-018',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн Event Sourcing. Какие преимущества и сложности он несёт? В каких системах его целесообразно применять?',
    sampleAnswer:
      'Event Sourcing — архитектурный паттерн, при котором состояние системы определяется не текущим снимком данных, а последовательностью событий (event log). Каждое изменение состояния записывается как неизменяемое событие: «Товар добавлен в корзину», «Цена изменена», «Заказ отменён». Текущее состояние восстанавливается путём воспроизведения (replay) всех событий. Преимущества: (1) Полный аудит — каждое изменение зафиксировано с причиной, автором и временем. (2) Возможность восстановить состояние на любой момент в прошлом (temporal queries). (3) Возможность построить новые проекции данных (read models), воспроизведя события. (4) Естественная интеграция с CQRS и event-driven архитектурой. Сложности: (1) Эволюция схемы событий (event versioning) — нельзя изменить структуру опубликованного события. (2) Сложность запросов — для чтения нужны проекции (materialized views). (3) Увеличение объёма хранимых данных. (4) Снэпшоты (snapshots) нужны для оптимизации восстановления при большом количестве событий. Применение: финансовые системы (банковские транзакции), системы бронирования, аудируемые системы (здравоохранение), корзины покупок.',
    explanation:
      'Event Sourcing часто сочетается с CQRS (Command Query Responsibility Segregation): команды записывают события, а запросы работают с оптимизированными проекциями. Это мощный, но сложный паттерн — не стоит применять его повсеместно. Аналитик должен оценить, оправданы ли преимущества полного аудита и временных запросов для данного домена.',
  },
  {
    id: 'sa-architecture-019',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход к интеграции данных предполагает загрузку сырых данных в хранилище с последующей трансформацией внутри хранилища?',
    options: [
      'ETL (Extract, Transform, Load)',
      'ELT (Extract, Load, Transform)',
      'CDC (Change Data Capture)',
      'ESB (Enterprise Service Bus)',
    ],
    correctIndex: 1,
    explanation:
      'ELT (Extract, Load, Transform) — подход, при котором данные извлекаются из источников, загружаются в целевое хранилище «как есть» (сырыми), а трансформация выполняется уже внутри хранилища средствами его SQL-движка. Это стало возможным благодаря облачным хранилищам с эластичными вычислительными ресурсами (BigQuery, Snowflake, Databricks). Преимущества: хранение исходных данных, возможность перетрансформировать при изменении бизнес-логики, использование мощности хранилища. ETL — классический подход, где трансформация происходит до загрузки. CDC — механизм отслеживания изменений в базе-источнике (не сам подход к загрузке). ESB — шина интеграции для взаимодействия между системами.',
  },
  {
    id: 'sa-architecture-020',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн микросервисной архитектуры предполагает, что каждый микросервис владеет собственной базой данных и не имеет прямого доступа к данным других сервисов?',
    options: [
      'Shared Database',
      'Database per Service',
      'CQRS',
      'Strangler Fig',
    ],
    correctIndex: 1,
    explanation:
      'Database per Service — ключевой паттерн микросервисной архитектуры, согласно которому каждый микросервис имеет собственное хранилище данных, инкапсулирует доступ к нему и предоставляет данные другим сервисам только через свой API. Преимущества: независимость развёртывания и масштабирования, свобода выбора технологии хранения (polyglot persistence), отсутствие блокировок на уровне БД между сервисами. Недостатки: сложность реализации запросов, затрагивающих данные нескольких сервисов (нужны API Composition, CQRS или Saga), дублирование данных. Shared Database — антипаттерн для микросервисов, хотя допустим в SOA. CQRS — разделение моделей чтения и записи. Strangler Fig — паттерн постепенной миграции с монолита.',
  },
];
