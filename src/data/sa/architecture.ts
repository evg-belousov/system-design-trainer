import type { Question } from '../types';

export const architectureQuestions: Question[] = [
  {
    id: 'sa-architecture-001',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой архитектурный стиль API использует HTTP-методы (GET, POST, PUT, DELETE) для операций над ресурсами, идентифицируемыми по URL?',
    options: [
      'SOAP',
      'REST',
      'GraphQL',
      'gRPC',
    ],
    correctIndex: 1,
    explanation:
      'REST (Representational State Transfer) — архитектурный стиль, основанный на принципах работы с ресурсами через стандартные HTTP-методы. Каждый ресурс имеет уникальный URI. GET — получение, POST — создание, PUT — полное обновление, PATCH — частичное обновление, DELETE — удаление. REST не является протоколом (в отличие от SOAP) — это набор архитектурных ограничений: stateless, uniform interface, client-server, cacheable, layered system. SOAP — протокол обмена структурированными сообщениями на базе XML с WSDL-описанием. GraphQL позволяет клиенту запрашивать именно те данные, которые ему нужны. gRPC использует Protocol Buffers и HTTP/2 для высокопроизводительного RPC.',
  },
  {
    id: 'sa-architecture-002',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое XSD в контексте веб-сервисов?',
    options: [
      'Протокол передачи данных поверх HTTP',
      'Язык описания структуры XML-документов (XML Schema Definition)',
      'Формат сериализации данных, альтернатива JSON',
      'Инструмент автоматического тестирования API',
    ],
    correctIndex: 1,
    explanation:
      'XSD (XML Schema Definition) — язык описания структуры XML-документа. XSD-схема определяет допустимые элементы и атрибуты, их типы данных, ограничения (минимальные/максимальные значения, паттерны, перечисления), обязательность полей, вложенность и порядок элементов. В контексте SOAP-сервисов XSD используется внутри WSDL для описания типов данных запросов и ответов. Это позволяет автоматически валидировать XML-сообщения и генерировать код клиентских/серверных заглушек. XSD также широко применяется в корпоративных интеграциях для формализации форматов обмена данными между системами.',
  },
  {
    id: 'sa-architecture-003',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какое ключевое преимущество асинхронного взаимодействия через брокер сообщений (например, Kafka, RabbitMQ) по сравнению с синхронным REST-вызовом?',
    options: [
      'Гарантия доставки сообщения в реальном времени',
      'Снижение связанности (coupling) между сервисами и возможность обработки пиковых нагрузок',
      'Более простая отладка и трассировка запросов',
      'Автоматическая типизация данных без необходимости в схемах',
    ],
    correctIndex: 1,
    explanation:
      'Асинхронное взаимодействие через брокер сообщений обеспечивает слабую связанность (loose coupling): отправитель не знает о получателе и не ждёт его ответа. Это даёт несколько преимуществ: (1) Temporal decoupling — сервис-получатель может быть временно недоступен, сообщение сохранится в очереди. (2) Сглаживание пиковых нагрузок (load leveling) — брокер буферизирует сообщения, получатель обрабатывает их в своём темпе. (3) Масштабируемость — можно добавлять потребителей для параллельной обработки. (4) Возможность fan-out — одно сообщение могут получить несколько подписчиков. Недостатки: усложнение отладки, eventual consistency, необходимость обработки дублей (идемпотентность) и мониторинга очередей.',
  },
  {
    id: 'sa-architecture-004',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните SOAP и REST с точки зрения системного аналитика. В каких сценариях вы бы рекомендовали использование SOAP, а в каких — REST?',
    sampleAnswer:
      'REST предпочтителен для публичных API, мобильных приложений, микросервисных архитектур — везде, где важна простота, скорость разработки и гибкость формата данных (JSON). REST легче документировать (OpenAPI/Swagger), тестировать и кэшировать. SOAP рекомендуется для корпоративных интеграций, где критичны: (1) формальный контракт (WSDL + XSD обеспечивает строгую типизацию и автогенерацию кода); (2) встроенные стандарты безопасности (WS-Security для шифрования и подписи на уровне сообщения); (3) надёжная доставка (WS-ReliableMessaging); (4) транзакционность (WS-AtomicTransaction); (5) работа поверх разных транспортов (не только HTTP, но и JMS, SMTP). Типичные SOAP-сценарии: банковские системы, государственные сервисы, ERP-интеграции. При выборе аналитик должен учитывать требования к безопасности, существующий ландшафт (legacy-системы часто поддерживают только SOAP), компетенции команды и нефункциональные требования.',
    explanation:
      'Ключевые критерии выбора: (1) Строгость контракта — SOAP через WSDL/XSD, REST через OpenAPI (менее строго). (2) Безопасность — SOAP имеет WS-Security на уровне сообщения, REST полагается на HTTPS и OAuth. (3) Транспорт — REST привязан к HTTP, SOAP транспортно-независим. (4) Производительность — REST с JSON компактнее XML-конвертов SOAP. (5) Экосистема — REST доминирует в современных архитектурах, SOAP — в enterprise-legacy.',
  },
  {
    id: 'sa-architecture-005',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы проектируете систему, в которой микросервис заказов должен взаимодействовать с микросервисом оплаты и микросервисом склада. Опишите подходы к оркестрации и хореографии, их плюсы и минусы, и предложите паттерн обеспечения консистентности данных.',
    sampleAnswer:
      'Оркестрация: выделяется центральный сервис-оркестратор (например, сервис заказов), который последовательно вызывает сервис оплаты и сервис склада, управляя всей логикой процесса. Плюсы: логика процесса сосредоточена в одном месте, легче понимать и отлаживать. Минусы: оркестратор становится единой точкой отказа и бутылочным горлышком, сильная связанность. Хореография: каждый сервис реагирует на события других сервисов через брокер сообщений. Сервис заказов публикует событие «Заказ создан», сервис оплаты подписан на него и после обработки публикует «Оплата выполнена», сервис склада реагирует резервированием товара. Плюсы: слабая связанность, лучшая масштабируемость. Минусы: бизнес-логика распределена, сложнее отслеживать полный процесс, риск «зацикливания» событий. Для обеспечения консистентности рекомендуется паттерн Saga: каждый шаг имеет компенсирующее действие. Если оплата прошла, но резервирование на складе не удалось — выполняется возврат средств (компенсация). Saga может быть реализована как в стиле оркестрации (Saga-координатор), так и хореографии (через события). Дополнительно необходимы: идемпотентность обработчиков, Outbox-паттерн для надёжной публикации событий, корреляционные идентификаторы для трассировки.',
    explanation:
      'Оркестрация vs хореография — фундаментальный выбор в микросервисной архитектуре. Оркестрация проще для линейных процессов с небольшим количеством участников. Хореография масштабируется лучше, но требует зрелой инфраструктуры (distributed tracing, мониторинг событий). Паттерн Saga заменяет распределённые ACID-транзакции, обеспечивая eventual consistency. Аналитик должен документировать как «счастливый путь», так и все компенсирующие действия для каждого шага процесса.',
  },
  {
    id: 'sa-architecture-006',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн интеграции обеспечивает надёжную публикацию события в брокер сообщений вместе с сохранением данных в БД в рамках одной логической транзакции?',
    options: [
      'Circuit Breaker',
      'Transactional Outbox',
      'API Gateway',
      'Service Mesh',
    ],
    correctIndex: 1,
    explanation:
      'Паттерн Transactional Outbox решает проблему dual write: когда сервису нужно одновременно обновить свою БД и отправить сообщение в брокер, но эти два действия не могут быть объединены в одну ACID-транзакцию. Решение: событие записывается в специальную таблицу outbox в той же БД в рамках той же транзакции, что и бизнес-данные. Отдельный процесс (relay/poller или CDC — Change Data Capture, например, Debezium) читает записи из outbox и публикует их в брокер. Это гарантирует, что событие будет отправлено тогда и только тогда, когда бизнес-данные успешно сохранены. Circuit Breaker предотвращает каскадные отказы. API Gateway — единая точка входа. Service Mesh — инфраструктурный слой для межсервисного взаимодействия.',
  },
  {
    id: 'sa-architecture-007',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой HTTP-метод в REST API является идемпотентным и используется для полной замены ресурса?',
    options: [
      'POST',
      'PATCH',
      'PUT',
      'DELETE',
    ],
    correctIndex: 2,
    explanation:
      'PUT — идемпотентный HTTP-метод, который заменяет ресурс целиком. Повторный вызов PUT с теми же данными даёт тот же результат (идемпотентность). POST не является идемпотентным — каждый вызов может создавать новый ресурс. PATCH — частичное обновление, формально не обязан быть идемпотентным (хотя на практике часто реализуется таким образом). DELETE также идемпотентен — повторное удаление уже удалённого ресурса не меняет состояние системы. Понимание идемпотентности критично для проектирования устойчивых API: при сетевых сбоях клиент может безопасно повторять идемпотентные запросы без риска дублирования данных.',
  },
  {
    id: 'sa-architecture-008',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое API Gateway в микросервисной архитектуре?',
    options: [
      'База данных, общая для всех микросервисов',
      'Единая точка входа для клиентских запросов, выполняющая маршрутизацию, аутентификацию и агрегацию',
      'Сервис, отвечающий за развёртывание микросервисов в продакшн',
      'Инструмент для автоматического тестирования API',
    ],
    correctIndex: 1,
    explanation:
      'API Gateway — паттерн микросервисной архитектуры, представляющий единую точку входа для всех клиентских запросов. Основные функции: маршрутизация запросов к соответствующим микросервисам, аутентификация и авторизация, rate limiting (ограничение частоты запросов), агрегация ответов от нескольких сервисов, кэширование, трансформация протоколов (например, REST для внешних клиентов, gRPC для внутреннего взаимодействия), логирование и мониторинг. Популярные реализации: Kong, NGINX, AWS API Gateway, Spring Cloud Gateway. API Gateway скрывает внутреннюю структуру микросервисов от клиентов и упрощает работу фронтенд-разработчиков.',
  },
  {
    id: 'sa-architecture-009',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Webhook?',
    options: [
      'Специальный тип базы данных для хранения событий',
      'HTTP-обратный вызов: сервер отправляет HTTP-запрос на заранее указанный URL при наступлении события',
      'Протокол двусторонней связи поверх TCP (аналог WebSocket)',
      'Метод шифрования данных в REST API',
    ],
    correctIndex: 1,
    explanation:
      'Webhook — это механизм обратного вызова (callback) через HTTP. Вместо того чтобы клиент периодически опрашивал сервер на наличие новых данных (polling), сервер сам отправляет HTTP POST-запрос на заранее зарегистрированный URL клиента при наступлении определённого события. Например, платёжный шлюз отправляет webhook в интернет-магазин при успешной оплате. Преимущества: реальное время получения уведомлений, экономия ресурсов (нет лишних запросов). Важные аспекты проектирования: верификация подписи (HMAC), идемпотентность обработки (webhook может быть доставлен повторно), обработка ошибок и retry-политика, таймауты.',
  },
  {
    id: 'sa-architecture-010',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой интеграционный подход предполагает централизованную шину, через которую проходят все сообщения между системами?',
    options: [
      'Точка-точка (Point-to-Point)',
      'Enterprise Service Bus (ESB)',
      'Shared Database',
      'File Transfer',
    ],
    correctIndex: 1,
    explanation:
      'Enterprise Service Bus (ESB) — интеграционный паттерн, в котором все системы подключаются к централизованной шине сообщений. ESB берёт на себя маршрутизацию, трансформацию форматов данных, оркестрацию и мониторинг. Преимущества: снижение количества прямых связей между системами (вместо N*(N-1)/2 связей — N подключений к шине), централизованное управление интеграциями. Недостатки: единая точка отказа, сложность поддержки, риск превращения в «монолитный интеграционный слой». В современных архитектурах ESB часто заменяют более легковесными решениями — API Gateway, брокеры сообщений (Kafka, RabbitMQ) или Service Mesh.',
  },
  {
    id: 'sa-architecture-011',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните разницу между ETL и ELT. Когда применяется каждый подход?',
    sampleAnswer:
      'ETL (Extract, Transform, Load) — классический подход к интеграции данных: данные извлекаются из источников (Extract), трансформируются в промежуточном слое (Transform) — очищаются, агрегируются, приводятся к целевой схеме — и затем загружаются в хранилище (Load). Трансформация происходит ДО загрузки, обычно на выделенном ETL-сервере. Подходит, когда целевое хранилище имеет ограниченные вычислительные ресурсы (традиционные DWH), нужна сложная бизнес-логика трансформации. ELT (Extract, Load, Transform) — данные извлекаются и загружаются в целевое хранилище «как есть» (в сыром виде), а трансформация выполняется уже внутри хранилища средствами его движка. Подходит для облачных хранилищ с эластичными вычислительными ресурсами (BigQuery, Snowflake, ClickHouse), когда нужно хранить исторические сырые данные и применять разные трансформации по мере необходимости (schema-on-read). ELT стал доминирующим подходом в современных data-платформах благодаря масштабируемости облачных хранилищ.',
    explanation:
      'Ключевое различие — где происходит трансформация: вне хранилища (ETL) или внутри него (ELT). ETL — зрелый подход с развитой экосистемой инструментов (Informatica, Talend, SSIS). ELT лучше использует ресурсы облачных хранилищ (dbt, Dataform). Аналитик должен учитывать объёмы данных, требования к латентности, доступные инструменты и навыки команды.',
  },
  {
    id: 'sa-architecture-012',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем SOA (сервис-ориентированная архитектура) принципиально отличается от микросервисной архитектуры?',
    options: [
      'SOA не использует сетевое взаимодействие между сервисами',
      'В микросервисах каждый сервис имеет собственное хранилище данных, а в SOA сервисы часто разделяют общую БД',
      'SOA поддерживает только синхронное взаимодействие, микросервисы — только асинхронное',
      'Микросервисы не могут использовать брокеры сообщений',
    ],
    correctIndex: 1,
    explanation:
      'Хотя SOA и микросервисы разделяют идею декомпозиции на сервисы, ключевые различия: (1) Размер сервисов — SOA-сервисы обычно крупнее и охватывают целый бизнес-домен, микросервисы более гранулярные. (2) Данные — в микросервисной архитектуре строго соблюдается принцип «database per service», каждый сервис владеет своими данными; в SOA сервисы часто разделяют общую БД. (3) Интеграция — SOA часто использует ESB для оркестрации и тяжёлые стандарты (WS-*, SOAP); микросервисы предпочитают лёгкие протоколы (REST, gRPC) и «умные эндпоинты, глупые каналы». (4) Развёртывание — микросервисы разворачиваются независимо, SOA-сервисы могут иметь связанные циклы релизов. (5) Управление — SOA предполагает централизованное управление (governance), микросервисы — децентрализованное.',
  },
  {
    id: 'sa-architecture-013',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн интеграции предполагает, что сервисы реагируют на события, публикуемые другими сервисами, без прямых вызовов между ними?',
    options: [
      'Request-Reply',
      'Shared Database',
      'Event-Driven (Publish-Subscribe)',
      'Remote Procedure Call (RPC)',
    ],
    correctIndex: 2,
    explanation:
      'Event-Driven интеграция по модели Publish-Subscribe предполагает, что сервис-продюсер публикует событие (например, «Заказ создан») в брокер сообщений, не зная, кто его обработает. Сервисы-подписчики получают событие и реагируют на него: сервис уведомлений отправляет email, сервис аналитики обновляет статистику, сервис склада резервирует товар. Преимущества: минимальная связанность (продюсер не зависит от потребителей), лёгкость добавления новых подписчиков без изменения продюсера. Недостатки: eventual consistency, сложность отладки и трассировки, необходимость мониторинга очередей. Request-Reply — синхронный вызов с ожиданием ответа. RPC — удалённый вызов процедуры. Shared Database — интеграция через общую БД.',
  },
  {
    id: 'sa-architecture-014',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое ADR (Architecture Decision Record) и зачем он нужен? Какие ключевые разделы должен содержать ADR?',
    sampleAnswer:
      'ADR (Architecture Decision Record) — документ, фиксирующий значимое архитектурное решение: что было решено, почему и какие альтернативы рассматривались. ADR создаёт «институциональную память» проекта: через год новый член команды сможет понять, почему была выбрана PostgreSQL, а не MongoDB, или почему коммуникация между сервисами идёт через Kafka, а не REST. Ключевые разделы ADR: (1) Title — краткое описание решения. (2) Status — предложено / принято / отклонено / заменено. (3) Context — контекст и проблема, которую нужно решить. (4) Decision — само решение. (5) Consequences — последствия (плюсы и минусы), компромиссы. (6) Alternatives Considered — рассмотренные альтернативы с обоснованием отказа. ADR обычно хранятся в репозитории проекта (docs/adr/) и нумеруются последовательно. Популярные шаблоны: Michael Nygard, MADR.',
    explanation:
      'ADR решает проблему «утерянного контекста»: без документирования причин архитектурных решений команда рискует повторно обсуждать одни и те же вопросы или отменять обоснованные решения. ADR не заменяет архитектурную документацию, а дополняет её, фокусируясь на «почему», а не «как». Аналитик часто выступает инициатором и автором ADR, особенно для решений, затрагивающих интеграции и модель данных.',
  },
  {
    id: 'sa-architecture-015',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой фреймворк корпоративной архитектуры включает ADM (Architecture Development Method) как центральный процесс разработки архитектуры?',
    options: [
      'Zachman Framework',
      'TOGAF',
      'FEAF',
      'DoDAF',
    ],
    correctIndex: 1,
    explanation:
      'TOGAF (The Open Group Architecture Framework) — один из наиболее широко используемых фреймворков корпоративной архитектуры. Его центральный компонент — ADM (Architecture Development Method) — итеративный процесс из нескольких фаз: предварительная подготовка, определение видения архитектуры, бизнес-архитектура, архитектура информационных систем, технологическая архитектура, возможности и решения, планирование миграции, управление реализацией, управление изменениями. TOGAF также включает континуум предприятия (Enterprise Continuum), репозиторий архитектуры и набор эталонных моделей. Zachman Framework — классификационная схема (матрица) артефактов архитектуры. FEAF — федеральный фреймворк (США). DoDAF — фреймворк министерства обороны США.',
  },
  {
    id: 'sa-architecture-016',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн помогает предотвратить каскадные отказы в распределённой системе, прекращая вызовы к неработающему сервису на определённое время?',
    options: [
      'Retry Pattern',
      'Bulkhead Pattern',
      'Circuit Breaker',
      'Sidecar Pattern',
    ],
    correctIndex: 2,
    explanation:
      'Circuit Breaker (автоматический выключатель) — паттерн устойчивости, предотвращающий каскадные отказы. Работает по аналогии с электрическим автоматом: (1) Closed — запросы проходят нормально, сбои подсчитываются. (2) Open — при достижении порога сбоев цепь «размыкается»: запросы к проблемному сервису немедленно отклоняются без фактического вызова (fail fast), возвращается fallback-ответ. (3) Half-Open — через настраиваемый интервал пропускается пробный запрос; если успешен — цепь замыкается, если нет — остаётся открытой. Retry Pattern — повторные попытки (может усугубить проблему без Circuit Breaker). Bulkhead — изоляция ресурсов (пулы потоков, connection pools) для предотвращения распространения сбоя. Sidecar — вспомогательный контейнер рядом с основным сервисом.',
  },
  {
    id: 'sa-architecture-017',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните SOAP и REST с технической точки зрения: протоколы, форматы данных, описание контракта, безопасность, надёжность. В каком случае SOAP до сих пор является предпочтительным выбором?',
    sampleAnswer:
      'Техническое сравнение: (1) Протокол: SOAP — полноценный протокол со строгой спецификацией конверта (Envelope, Header, Body, Fault); REST — архитектурный стиль поверх HTTP, использующий стандартные HTTP-методы и статус-коды. (2) Формат данных: SOAP — исключительно XML; REST — JSON (основной), XML, YAML, бинарные форматы. (3) Контракт: SOAP — WSDL + XSD (строго типизированный, позволяет автогенерацию кода); REST — OpenAPI/Swagger (менее строгий, описывается постфактум). (4) Безопасность: SOAP — WS-Security (шифрование и подпись на уровне сообщения, работает через любого посредника); REST — HTTPS + OAuth 2.0 (безопасность на уровне транспорта). (5) Надёжность: SOAP — WS-ReliableMessaging (гарантированная доставка, порядок сообщений); REST — нет встроенного механизма, реализуется на уровне приложения. (6) Транзакции: SOAP — WS-AtomicTransaction; REST — нет стандарта. SOAP предпочтителен: банковские и финансовые системы, государственные сервисы (СМЭВ), интеграция с legacy-системами, когда требуется подпись на уровне сообщения или гарантированная доставка.',
    explanation:
      'SOAP остаётся актуальным в enterprise-среде, где критичны формальные контракты, безопасность на уровне сообщения и интеграция с legacy. REST доминирует в публичных API, мобильных приложениях и микросервисах. Аналитик должен понимать оба подхода и рекомендовать выбор на основе конкретных требований, а не моды.',
  },
  {
    id: 'sa-architecture-018',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн Event Sourcing. Какие преимущества и сложности он несёт? В каких системах его целесообразно применять?',
    sampleAnswer:
      'Event Sourcing — архитектурный паттерн, при котором состояние системы определяется не текущим снимком данных, а последовательностью событий (event log). Каждое изменение состояния записывается как неизменяемое событие: «Товар добавлен в корзину», «Цена изменена», «Заказ отменён». Текущее состояние восстанавливается путём воспроизведения (replay) всех событий. Преимущества: (1) Полный аудит — каждое изменение зафиксировано с причиной, автором и временем. (2) Возможность восстановить состояние на любой момент в прошлом (temporal queries). (3) Возможность построить новые проекции данных (read models), воспроизведя события. (4) Естественная интеграция с CQRS и event-driven архитектурой. Сложности: (1) Эволюция схемы событий (event versioning) — нельзя изменить структуру опубликованного события. (2) Сложность запросов — для чтения нужны проекции (materialized views). (3) Увеличение объёма хранимых данных. (4) Снэпшоты (snapshots) нужны для оптимизации восстановления при большом количестве событий. Применение: финансовые системы (банковские транзакции), системы бронирования, аудируемые системы (здравоохранение), корзины покупок.',
    explanation:
      'Event Sourcing часто сочетается с CQRS (Command Query Responsibility Segregation): команды записывают события, а запросы работают с оптимизированными проекциями. Это мощный, но сложный паттерн — не стоит применять его повсеместно. Аналитик должен оценить, оправданы ли преимущества полного аудита и временных запросов для данного домена.',
  },
  {
    id: 'sa-architecture-019',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход к интеграции данных предполагает загрузку сырых данных в хранилище с последующей трансформацией внутри хранилища?',
    options: [
      'ETL (Extract, Transform, Load)',
      'ELT (Extract, Load, Transform)',
      'CDC (Change Data Capture)',
      'ESB (Enterprise Service Bus)',
    ],
    correctIndex: 1,
    explanation:
      'ELT (Extract, Load, Transform) — подход, при котором данные извлекаются из источников, загружаются в целевое хранилище «как есть» (сырыми), а трансформация выполняется уже внутри хранилища средствами его SQL-движка. Это стало возможным благодаря облачным хранилищам с эластичными вычислительными ресурсами (BigQuery, Snowflake, Databricks). Преимущества: хранение исходных данных, возможность перетрансформировать при изменении бизнес-логики, использование мощности хранилища. ETL — классический подход, где трансформация происходит до загрузки. CDC — механизм отслеживания изменений в базе-источнике (не сам подход к загрузке). ESB — шина интеграции для взаимодействия между системами.',
  },
  {
    id: 'sa-architecture-020',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн микросервисной архитектуры предполагает, что каждый микросервис владеет собственной базой данных и не имеет прямого доступа к данным других сервисов?',
    options: [
      'Shared Database',
      'Database per Service',
      'CQRS',
      'Strangler Fig',
    ],
    correctIndex: 1,
    explanation:
      'Database per Service — ключевой паттерн микросервисной архитектуры, согласно которому каждый микросервис имеет собственное хранилище данных, инкапсулирует доступ к нему и предоставляет данные другим сервисам только через свой API. Преимущества: независимость развёртывания и масштабирования, свобода выбора технологии хранения (polyglot persistence), отсутствие блокировок на уровне БД между сервисами. Недостатки: сложность реализации запросов, затрагивающих данные нескольких сервисов (нужны API Composition, CQRS или Saga), дублирование данных. Shared Database — антипаттерн для микросервисов, хотя допустим в SOA. CQRS — разделение моделей чтения и записи. Strangler Fig — паттерн постепенной миграции с монолита.',
  },
  {
    id: 'sa-architecture-021',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Service Mesh в контексте микросервисной архитектуры?',
    options: [
      'База данных для хранения конфигурации сервисов',
      'Инфраструктурный слой для управления межсервисным взаимодействием (маршрутизация, балансировка, безопасность, observability)',
      'Инструмент для автоматического тестирования API',
      'Протокол обмена сообщениями между сервисами',
    ],
    correctIndex: 1,
    explanation:
      'Service Mesh — выделенный инфраструктурный слой для управления взаимодействием между микросервисами. Реализуется через sidecar-прокси (Envoy), развёрнутые рядом с каждым сервисом. Функции: автоматическая mTLS-аутентификация, балансировка нагрузки, circuit breaker, retry, timeout, трассировка запросов, сбор метрик, canary-deployments, A/B-тестирование на уровне трафика. Популярные реализации: Istio, Linkerd, Consul Connect. Service Mesh выносит cross-cutting concerns из кода сервисов в инфраструктуру, упрощая разработку.',
  },
  {
    id: 'sa-architecture-022',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код ответа означает, что запрос успешно принят для асинхронной обработки, но ещё не завершён?',
    options: [
      '200 OK',
      '201 Created',
      '202 Accepted',
      '204 No Content',
    ],
    correctIndex: 2,
    explanation:
      '202 Accepted означает, что запрос принят для обработки, но обработка ещё не завершена. Используется для асинхронных операций: клиент отправляет запрос, сервер подтверждает получение и обрабатывает в фоне. Обычно в ответе возвращается ссылка на ресурс для проверки статуса (Location header или JSON с URL). 200 OK — успешное завершение. 201 Created — ресурс создан синхронно. 204 No Content — успешное выполнение без возвращаемого тела.',
  },
  {
    id: 'sa-architecture-023',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Backend for Frontend (BFF) паттерн?',
    options: [
      'Единый универсальный API для всех клиентов',
      'Отдельный backend-сервис для каждого типа клиента (web, mobile, IoT), адаптирующий API под его потребности',
      'Кэширующий слой между клиентом и сервером',
      'Фреймворк для разработки пользовательского интерфейса',
    ],
    correctIndex: 1,
    explanation:
      'Backend for Frontend (BFF) — паттерн, при котором для каждого типа клиента создаётся отдельный backend-сервис, оптимизированный под его нужды. Мобильное приложение может требовать компактные ответы и агрегацию данных, веб-приложение — более детальные данные, IoT-устройство — минимальный протокол. BFF агрегирует вызовы к внутренним микросервисам, трансформирует данные, может кэшировать. Преимущества: оптимизация под каждый клиент, изоляция изменений, независимое развитие. Недостатки: дублирование логики между BFF, больше сервисов для поддержки.',
  },
  {
    id: 'sa-architecture-024',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните разницу между синхронным и асинхронным взаимодействием между сервисами. Приведите примеры использования каждого подхода.',
    sampleAnswer:
      'Синхронное взаимодействие: вызывающий сервис отправляет запрос и ожидает ответа (блокируется до получения). Протоколы: REST/HTTP, gRPC. Преимущества: простота реализации и отладки, немедленный результат. Недостатки: временная связанность (сервис-получатель должен быть доступен), каскадные отказы, увеличение latency при цепочке вызовов. Примеры: валидация данных в реальном времени, получение информации о пользователе, проверка наличия товара. Асинхронное взаимодействие: отправитель публикует сообщение и продолжает работу, не ожидая ответа. Протоколы: AMQP, Kafka, очереди сообщений. Преимущества: temporal decoupling (получатель может обработать позже), сглаживание пиковых нагрузок, лучшая отказоустойчивость. Недостатки: eventual consistency, сложность отладки и трассировки, необходимость идемпотентности. Примеры: отправка уведомлений, обработка заказов, синхронизация данных между системами, аналитические события.',
    explanation:
      'Выбор между синхронным и асинхронным взаимодействием — одно из ключевых архитектурных решений. Правило: если нужен немедленный ответ и операция быстрая — синхронно; если можно обработать позже или операция долгая — асинхронно. Гибридный подход: синхронный ответ «принято», асинхронная обработка, webhook или polling для результата.',
  },
  {
    id: 'sa-architecture-025',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Strangler Fig паттерн в контексте миграции с монолита?',
    options: [
      'Одномоментная замена всего монолита на микросервисы',
      'Постепенная замена частей монолита новыми сервисами, направляя трафик через фасад',
      'Паттерн обработки ошибок в распределённых системах',
      'Метод декомпозиции базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Strangler Fig (Мартин Фаулер, по аналогии с фикусом-душителем) — паттерн постепенной миграции с монолита на микросервисы. Суть: перед монолитом размещается фасад (API Gateway, reverse proxy); новые функции реализуются в отдельных сервисах; трафик постепенно перенаправляется от монолита к новым сервисам; монолит «усыхает» по мере миграции функционала, пока не будет полностью заменён. Преимущества: низкий риск (можно откатить), постепенное обучение команды, бизнес-ценность доставляется непрерывно. Ключевой элемент — façade/routing layer, определяющий, какие запросы идут в монолит, а какие — в новые сервисы.',
  },
  {
    id: 'sa-architecture-026',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой принцип API-first подхода к проектированию?',
    options: [
      'Сначала пишется код, затем генерируется документация API',
      'Сначала проектируется и согласовывается спецификация API, затем реализуется код',
      'API создаётся только для внутренних нужд, без документации',
      'Один API для всех клиентов без версионирования',
    ],
    correctIndex: 1,
    explanation:
      'API-first (Contract-first) — подход, при котором спецификация API (OpenAPI, AsyncAPI, GraphQL Schema) создаётся и согласовывается до написания кода. Преимущества: параллельная разработка (frontend-команда работает по спецификации, backend реализует); согласованность контракта между командами; автоматическая генерация клиентского кода, серверных заглушек, документации, тестов; раннее выявление проблем дизайна API. Противоположность — code-first: API генерируется из кода (аннотации, атрибуты). API-first особенно важен в микросервисной архитектуре и при работе с внешними партнёрами.',
  },
  {
    id: 'sa-architecture-027',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое антипаттерн «Distributed Monolith»?',
    options: [
      'Монолит, развёрнутый в нескольких дата-центрах',
      'Система из множества сервисов с сильной связанностью, требующих синхронного развёртывания и изменений',
      'Монолитная база данных для распределённой системы',
      'Использование нескольких языков программирования в одном проекте',
    ],
    correctIndex: 1,
    explanation:
      'Distributed Monolith — антипаттерн, когда система формально разбита на микросервисы, но сохраняет недостатки монолита: сервисы сильно связаны (shared database, синхронные вызовы), изменение одного сервиса требует изменений в других, развёртывание требует координации всех команд, нельзя масштабировать независимо. Это худший из миров: сложность распределённой системы без преимуществ микросервисов. Причины: неправильное определение границ сервисов, отсутствие database-per-service, избыточные синхронные зависимости. Решение: правильная декомпозиция по бизнес-доменам, асинхронное взаимодействие, чёткие контракты.',
  },
  {
    id: 'sa-architecture-028',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Опишите подходы к версионированию REST API. Какие преимущества и недостатки у каждого?',
    sampleAnswer:
      'Основные подходы к версионированию REST API: (1) В URL-пути: /api/v1/users, /api/v2/users. Преимущества: явность, простота маршрутизации, кэшируемость. Недостатки: не REST-pure (версия не является частью ресурса), требует изменения URL при апгрейде. Наиболее популярный подход. (2) Через Query Parameter: /api/users?version=2. Преимущества: URL ресурса не меняется. Недостатки: легко пропустить, может влиять на кэширование. (3) Через HTTP-заголовок: Accept: application/vnd.company.api+json; version=2 или X-API-Version: 2. Преимущества: чистые URL, гибкость, соответствует REST (content negotiation). Недостатки: неявность, сложнее тестировать в браузере. (4) В Content-Type (media type versioning): Accept: application/vnd.company.users.v2+json. Преимущества: семантически корректно, гибко. Недостатки: сложность реализации. Рекомендации: использовать версионирование в URL для простоты; менять мажорную версию только при breaking changes; поддерживать минимум 2 версии одновременно; документировать политику deprecation.',
    explanation:
      'Версионирование — неизбежность для долгоживущих API. Главный принцип: обратная совместимость внутри версии (добавление полей — ok, удаление — breaking change). Semantic Versioning (SemVer) в URL обычно использует только мажорную версию (v1, v2). Стратегия deprecation: объявление → период предупреждений → отключение.',
  },
  {
    id: 'sa-architecture-029',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн интеграции используется для получения данных из нескольких микросервисов и сборки единого ответа для клиента?',
    options: [
      'Saga Pattern',
      'API Composition / Aggregator Pattern',
      'Event Sourcing',
      'Circuit Breaker',
    ],
    correctIndex: 1,
    explanation:
      'API Composition (Aggregator Pattern) — паттерн, при котором один сервис (композитор/агрегатор) получает данные из нескольких микросервисов и собирает единый ответ для клиента. Например, страница профиля пользователя требует данных из User Service, Order Service и Recommendation Service. Агрегатор вызывает все три сервиса (параллельно или последовательно), объединяет данные и возвращает клиенту. Реализуется в API Gateway или отдельном сервисе. Saga Pattern — распределённые транзакции. Event Sourcing — хранение событий. Circuit Breaker — защита от каскадных отказов.',
  },
  {
    id: 'sa-architecture-030',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое CQRS (Command Query Responsibility Segregation)?',
    options: [
      'Паттерн обработки ошибок в распределённых системах',
      'Разделение модели данных на отдельные модели для операций записи (команд) и чтения (запросов)',
      'Механизм кэширования запросов к базе данных',
      'Протокол синхронизации данных между микросервисами',
    ],
    correctIndex: 1,
    explanation:
      'CQRS (Command Query Responsibility Segregation) — паттерн, разделяющий модель данных на две: Command Model (для записи) и Query Model (для чтения). Команды изменяют состояние, запросы только читают и не изменяют. Преимущества: оптимизация каждой модели под свою задачу (нормализованная для записи, денормализованная для чтения), независимое масштабирование чтения и записи, упрощение сложных запросов. Часто сочетается с Event Sourcing: события записываются в event store, а query model строится как проекция событий. Применяется в системах с высокой нагрузкой на чтение или сложными запросами.',
  },
  {
    id: 'sa-architecture-031',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн Enterprise Integration Patterns используется для гарантии обработки сообщения ровно одним из нескольких конкурирующих потребителей?',
    options: [
      'Publish-Subscribe Channel',
      'Competing Consumers',
      'Message Router',
      'Content-Based Router',
    ],
    correctIndex: 1,
    explanation:
      'Competing Consumers — паттерн, при котором несколько экземпляров потребителя (consumer) слушают одну очередь. Каждое сообщение обрабатывается ровно одним потребителем, что обеспечивает распределение нагрузки и масштабирование обработки. Брокер сообщений (RabbitMQ, SQS) гарантирует, что сообщение доставляется одному потребителю. Publish-Subscribe — каждое сообщение получают все подписчики. Message Router — маршрутизация на основе правил. Content-Based Router — маршрутизация на основе содержимого сообщения.',
  },
  {
    id: 'sa-architecture-032',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Architecture Governance в контексте корпоративной архитектуры?',
    options: [
      'Автоматическое тестирование архитектурных решений',
      'Процессы и механизмы контроля соответствия реализуемых решений архитектурным принципам и стандартам организации',
      'Инструмент для визуализации архитектуры',
      'Методология декомпозиции монолита',
    ],
    correctIndex: 1,
    explanation:
      'Architecture Governance — совокупность процессов, организационных структур и инструментов для обеспечения соответствия проектных решений архитектурным принципам, стандартам и целям организации. Включает: Architecture Review Board (комитет по архитектурным решениям), процедуры согласования архитектурных решений, контроль соблюдения стандартов, исключения и вейверы, метрики соответствия. Governance предотвращает архитектурную эрозию, обеспечивает переиспользование решений и согласованность landscape. В TOGAF Architecture Governance — одна из ключевых практик.',
  },
  {
    id: 'sa-architecture-033',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите антипаттерны интеграции в корпоративных системах и способы их избежать.',
    sampleAnswer:
      'Ключевые антипаттерны интеграции: (1) Spaghetti Integration — хаотичные point-to-point интеграции без единой стратегии. N систем → N*(N-1)/2 интеграций. Решение: централизованная интеграционная платформа (Integration Platform), API Gateway, чёткие стандарты. (2) Golden Hammer — использование одного подхода для всех интеграций (только ESB, только REST). Решение: выбор подхода по требованиям (синхронный/асинхронный, real-time/batch, volume). (3) Leaky Abstraction — интеграционный слой пропускает детали внутренней реализации системы. Решение: чёткие контракты, адаптеры для трансформации. (4) Chatty Integration — множество мелких вызовов вместо одного агрегированного. Решение: API Composition, Batch API, GraphQL. (5) Shared Database Integration — интеграция через прямой доступ к БД другой системы. Решение: API, CDC (Change Data Capture) для событий. (6) Big Ball of Mud ESB — вся логика в тяжёлом ESB, который становится монолитом. Решение: тонкий интеграционный слой, логика в сервисах, smart endpoints / dumb pipes. (7) Synchronous Overload — избыточные синхронные вызовы, каскадные зависимости. Решение: асинхронность где возможно, circuit breaker, timeouts.',
    explanation:
      'Интеграционные антипаттерны — одна из главных причин технического долга в enterprise-системах. Ключевые принципы: стандартизация, loose coupling, единый каталог интеграций, мониторинг и observability интеграционного слоя. Аналитик должен выявлять антипаттерны на ранних стадиях и предлагать альтернативные решения.',
  },
  {
    id: 'sa-architecture-034',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить идемпотентность операций в REST API и при обработке сообщений? Почему это важно?',
    sampleAnswer:
      'Идемпотентность — свойство операции, при котором повторное выполнение даёт тот же результат, что и однократное. Важность: при сетевых сбоях клиент не знает, выполнена ли операция; повторный запрос безопасен только для идемпотентных операций. HTTP-методы: GET, PUT, DELETE — идемпотентны по спецификации; POST — не идемпотентен. Подходы обеспечения идемпотентности: (1) Idempotency Key — клиент генерирует уникальный ключ (UUID) и передаёт в заголовке (Idempotency-Key). Сервер сохраняет ключ и результат; при повторном запросе с тем же ключом возвращает сохранённый результат. (2) Conditional Requests — ETag/If-Match для PUT/DELETE: обновление только если ресурс не изменился. (3) Естественная идемпотентность — дизайн операций: PUT /orders/123/status с телом {status: "paid"} идемпотентен; POST /orders/123/mark-as-paid — нет (если не добавить логику). (4) Для очередей сообщений — дедупликация по message_id: хранить обработанные ID (в БД или Redis) с TTL; проверять перед обработкой. (5) Идемпотентные бизнес-операции — использовать upsert вместо insert, проверять текущее состояние перед изменением.',
    explanation:
      'Идемпотентность — фундамент надёжных распределённых систем. Без неё клиенту приходится гадать, выполнен ли запрос, что приводит к дублированию операций (двойные списания, двойные заказы). Stripe, AWS и другие лидеры рынка реализуют Idempotency Key как стандарт. Аналитик должен требовать идемпотентности для критичных операций и документировать механизм в спецификации API.',
  },
  {
    id: 'sa-architecture-035',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн позволяет постепенно перенаправлять трафик с legacy-системы на новую, контролируя процент трафика на каждую версию?',
    options: [
      'Blue-Green Deployment',
      'Canary Release',
      'Feature Toggle',
      'Shadow Traffic',
    ],
    correctIndex: 1,
    explanation:
      'Canary Release — паттерн развёртывания, при котором новая версия сначала получает небольшую долю трафика (1-5%), постепенно увеличивающуюся при отсутствии проблем. Позволяет выявить проблемы на малой выборке пользователей до полного rollout. Blue-Green — две идентичные среды (blue и green), мгновенное переключение трафика между ними. Feature Toggle — включение/выключение функционала через конфигурацию. Shadow Traffic (Traffic Mirroring) — дублирование трафика на новую версию без влияния на пользователей (для тестирования). Canary Release — наиболее гибкий подход для миграции с legacy.',
  },
  {
    id: 'sa-architecture-036',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое rate limiting в контексте API?',
    options: [
      'Ограничение размера запроса',
      'Ограничение количества запросов от клиента за единицу времени',
      'Ограничение скорости передачи данных',
      'Ограничение количества одновременных соединений',
    ],
    correctIndex: 1,
    explanation:
      'Rate Limiting — механизм ограничения количества запросов, которые клиент может сделать за определённый период (например, 1000 запросов в минуту). Цели: защита от DDoS и злоупотреблений, обеспечение справедливого распределения ресурсов между клиентами, предотвращение перегрузки backend. Алгоритмы: Token Bucket, Leaky Bucket, Fixed Window, Sliding Window. HTTP-заголовки: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset. При превышении лимита возвращается 429 Too Many Requests. Rate Limiting обычно реализуется в API Gateway.',
  },
  {
    id: 'sa-architecture-037',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой формат данных использует gRPC для сериализации сообщений?',
    options: [
      'JSON',
      'XML',
      'Protocol Buffers (Protobuf)',
      'YAML',
    ],
    correctIndex: 2,
    explanation:
      'gRPC использует Protocol Buffers (Protobuf) — бинарный формат сериализации, разработанный Google. Protobuf компактнее JSON (в 3-10 раз меньше), быстрее парсится, имеет строгую типизацию, поддерживает эволюцию схемы. Сообщения описываются в .proto файлах, из которых генерируется код на целевом языке. gRPC также использует HTTP/2, обеспечивая мультиплексирование, двунаправленный streaming и сжатие заголовков. gRPC оптимален для внутренних высоконагруженных коммуникаций между микросервисами. JSON используется в REST, XML — в SOAP.',
  },
  {
    id: 'sa-architecture-038',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Bulkhead паттерн в контексте отказоустойчивости?',
    options: [
      'Резервное копирование данных',
      'Изоляция ресурсов (пулы потоков, соединений) для предотвращения распространения сбоя между компонентами',
      'Автоматическое масштабирование при нагрузке',
      'Репликация сервисов между дата-центрами',
    ],
    correctIndex: 1,
    explanation:
      'Bulkhead (переборка) — паттерн изоляции, названный по аналогии с водонепроницаемыми отсеками корабля. Ресурсы (пулы потоков, connection pools, очереди) разделяются между компонентами или типами запросов так, чтобы сбой в одном не влиял на другие. Пример: отдельный пул соединений для критичных и некритичных операций; перегрузка аналитических запросов не влияет на обработку платежей. Реализуется через thread pools, semaphores, отдельные инстансы. Часто применяется вместе с Circuit Breaker и Timeout для комплексной отказоустойчивости.',
  },
  {
    id: 'sa-architecture-039',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните GraphQL и REST с точки зрения проектирования API. Когда предпочтительнее использовать каждый подход?',
    sampleAnswer:
      'REST: ресурсо-ориентированный стиль; фиксированные endpoints (/users, /orders); несколько запросов для связанных данных (N+1); overfetching (получение лишних полей) и underfetching (нехватка данных); кэширование через HTTP; широкая поддержка инструментов; простота понимания. GraphQL: единый endpoint (/graphql); клиент запрашивает ровно те поля, которые нужны (query language); связанные данные в одном запросе; строгая типизированная схема; сложнее кэширование (POST-запросы); introspection и developer tools; более крутая кривая обучения. REST предпочтительнее: публичные API для широкой аудитории, простые CRUD-операции, когда важно HTTP-кэширование, при ограниченных ресурсах на обучение команды. GraphQL предпочтительнее: мобильные приложения с ограниченным bandwidth, сложные связанные данные, разнообразные клиенты с разными потребностями (web/mobile/IoT), rapid iteration когда структура данных часто меняется, внутренние API с контролируемыми клиентами.',
    explanation:
      'GraphQL не замена REST, а альтернативный подход с другими компромиссами. На практике часто используют оба: GraphQL для frontend-facing API, REST — для внутренних B2B-интеграций и публичных API. Важно: GraphQL не решает проблем производительности backend автоматически — неоптимальные resolvers могут создать N+1 проблему на сервере.',
  },
  {
    id: 'sa-architecture-040',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Change Data Capture (CDC) и для чего применяется?',
    options: [
      'Резервное копирование базы данных',
      'Механизм отслеживания и захвата изменений в базе данных для их передачи другим системам в реальном времени',
      'Версионирование схемы базы данных',
      'Шифрование данных при передаче',
    ],
    correctIndex: 1,
    explanation:
      'Change Data Capture (CDC) — технология отслеживания изменений в базе данных (INSERT, UPDATE, DELETE) и передачи их в другие системы в реальном времени или near-real-time. Методы: чтение transaction log (Debezium + Kafka Connect), триггеры, timestamp-based polling. Применение: синхронизация данных между системами, построение реплик для аналитики, реализация паттерна Transactional Outbox, создание event stream из legacy-БД, обновление search-индексов (Elasticsearch), инвалидация кэшей. Debezium — популярный open-source инструмент CDC для PostgreSQL, MySQL, MongoDB и др.',
  },
  {
    id: 'sa-architecture-041',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите архитектурные принципы, которые должны соблюдаться при проектировании корпоративной архитектуры. Как они влияют на принятие решений?',
    sampleAnswer:
      'Архитектурные принципы — руководящие правила, направляющие принятие решений. Ключевые принципы: (1) Single Source of Truth — для каждого типа данных определяется одна мастер-система; другие получают данные из неё. (2) Loose Coupling — минимизация зависимостей между системами через стабильные контракты и асинхронное взаимодействие. (3) Reusability — проектирование сервисов и компонентов для повторного использования (API-first, общие библиотеки). (4) Technology Agnosticism — абстракция от конкретных технологий, возможность замены реализации без изменения контрактов. (5) Defense in Depth — многоуровневая безопасность на каждом слое архитектуры. (6) Design for Failure — система должна быть устойчива к сбоям компонентов (circuit breaker, retry, fallback). (7) Observability — возможность понять состояние системы через метрики, логи, трейсы. (8) Automation First — автоматизация развёртывания, тестирования, мониторинга (CI/CD, IaC). Влияние на решения: принципы служат фильтром для оценки альтернатив — решение, нарушающее принцип, требует явного обоснования и документирования исключения (waiver). Architecture Review Board использует принципы как критерии оценки.',
    explanation:
      'Архитектурные принципы — часть Architecture Governance. Они должны быть: измеримыми (можно проверить соответствие), обоснованными (связаны с бизнес-целями), немногочисленными (5-15), согласованными стейкхолдерами. Принципы документируются в Architecture Repository и регулярно пересматриваются.',
  },
  {
    id: 'sa-architecture-042',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое OpenAPI (ранее Swagger)?',
    options: [
      'Открытый стандарт для описания REST API в машиночитаемом формате (YAML/JSON)',
      'Протокол аутентификации для API',
      'Фреймворк для разработки API на Java',
      'База данных для хранения метаданных API',
    ],
    correctIndex: 0,
    explanation:
      'OpenAPI Specification (OAS) — открытый стандарт для описания REST API в машиночитаемом формате (YAML или JSON). Описывает: endpoints, HTTP-методы, параметры, схемы запросов/ответов, аутентификацию, примеры. Преимущества: автогенерация документации (Swagger UI), клиентского и серверного кода, тестов; единый источник истины для API-контракта. OpenAPI Initiative развивает стандарт под эгидой Linux Foundation. Swagger — оригинальное название и набор инструментов (Swagger Editor, Swagger UI, Swagger Codegen). Текущая версия — OpenAPI 3.1.',
  },
  {
    id: 'sa-architecture-043',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн позволяет избежать каскадных вызовов при ожидании ответа от медленного сервиса, возвращая заранее подготовленный ответ?',
    options: [
      'Retry Pattern',
      'Fallback Pattern',
      'Throttling',
      'Load Shedding',
    ],
    correctIndex: 1,
    explanation:
      'Fallback Pattern — предоставление альтернативного ответа, когда основной сервис недоступен или слишком медленен. Варианты: возврат кэшированных данных, дефолтных значений, сокращённого функционала (graceful degradation). Часто используется вместе с Circuit Breaker: при открытом circuit breaker вместо ошибки возвращается fallback. Пример: при недоступности Recommendation Service показывать популярные товары вместо персонализированных. Retry — повторные попытки. Throttling — ограничение частоты запросов. Load Shedding — отбрасывание части запросов при перегрузке.',
  },
  {
    id: 'sa-architecture-044',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое AsyncAPI?',
    options: [
      'Библиотека для асинхронного программирования',
      'Стандарт спецификации для асинхронных API (event-driven, message-driven)',
      'Протокол передачи сообщений',
      'Инструмент для мониторинга очередей',
    ],
    correctIndex: 1,
    explanation:
      'AsyncAPI — открытый стандарт для описания асинхронных/event-driven API, аналогичный OpenAPI для REST. Описывает: каналы (topics, queues), сообщения, их схемы (JSON Schema, Avro), протоколы (Kafka, AMQP, WebSocket, MQTT). Позволяет: документировать event-driven архитектуру, генерировать код и документацию, валидировать сообщения. AsyncAPI — ответ на потребность в стандартизации описания event-driven систем, которые не покрываются OpenAPI. Используется для Kafka-топиков, RabbitMQ-очередей, WebSocket-API.',
  },
  {
    id: 'sa-architecture-045',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой тип архитектуры предполагает разделение приложения на слои (presentation, business logic, data access), каждый из которых может взаимодействовать только с соседним?',
    options: [
      'Микросервисная архитектура',
      'Layered (N-tier) Architecture',
      'Event-Driven Architecture',
      'Hexagonal Architecture',
    ],
    correctIndex: 1,
    explanation:
      'Layered (N-tier, слоистая) Architecture — классический архитектурный стиль с разделением на горизонтальные слои: Presentation (UI), Business Logic (Application), Data Access (Persistence). Каждый слой зависит только от нижележащего. Преимущества: разделение ответственности, тестируемость слоёв, понятность. Недостатки: сложность распределения, все изменения проходят через все слои (shotgun surgery), риск превращения в «Big Ball of Mud». Микросервисы — вертикальная декомпозиция по бизнес-доменам. Hexagonal (Ports and Adapters) — бизнес-логика в центре, адаптеры для внешнего мира.',
  },
  {
    id: 'sa-architecture-046',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Вы проектируете интеграцию между CRM-системой и биллинговой системой. Опишите, какие вопросы вы зададите для определения архитектуры интеграции.',
    sampleAnswer:
      'Ключевые вопросы для проектирования интеграции: (1) Направление потока данных: CRM → Биллинг, Биллинг → CRM, или двунаправленная? Какие сущности синхронизируются (клиенты, контракты, платежи, счета)? (2) Инициатор: кто источник данных (master system) для каждой сущности? (3) Синхронность: нужен ли немедленный ответ (синхронная) или допустима задержка (асинхронная, batch)? (4) Частота и объём: real-time events, near-real-time (минуты), batch (daily/hourly)? Объём данных за период? (5) Требования к консистентности: eventual consistency допустима или нужна strong consistency (распределённые транзакции)? (6) Обработка конфликтов: что делать при расхождении данных? Last-write-wins, manual resolution, merge rules? (7) Форматы и протоколы: REST API, SOAP, файловый обмен, очереди сообщений, CDC? Какие форматы поддерживают системы? (8) Безопасность: аутентификация (API key, OAuth, mTLS), шифрование, PII-данные? (9) Обработка ошибок: retry policy, dead-letter queue, alerting, компенсация? (10) Мониторинг: метрики интеграции, SLA, alerting при сбоях? (11) Историчность: нужно ли хранить историю обменов для аудита? (12) Технические ограничения: rate limits, maintenance windows, доступные коннекторы?',
    explanation:
      'Вопросы позволяют определить: паттерн интеграции (request-reply, publish-subscribe, file transfer, shared database), технологический стек, требования к инфраструктуре. Результат — Integration Design Document с описанием контрактов, потоков данных, обработки ошибок и NFR. Аналитик должен проводить подобный discovery для каждой значимой интеграции.',
  },
  {
    id: 'sa-architecture-047',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код статуса возвращается при успешном создании нового ресурса?',
    options: [
      '200 OK',
      '201 Created',
      '204 No Content',
      '301 Moved Permanently',
    ],
    correctIndex: 1,
    explanation:
      '201 Created — HTTP-статус, указывающий на успешное создание нового ресурса. Обычно возвращается в ответ на POST-запрос. В заголовке Location должен содержаться URI созданного ресурса. Тело ответа обычно содержит созданный ресурс с присвоенным ID. 200 OK — общий успех (для GET, PUT). 204 No Content — успех без тела ответа (для DELETE). 301 — перенаправление.',
  },
  {
    id: 'sa-architecture-048',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Sidecar паттерн в контексте микросервисов?',
    options: [
      'Паттерн хранения данных в отдельном контейнере',
      'Развёртывание вспомогательного контейнера рядом с основным для реализации cross-cutting concerns',
      'Метод балансировки нагрузки',
      'Паттерн обработки ошибок',
    ],
    correctIndex: 1,
    explanation:
      'Sidecar — паттерн, при котором вспомогательный контейнер (sidecar) развёртывается рядом с основным приложением в одном pod\'е (Kubernetes) и берёт на себя cross-cutting concerns: логирование, мониторинг, сетевую безопасность (mTLS), трассировку, конфигурацию. Основное приложение взаимодействует с sidecar через localhost. Преимущества: разделение ответственности, полиглотность (sidecar реализован на любом языке), независимое обновление. Service Mesh (Istio, Linkerd) основан на sidecar-прокси (Envoy) для каждого сервиса.',
  },
  {
    id: 'sa-architecture-049',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите подход к документированию архитектуры информационной системы. Какие артефакты должны быть созданы и как поддерживать их актуальность?',
    sampleAnswer:
      'Архитектурная документация должна быть достаточной (не избыточной) и живой (актуальной). Ключевые артефакты: (1) Architecture Vision — краткое описание целей, принципов, ключевых решений (1-2 страницы). (2) Context Diagram (C4 Level 1) — система и её окружение (пользователи, внешние системы). (3) Container Diagram (C4 Level 2) — основные компоненты системы (сервисы, БД, очереди), их взаимодействие. (4) ADR (Architecture Decision Records) — документирование значимых решений с контекстом, альтернативами и последствиями. (5) Sequence Diagrams — для ключевых сценариев интеграции. (6) Data Model — ER-диаграмма или описание основных сущностей. (7) API Specifications — OpenAPI/AsyncAPI как исполняемая документация. (8) NFR Document — нефункциональные требования и их реализация. Поддержание актуальности: docs-as-code (документация в Git рядом с кодом), автогенерация диаграмм из кода (PlantUML, Structurizr), автогенерация API-документации, ревью документации при архитектурных изменениях, Definition of Done включает обновление документации, периодический audit (например, ежеквартально).',
    explanation:
      'Главный принцип — документация должна приносить пользу, а не быть формальностью. Just enough documentation — документировать то, что нужно для понимания и принятия решений. Docs-as-code интегрирует документацию в developer workflow, снижая порог её обновления. ADR — особенно ценный артефакт, сохраняющий контекст решений.',
  },
  {
    id: 'sa-architecture-050',
    block: 'sa',
    topic: 'architecture',
    topicLabel: 'Архитектура и интеграции',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Hexagonal Architecture (Ports and Adapters)?',
    options: [
      'Архитектура с шестью обязательными слоями',
      'Архитектурный стиль, изолирующий бизнес-логику от внешнего мира через порты (интерфейсы) и адаптеры (реализации)',
      'Архитектура для систем с шестью микросервисами',
      'Паттерн распределённых баз данных',
    ],
    correctIndex: 1,
    explanation:
      'Hexagonal Architecture (Alistair Cockburn), также Ports and Adapters — архитектурный стиль, помещающий бизнес-логику (domain) в центр, изолированную от внешнего мира. Порты (ports) — интерфейсы для взаимодействия с внешним миром (входящие — для запросов к системе, исходящие — для запросов от системы). Адаптеры (adapters) — конкретные реализации портов (REST controller, Kafka consumer, PostgreSQL repository, Email sender). Преимущества: тестируемость (бизнес-логика тестируется без инфраструктуры), взаимозаменяемость адаптеров (смена БД без изменения логики), чёткое разделение ответственности. Близкие концепции: Clean Architecture (Robert Martin), Onion Architecture.',
  },
];
