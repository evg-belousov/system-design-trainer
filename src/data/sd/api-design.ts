import type { Question } from '../types';

export const apiDesignQuestions: Question[] = [
  {
    id: 'sd-api-001',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-метод следует использовать для создания нового ресурса в RESTful API?',
    options: [
      'GET',
      'PUT',
      'POST',
      'PATCH',
    ],
    correctIndex: 2,
    explanation:
      'В RESTful API метод POST используется для создания нового ресурса. GET -- для получения, PUT -- для полного обновления (или создания по известному ID), PATCH -- для частичного обновления, DELETE -- для удаления. POST является не-идемпотентным методом: повторный вызов может создать дублирующие ресурсы. Это важно учитывать при проектировании API для обработки сетевых ошибок и ретраев.',
  },
  {
    id: 'sd-api-002',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой подход к версионированию API считается наиболее распространённым?',
    options: [
      'Версия в URL-пути: /api/v1/users',
      'Версия в query-параметре: /api/users?version=1',
      'Версия в кастомном HTTP-заголовке: X-API-Version: 1',
      'Версия в Accept-заголовке: Accept: application/vnd.api.v1+json',
    ],
    correctIndex: 0,
    explanation:
      'Версионирование через URL-путь (/api/v1/users, /api/v2/users) -- самый распространённый и простой подход. Его используют Google, Twitter, Facebook. Преимущества: очевидно и читаемо, легко тестировать в браузере, легко маршрутизировать на разные бэкенды. Недостатки: нарушает принцип REST (URI должен идентифицировать ресурс, а не его версию), при изменении версии меняются все URL. Альтернативы (заголовки, query-параметры, content negotiation) более «правильны» с точки зрения REST, но менее удобны на практике.',
  },
  {
    id: 'sd-api-003',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните REST, GraphQL и gRPC. В каких сценариях каждый подход предпочтителен?',
    sampleAnswer:
      'REST: стандартный подход для публичных веб-API. Использует HTTP-методы и URL для ресурсов. Прост, широко поддерживается, хорошо кэшируется. Подходит для CRUD-операций, публичных API, когда структура данных стабильна. Недостатки: over-fetching (получение лишних полей), under-fetching (необходимость нескольких запросов), нет строгой типизации. GraphQL: единый endpoint, клиент запрашивает ровно те поля, которые нужны. Подходит для: мобильных приложений (экономия трафика), UI с разнообразными представлениями одних данных, BFF (Backend for Frontend). Недостатки: сложность кэширования, N+1 проблема на бэкенде, сложнее авторизация на уровне полей. gRPC: бинарный протокол на основе Protocol Buffers и HTTP/2. Строгая типизация, кодогенерация клиентов, двунаправленный стриминг. Подходит для: межсервисной коммуникации, высоконагруженных систем, real-time стриминга. Недостатки: сложнее отладка (бинарный формат), ограниченная поддержка в браузерах.',
    explanation:
      'На практике часто используется комбинация: gRPC для межсервисной коммуникации внутри кластера (высокая производительность, строгие контракты), REST или GraphQL для внешнего API (удобство для фронтенд-разработчиков). Важно выбирать технологию исходя из конкретных требований, а не моды.',
  },
  {
    id: 'sd-api-004',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как спроектировать API с поддержкой rate limiting? Какие алгоритмы ограничения частоты запросов существуют и какие заголовки должен возвращать API?',
    sampleAnswer:
      'Rate limiting ограничивает количество запросов от клиента за единицу времени. Основные алгоритмы: 1) Token Bucket: виртуальное «ведро» с токенами, каждый запрос потребляет токен, токены добавляются с фиксированной скоростью. Позволяет всплески (burst). 2) Leaky Bucket: запросы ставятся в очередь и обрабатываются с фиксированной скоростью, сглаживая нагрузку. 3) Fixed Window: подсчёт запросов в фиксированных временных окнах (например, 100 запросов в минуту). Проблема: на границе окон возможен двойной лимит. 4) Sliding Window Log: хранение timestamp каждого запроса, подсчёт в скользящем окне. Точный, но расходует память. 5) Sliding Window Counter: комбинация fixed window и sliding window -- эффективный компромисс. API должен возвращать заголовки: X-RateLimit-Limit (лимит), X-RateLimit-Remaining (оставшиеся запросы), X-RateLimit-Reset (время сброса), Retry-After (при превышении). Код ответа при превышении: 429 Too Many Requests.',
    explanation:
      'Rate limiting -- критически важный компонент любого публичного API. Он защищает от злоупотреблений, DDoS-атак и обеспечивает справедливое распределение ресурсов между клиентами. В распределённых системах rate limiting реализуется через централизованное хранилище (Redis) с атомарными операциями (INCR + EXPIRE). Популярные реализации: API Gateway (Kong, AWS API Gateway), middleware (express-rate-limit), Envoy proxy.',
  },
  {
    id: 'sd-api-005',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что означает идемпотентность HTTP-метода?',
    options: [
      'Метод может быть вызван только один раз',
      'Повторный вызов метода с теми же параметрами даёт тот же результат, что и первый вызов',
      'Метод не изменяет состояние сервера',
      'Метод всегда возвращает HTTP 200',
    ],
    correctIndex: 1,
    explanation:
      'Идемпотентный метод -- это метод, многократный вызов которого с одними и теми же параметрами даёт тот же результат, что и однократный вызов. GET, PUT, DELETE -- идемпотентные методы. POST -- не идемпотентный (каждый вызов может создать новый ресурс). Идемпотентность важна для надёжности: если клиент не получил ответ из-за сетевой ошибки, он может безопасно повторить идемпотентный запрос. Это ключевое свойство при проектировании API для распределённых систем с ненадёжной сетью.',
  },
  {
    id: 'sd-api-design-006',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код ответа следует вернуть, когда запрашиваемый ресурс не найден?',
    options: [
      '200 OK',
      '400 Bad Request',
      '404 Not Found',
      '500 Internal Server Error',
    ],
    correctIndex: 2,
    explanation:
      'HTTP-код 404 Not Found означает, что сервер не нашёл запрашиваемый ресурс. Это один из наиболее часто используемых кодов ответа. 200 OK -- успешный запрос, 400 Bad Request -- ошибка в запросе клиента (неверный формат, отсутствие обязательных полей), 500 Internal Server Error -- необработанная ошибка на сервере. Правильное использование HTTP-кодов -- важный принцип проектирования RESTful API, позволяющий клиентам корректно обрабатывать ответы.',
  },
  {
    id: 'sd-api-design-007',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что описывает спецификация OpenAPI (Swagger)?',
    options: [
      'Протокол шифрования API-запросов',
      'Стандарт для описания REST API: эндпоинты, параметры, тела запросов/ответов, аутентификация',
      'Инструмент для автоматического масштабирования API-серверов',
      'Система управления версиями API',
    ],
    correctIndex: 1,
    explanation:
      'OpenAPI Specification (ранее Swagger) -- это стандарт для описания REST API в машиночитаемом формате (YAML или JSON). Он включает описание эндпоинтов, HTTP-методов, параметров запросов, тел запросов и ответов, схем данных, аутентификации. На основе OpenAPI-спецификации можно: генерировать интерактивную документацию (Swagger UI, ReDoc), генерировать клиентские и серверные SDK, автоматизировать тестирование, настраивать валидацию запросов. Это де-факто стандарт для документирования REST API.',
  },
  {
    id: 'sd-api-design-008',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой основной принцип именования ресурсов в REST API?',
    options: [
      'Использовать глаголы для обозначения действий: /getUsers, /createOrder',
      'Использовать существительные во множественном числе: /users, /orders',
      'Использовать однобуквенные сокращения: /u, /o',
      'Использовать нумерацию эндпоинтов: /endpoint1, /endpoint2',
    ],
    correctIndex: 1,
    explanation:
      'В REST API ресурсы именуются существительными во множественном числе: /users, /orders, /products. Действия определяются HTTP-методами: GET /users (получить список), POST /users (создать), GET /users/123 (получить конкретного), PUT /users/123 (обновить), DELETE /users/123 (удалить). Глаголы в URL (/getUsers, /deleteOrder) -- антипаттерн, нарушающий принципы REST. Исключение -- RPC-style эндпоинты для операций, не укладывающихся в CRUD (например, POST /users/123/activate).',
  },
  {
    id: 'sd-api-design-009',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Richardson Maturity Model (модель зрелости Ричардсона) для REST API?',
    options: [
      'Методология тестирования производительности API',
      'Модель из 4 уровней зрелости REST API: от RPC-стиля (уровень 0) до HATEOAS (уровень 3)',
      'Система оценки безопасности API',
      'Стандарт версионирования API от уровня 1 до уровня 4',
    ],
    correctIndex: 1,
    explanation:
      'Модель зрелости Ричардсона определяет 4 уровня зрелости REST API: Уровень 0 (The Swamp of POX): один URL, один HTTP-метод (обычно POST), RPC-стиль. Уровень 1 (Resources): отдельные URL для каждого ресурса (/users, /orders), но используется один HTTP-метод. Уровень 2 (HTTP Verbs): правильное использование HTTP-методов (GET, POST, PUT, DELETE) и кодов ответа. Большинство современных REST API находятся на этом уровне. Уровень 3 (Hypermedia/HATEOAS): ответы содержат ссылки на связанные ресурсы и доступные действия, позволяя клиенту навигировать по API динамически.',
  },
  {
    id: 'sd-api-design-010',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Какие существуют подходы к пагинации в API? Сравните их преимущества и недостатки.',
    sampleAnswer:
      '1) Offset-based (LIMIT/OFFSET): GET /items?offset=20&limit=10. Плюсы: простота реализации, возможность перехода к произвольной странице. Минусы: плохая производительность на больших offset (БД сканирует все строки до offset), неконсистентность при параллельных вставках/удалениях (элементы могут дублироваться или пропускаться). 2) Cursor-based (keyset pagination): GET /items?cursor=eyJpZCI6MTAwfQ&limit=10. Курсор -- закодированный указатель на последний элемент предыдущей страницы. Плюсы: стабильная производительность на любой «глубине», консистентность при изменениях данных. Минусы: нельзя перейти к произвольной странице, сложнее реализация. 3) Page-based: GET /items?page=3&per_page=10. Плюсы: интуитивность для пользователей. Минусы: те же проблемы, что у offset-based (page * per_page = offset). 4) Time-based: GET /items?since=2024-01-01T00:00:00Z&limit=10. Плюсы: хорошо работает для лент событий. Минусы: проблемы с элементами с одинаковым timestamp. Рекомендация: cursor-based для API с большими данными, offset для небольших коллекций и админ-панелей.',
    explanation:
      'Cursor-based пагинация стала стандартом для API крупных платформ: Facebook Graph API, Twitter API, Stripe API используют курсоры. Важно также возвращать метаданные пагинации: общее количество элементов (если возможно вычислить эффективно), ссылки на следующую/предыдущую страницу, признак наличия следующей страницы (has_next).',
  },
  {
    id: 'sd-api-design-011',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое HATEOAS в REST API?',
    options: [
      'Протокол аутентификации для API',
      'Принцип, при котором ответ API содержит гиперссылки на связанные ресурсы и доступные действия',
      'Формат сериализации данных, альтернативный JSON',
      'Механизм кэширования ответов API на стороне клиента',
    ],
    correctIndex: 1,
    explanation:
      'HATEOAS (Hypermedia As The Engine Of Application State) -- принцип REST, при котором ответ API содержит гиперссылки на связанные ресурсы и доступные действия. Пример: GET /orders/123 возвращает не только данные заказа, но и ссылки: {"self": "/orders/123", "cancel": "/orders/123/cancel", "payment": "/payments/456"}. Это позволяет клиенту навигировать по API динамически, без жёсткого кодирования URL. Это высший уровень зрелости REST API (Level 3 по Ричардсону), но на практике используется редко из-за сложности реализации и отсутствия явных преимуществ для типичных SPA/мобильных приложений.',
  },
  {
    id: 'sd-api-design-012',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое ключи идемпотентности (Idempotency Keys) и как они используются для обеспечения надёжности API?',
    sampleAnswer:
      'Idempotency Key -- это уникальный идентификатор (обычно UUID), который клиент передаёт в заголовке запроса (например, Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000) при выполнении мутирующих операций (POST, PATCH). Сервер сохраняет ключ и результат операции. При повторном запросе с тем же ключом сервер возвращает сохранённый результат без повторного выполнения операции. Алгоритм: 1) Клиент генерирует UUID и отправляет запрос. 2) Сервер проверяет, существует ли ключ в хранилище. 3) Если нет -- выполняет операцию, сохраняет результат с привязкой к ключу. 4) Если да -- возвращает сохранённый результат. 5) Ключи хранятся ограниченное время (например, 24 часа). Это критически важно для финансовых операций: при сетевой ошибке клиент может повторить запрос на списание денег, не боясь двойного списания. Stripe, PayPal, AWS API -- все используют idempotency keys.',
    explanation:
      'Реализация idempotency keys требует атомарности: проверка ключа и выполнение операции должны быть в одной транзакции, иначе возможны race conditions. Хранилище ключей (обычно Redis или таблица в БД) должно быть надёжным и быстрым. Важно обрабатывать edge cases: что делать, если первый запрос ещё выполняется, а пришёл повторный (in-flight collision)? Обычно второй запрос получает ответ 409 Conflict или блокируется до завершения первого.',
  },
  {
    id: 'sd-api-design-013',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить обратную совместимость API при его развитии? Какие изменения являются обратно совместимыми, а какие -- нет?',
    sampleAnswer:
      'Обратно совместимые изменения (не ломают существующих клиентов): 1) Добавление нового необязательного поля в ответ (клиенты, не знающие о поле, его игнорируют). 2) Добавление нового необязательного параметра запроса. 3) Добавление нового эндпоинта. 4) Добавление нового значения enum (если клиент обрабатывает неизвестные значения). 5) Расширение допустимых значений параметра. Обратно несовместимые (breaking) изменения: 1) Удаление или переименование поля в ответе. 2) Изменение типа поля (string -> number). 3) Добавление нового обязательного параметра запроса. 4) Изменение URL эндпоинта. 5) Изменение семантики существующего поля. 6) Удаление значения enum. Стратегии управления: 1) Версионирование API (v1, v2) для breaking changes. 2) Deprecation policy: объявление устаревших полей/эндпоинтов заранее с датой удаления. 3) Feature flags для постепенного перехода. 4) Sunset header (RFC 8594) для уведомления о дате выключения. 5) Расширяемый дизайн: использование объектов вместо примитивов, массивов вместо одиночных значений.',
    explanation:
      'Правило Postels (закон робастности): «Будь консервативен в том, что отправляешь, и либерален в том, что принимаешь». Клиенты должны игнорировать неизвестные поля, а серверы -- принимать запросы с отсутствующими необязательными полями. Это обеспечивает максимальную совместимость при эволюции API.',
  },
  {
    id: 'sd-api-design-014',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В чём главное преимущество GraphQL перед REST при разработке клиентских приложений?',
    options: [
      'GraphQL всегда быстрее REST',
      'GraphQL позволяет клиенту запрашивать ровно те поля, которые нужны, решая проблемы over-fetching и under-fetching',
      'GraphQL не требует серверной части',
      'GraphQL автоматически шифрует все данные',
    ],
    correctIndex: 1,
    explanation:
      'Главное преимущество GraphQL -- клиент определяет структуру ответа в запросе, получая ровно те данные, которые нужны. Over-fetching (получение лишних полей) и under-fetching (необходимость нескольких запросов для сбора данных) -- типичные проблемы REST, которые GraphQL решает. Например, вместо двух REST-запросов (GET /users/1 + GET /users/1/posts) в GraphQL достаточно одного запроса, возвращающего только нужные поля пользователя и его постов. Это особенно полезно для мобильных приложений с ограниченной пропускной способностью.',
  },
  {
    id: 'sd-api-design-015',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое паттерн BFF (Backend for Frontend)?',
    options: [
      'Паттерн, при котором frontend-приложение напрямую обращается к базе данных',
      'Паттерн, при котором для каждого типа клиента (web, mobile, IoT) создаётся отдельный серверный API-слой',
      'Паттерн, при котором backend полностью генерирует HTML-страницы',
      'Паттерн, при котором все клиенты используют единый универсальный API',
    ],
    correctIndex: 1,
    explanation:
      'BFF (Backend for Frontend) -- это паттерн, при котором для каждого типа клиентского приложения создаётся отдельный серверный слой. Например: BFF для веб-приложения (отдаёт больше данных, HTML-рендеринг), BFF для мобильного приложения (компактные ответы, учёт слабой сети), BFF для IoT-устройств (минимальные данные, специфичные протоколы). Каждый BFF агрегирует данные из микросервисов и адаптирует их под нужды конкретного клиента. Это позволяет избежать «универсального» API, который плохо подходит всем. Паттерн предложен Сэмом Ньюманом и широко используется в Netflix, SoundCloud.',
  },
  {
    id: 'sd-api-design-016',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое HTTP-коды ответов и на какие группы они делятся? Приведите примеры кодов из каждой группы.',
    sampleAnswer:
      'HTTP-коды ответов -- трёхзначные числа, информирующие клиента о результате запроса. Они делятся на 5 групп: 1) 1xx (Informational): информационные. 100 Continue -- сервер получил заголовки и ждёт тело запроса. 101 Switching Protocols -- переключение протокола (WebSocket). 2) 2xx (Success): успех. 200 OK -- успешный запрос. 201 Created -- ресурс создан (ответ на POST). 204 No Content -- успех без тела ответа (ответ на DELETE). 3) 3xx (Redirection): перенаправление. 301 Moved Permanently -- ресурс перемещён навсегда. 302 Found -- временное перенаправление. 304 Not Modified -- ресурс не изменился (кэш актуален). 4) 4xx (Client Error): ошибка клиента. 400 Bad Request -- неверный запрос. 401 Unauthorized -- не аутентифицирован. 403 Forbidden -- нет прав доступа. 404 Not Found -- ресурс не найден. 429 Too Many Requests -- превышен лимит. 5) 5xx (Server Error): ошибка сервера. 500 Internal Server Error -- внутренняя ошибка. 502 Bad Gateway -- ошибка upstream-сервера. 503 Service Unavailable -- сервис недоступен.',
    explanation:
      'Правильное использование HTTP-кодов -- основа хорошего API-дизайна. Частая ошибка -- возвращать 200 OK с телом {"error": "not found"} вместо 404. Это затрудняет автоматическую обработку ошибок клиентами, мониторинг и алертинг.',
  },
  {
    id: 'sd-api-design-017',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Как реализовать версионирование API? Сравните основные подходы.',
    sampleAnswer:
      '1) Версия в URL-пути: /api/v1/users, /api/v2/users. Плюсы: наглядно, легко тестировать, легко маршрутизировать. Минусы: нарушает принцип REST (URI должен идентифицировать ресурс), требует обновления всех клиентских URL при смене версии. 2) Версия в query-параметре: /api/users?version=2. Плюсы: не меняет базовый URL ресурса, необязательный параметр. Минусы: менее очевидно, может конфликтовать с другими параметрами. 3) Версия в HTTP-заголовке: X-API-Version: 2 или Accept: application/vnd.myapi.v2+json. Плюсы: «чистые» URL, соответствует принципам REST (content negotiation). Минусы: сложнее тестировать (нельзя просто открыть URL в браузере), менее очевидно для разработчиков. 4) Без явного версионирования (evolution): используются только обратно совместимые изменения, deprecated поля помечаются, но не удаляются. Плюсы: один URL, нет фрагментации. Минусы: накопление легаси, сложность поддержки. На практике версия в URL -- самый популярный подход, используется Google, Stripe, GitHub.',
    explanation:
      'Важно определить стратегию поддержки старых версий: сколько версий поддерживать одновременно, какой период deprecation (обычно 6-12 месяцев), как уведомлять клиентов о предстоящих изменениях (Sunset header, email-нотификации, changelog).',
  },
  {
    id: 'sd-api-design-018',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой механизм позволяет сделать POST-запросы безопасными для повторной отправки при сетевых ошибках?',
    options: [
      'Использование HTTPS вместо HTTP',
      'Использование ключей идемпотентности (Idempotency-Key header)',
      'Увеличение таймаута запроса',
      'Отправка запроса через WebSocket вместо HTTP',
    ],
    correctIndex: 1,
    explanation:
      'Ключи идемпотентности (Idempotency-Key) позволяют безопасно повторять POST-запросы. Клиент генерирует уникальный ключ (UUID) и передаёт его в заголовке Idempotency-Key. Сервер при первом запросе сохраняет ключ и результат. При повторном запросе с тем же ключом сервер возвращает сохранённый результат без повторного выполнения операции. Это критически важно для платёжных систем: при таймауте запроса на списание клиент не знает, прошла ли оплата. С idempotency key он может безопасно повторить запрос без риска двойного списания.',
  },
  {
    id: 'sd-api-design-019',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите стратегии обработки ошибок в API. Какие best practices существуют для формирования ответов об ошибках?',
    sampleAnswer:
      'Best practices обработки ошибок в API: 1) Использовать правильные HTTP-коды: 4xx для ошибок клиента, 5xx для серверных. Не возвращать 200 с телом ошибки. 2) Структурированное тело ошибки: {"error": {"code": "VALIDATION_ERROR", "message": "Человекочитаемое описание", "details": [{"field": "email", "issue": "invalid_format"}], "request_id": "abc-123"}}. 3) Машиночитаемые коды ошибок (error codes): строковые константы (INSUFFICIENT_FUNDS, RATE_LIMIT_EXCEEDED), а не только HTTP-коды. Позволяют клиенту программно реагировать на конкретные ошибки. 4) Request ID: уникальный идентификатор запроса для корреляции с логами на сервере. 5) Локализация сообщений: разделять machine-readable code и human-readable message, поддерживать Accept-Language. 6) Не раскрывать внутренние детали: stack traces, SQL-запросы, пути файловой системы не должны попадать в ответы production API. 7) Стандартизация: использовать RFC 7807 (Problem Details for HTTP APIs) для единообразного формата ошибок. 8) Документирование: каждый эндпоинт должен документировать возможные ошибки.',
    explanation:
      'RFC 7807 (Problem Details for HTTP APIs) предлагает стандартный формат: {"type": "https://example.com/errors/insufficient-funds", "title": "Insufficient Funds", "status": 422, "detail": "Your account balance is 10, but the transfer requires 50", "instance": "/transfers/123"}. Stripe API -- хороший пример проектирования ошибок: чёткие коды, полезные сообщения, request_id для отладки.',
  },
  {
    id: 'sd-api-design-020',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какое утверждение о GraphQL верно с точки зрения безопасности?',
    options: [
      'GraphQL безопаснее REST, так как использует одну точку входа',
      'GraphQL требует дополнительных мер защиты: ограничение глубины и сложности запросов, контроль стоимости запроса (query cost analysis)',
      'GraphQL автоматически предотвращает SQL-инъекции',
      'GraphQL не нуждается в аутентификации, так как клиент сам выбирает данные',
    ],
    correctIndex: 1,
    explanation:
      'GraphQL вводит специфические проблемы безопасности, отсутствующие в REST: 1) Злоумышленник может построить глубоко вложенный запрос (query depth attack), потребляющий огромные ресурсы сервера. 2) Широкие запросы (запрос множества полей и связей) могут перегрузить БД. Меры защиты: ограничение глубины запроса (query depth limiting), анализ стоимости запроса (query cost analysis -- каждому полю присваивается «вес», суммарный вес ограничен), таймауты выполнения, пагинация обязательных связей, персистентные запросы (persisted queries -- сервер принимает только заранее зарегистрированные запросы), авторизация на уровне полей.',
  },
  {
    id: 'sd-api-design-021',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-метод используется для частичного обновления ресурса?',
    options: [
      'PUT',
      'POST',
      'PATCH',
      'UPDATE',
    ],
    correctIndex: 2,
    explanation:
      'PATCH используется для частичного обновления ресурса -- отправляются только изменяемые поля. PUT, напротив, заменяет ресурс целиком. Пример: чтобы изменить только email пользователя, PATCH /users/123 с телом {"email": "new@example.com"} обновит только email, тогда как PUT потребовал бы отправить все поля пользователя. PATCH идемпотентен, если одна и та же операция применяется к одним и тем же данным.',
  },
  {
    id: 'sd-api-design-022',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код следует вернуть при успешном создании ресурса?',
    options: [
      '200 OK',
      '201 Created',
      '204 No Content',
      '202 Accepted',
    ],
    correctIndex: 1,
    explanation:
      '201 Created -- правильный код при успешном создании ресурса (обычно в ответ на POST). В ответе рекомендуется включить заголовок Location с URL созданного ресурса и тело с его представлением. 200 OK используется для успешных GET/PUT/PATCH, 204 No Content -- когда ответ не содержит тела (DELETE), 202 Accepted -- когда запрос принят, но обработка ещё не завершена (асинхронные операции).',
  },
  {
    id: 'sd-api-design-023',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'open',
    question: 'Какие основные принципы проектирования RESTful API вы знаете?',
    sampleAnswer:
      'Основные принципы REST API: 1) Ресурсы идентифицируются через URL: /users, /orders/123. Используйте существительные, не глаголы. 2) HTTP-методы определяют действия: GET (чтение), POST (создание), PUT (полное обновление), PATCH (частичное обновление), DELETE (удаление). 3) Stateless: каждый запрос содержит всю информацию для обработки, сервер не хранит состояние сессии. 4) Единообразный интерфейс: консистентные URL, форматы ответов, коды ошибок. 5) Правильные HTTP-коды: 2xx успех, 4xx ошибки клиента, 5xx ошибки сервера. 6) Поддержка форматов: JSON как стандарт, указание через Content-Type и Accept. 7) Версионирование для обратной совместимости. 8) Фильтрация, сортировка, пагинация через query parameters.',
    explanation:
      'REST -- это архитектурный стиль, а не строгий стандарт. Многие API называются RESTful, но не следуют всем принципам (например, игнорируют HATEOAS). Практичный подход -- следовать основным принципам (ресурсы, HTTP-методы, коды ответов) и документировать API через OpenAPI.',
  },
  {
    id: 'sd-api-design-024',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой формат данных является стандартом де-факто для современных REST API?',
    options: [
      'XML',
      'JSON',
      'YAML',
      'Protocol Buffers',
    ],
    correctIndex: 1,
    explanation:
      'JSON (JavaScript Object Notation) стал стандартом для REST API благодаря: простоте чтения и записи, нативной поддержке в JavaScript (и хорошей поддержке в других языках), компактности по сравнению с XML. API указывает формат через заголовки Content-Type: application/json (в ответе) и Accept: application/json (в запросе). XML всё ещё используется в legacy-системах и SOAP. Protocol Buffers используется в gRPC.',
  },
  {
    id: 'sd-api-design-025',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое OAuth 2.0 в контексте API?',
    options: [
      'Протокол шифрования данных при передаче',
      'Протокол авторизации, позволяющий предоставить ограниченный доступ к ресурсам без передачи пароля',
      'Формат токенов аутентификации',
      'Стандарт описания API',
    ],
    correctIndex: 1,
    explanation:
      'OAuth 2.0 -- протокол авторизации, позволяющий приложениям получить ограниченный доступ к ресурсам пользователя на другом сервисе без знания его пароля. Пример: приложение получает доступ к фото в Google Photos. OAuth определяет роли (Resource Owner, Client, Authorization Server, Resource Server), типы грантов (Authorization Code, Client Credentials, и др.) и потоки авторизации. Результат -- access token, который приложение использует для доступа к API.',
  },
  {
    id: 'sd-api-design-026',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое JWT (JSON Web Token) и как он используется в API аутентификации?',
    sampleAnswer:
      'JWT -- компактный токен, состоящий из трёх частей, разделённых точками: Header (алгоритм подписи), Payload (claims -- данные о пользователе, время жизни), Signature (подпись для верификации). Пример: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIn0.signature. Использование: 1) Пользователь аутентифицируется (login), сервер создаёт JWT и возвращает клиенту. 2) Клиент отправляет JWT в заголовке Authorization: Bearer <token> при каждом запросе. 3) Сервер верифицирует подпись и извлекает данные из payload без обращения к БД. Преимущества: stateless аутентификация, масштабируемость. Недостатки: сложность отзыва токена до истечения срока (нужен blacklist), увеличенный размер запросов.',
    explanation:
      'JWT не зашифрован (если не использовать JWE), payload легко декодируется (base64). Не храните в нём секретные данные. Рекомендации: короткое время жизни access token (15-60 мин), refresh token для обновления, хранение refresh token в httpOnly cookie.',
  },
  {
    id: 'sd-api-design-027',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В чём основное различие между аутентификацией и авторизацией в API?',
    options: [
      'Это одно и то же, просто разные термины',
      'Аутентификация подтверждает личность пользователя, авторизация определяет его права доступа',
      'Аутентификация используется для API, авторизация -- для веб-приложений',
      'Аутентификация всегда требует пароль, авторизация -- токен',
    ],
    correctIndex: 1,
    explanation:
      'Аутентификация (Authentication) отвечает на вопрос «Кто ты?» -- подтверждает личность пользователя (логин/пароль, токен, сертификат). Авторизация (Authorization) отвечает на вопрос «Что тебе разрешено?» -- определяет, какие ресурсы и операции доступны аутентифицированному пользователю. Пример: JWT токен аутентифицирует пользователя, а роли/права в его claims определяют авторизацию (admin может удалять, user -- только читать).',
  },
  {
    id: 'sd-api-design-028',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Как обеспечить безопасность API? Перечислите основные практики.',
    sampleAnswer:
      'Практики безопасности API: 1) HTTPS обязательно -- шифрование трафика, защита от MITM. 2) Аутентификация: OAuth 2.0, JWT, API keys (для server-to-server). 3) Авторизация: проверка прав на каждом эндпоинте, RBAC/ABAC. 4) Валидация входных данных: защита от SQL injection, XSS, path traversal. 5) Rate limiting: защита от brute force и DDoS. 6) Не раскрывать внутренние детали в ошибках: stack traces, SQL-запросы, пути. 7) CORS: ограничить разрешённые origins. 8) Security headers: Content-Security-Policy, X-Content-Type-Options. 9) Логирование и мониторинг: отслеживание подозрительной активности. 10) Регулярный аудит: OWASP API Security Top 10, penetration testing. 11) Версионирование: поддержка безопасных миграций.',
    explanation:
      'OWASP API Security Top 10 выделяет главные угрозы: Broken Object Level Authorization (BOLA), Broken Authentication, Excessive Data Exposure, Lack of Resources & Rate Limiting. API -- основная точка атаки современных приложений.',
  },
  {
    id: 'sd-api-design-029',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое GraphQL Federation и как она решает проблему объединения нескольких GraphQL-сервисов?',
    sampleAnswer:
      'GraphQL Federation (Apollo Federation) -- архитектура для построения единого GraphQL API из нескольких независимых микросервисов (subgraphs). Каждый сервис определяет свою часть схемы и может расширять типы других сервисов. Gateway объединяет схемы и маршрутизирует запросы. Ключевые концепции: 1) @key directive -- определяет поля для идентификации сущности между сервисами. 2) @extends -- расширение типа, определённого в другом сервисе. 3) __resolveReference -- резолвер для получения сущности по ключу. Пример: User-сервис определяет User, Orders-сервис расширяет User полем orders. Преимущества: независимая разработка и деплой сервисов, единый API для клиента, разделение ответственности. Apollo Gateway / Apollo Router выполняет query planning и распределение запросов.',
    explanation:
      'Federation v2 (2022) упростила модель и добавила новые возможности: @shareable (общие поля), @override (миграция полей), улучшенный query planner. Netflix, Expedia, Airbnb используют Federation для объединения сотен микросервисов в единый GraphQL API.',
  },
  {
    id: 'sd-api-design-030',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое gRPC и какой протокол сериализации он использует по умолчанию?',
    options: [
      'RPC-фреймворк, использующий JSON',
      'RPC-фреймворк, использующий Protocol Buffers (protobuf) и HTTP/2',
      'REST-альтернатива, использующая XML',
      'Messaging-протокол, использующий MessagePack',
    ],
    correctIndex: 1,
    explanation:
      'gRPC -- высокопроизводительный RPC-фреймворк от Google. Ключевые особенности: Protocol Buffers для сериализации (бинарный формат, строгая типизация, кодогенерация), HTTP/2 для транспорта (мультиплексирование, server push, header compression), поддержка streaming (unary, server streaming, client streaming, bidirectional). Используется для межсервисной коммуникации, где важны производительность и строгие контракты. gRPC-web позволяет использовать gRPC из браузера через proxy.',
  },
  {
    id: 'sd-api-design-031',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерны streaming в gRPC. Когда использовать каждый тип?',
    sampleAnswer:
      'gRPC поддерживает 4 типа взаимодействия: 1) Unary RPC: классический request-response. Клиент отправляет один запрос, получает один ответ. Подходит для большинства CRUD-операций. 2) Server Streaming: клиент отправляет один запрос, сервер отвечает потоком сообщений. Пример: подписка на обновления, загрузка большого списка по частям. 3) Client Streaming: клиент отправляет поток сообщений, сервер отвечает одним ответом. Пример: загрузка файла по частям, отправка batch-данных. 4) Bidirectional Streaming: оба направления независимо передают потоки сообщений. Пример: chat, real-time collaboration, long-polling альтернатива. Streaming в gRPC эффективнее REST для: больших объёмов данных (не нужно держать всё в памяти), real-time обновлений, long-running операций.',
    explanation:
      'HTTP/2, лежащий в основе gRPC, позволяет мультиплексировать множество streams в одном TCP-соединении. Это делает gRPC streaming более эффективным, чем отдельные HTTP-запросы или WebSocket (который тоже можно использовать, но он менее структурирован).',
  },
  {
    id: 'sd-api-design-032',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой инструмент используется для интерактивной документации REST API на основе OpenAPI-спецификации?',
    options: [
      'Postman',
      'Swagger UI / ReDoc',
      'GraphiQL',
      'gRPCurl',
    ],
    correctIndex: 1,
    explanation:
      'Swagger UI и ReDoc -- инструменты для генерации интерактивной документации из OpenAPI-спецификации. Swagger UI позволяет не только читать документацию, но и выполнять запросы прямо из браузера (Try it out). ReDoc предлагает более современный и читаемый интерфейс. Postman -- инструмент для тестирования API (не документация). GraphiQL -- IDE для GraphQL. gRPCurl -- CLI для gRPC.',
  },
  {
    id: 'sd-api-design-033',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое API Gateway и какие функции он выполняет?',
    sampleAnswer:
      'API Gateway -- единая точка входа для клиентских запросов, которая маршрутизирует их к внутренним сервисам. Основные функции: 1) Маршрутизация: направление запросов к нужным микросервисам на основе URL, заголовков. 2) Аутентификация/авторизация: централизованная проверка токенов, JWT валидация. 3) Rate limiting: ограничение частоты запросов по API key, IP, пользователю. 4) Трансформация: преобразование запросов/ответов (protocol translation, payload transformation). 5) Агрегация: объединение ответов от нескольких сервисов. 6) Кэширование на уровне gateway. 7) Мониторинг, логирование, трейсинг. 8) SSL/TLS termination. Примеры: Kong, AWS API Gateway, Nginx, Envoy, Tyk.',
    explanation:
      'API Gateway реализует паттерн Facade для микросервисов. Важно не перегружать gateway бизнес-логикой -- он должен быть тонким слоем инфраструктуры. При неправильной настройке gateway может стать узким местом и single point of failure.',
  },
  {
    id: 'sd-api-design-034',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Deprecation Policy для API и какой HTTP-заголовок используется для уведомления о предстоящем удалении?',
    options: [
      'Content-Deprecation',
      'Sunset',
      'X-Deprecated',
      'Warning',
    ],
    correctIndex: 1,
    explanation:
      'Sunset header (RFC 8594) указывает дату, после которой ресурс/API будет недоступен. Формат: Sunset: Sat, 31 Dec 2024 23:59:59 GMT. Deprecation Policy определяет: сроки предупреждения (обычно 6-12 месяцев), способы уведомления (заголовки, email, документация, changelog), период поддержки старых версий. Best practices: документировать deprecation в changelog, отправлять Sunset header, логировать использование deprecated endpoints для оценки влияния, предоставлять migration guide.',
  },
  {
    id: 'sd-api-design-035',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код возвращается при превышении лимита запросов (rate limit)?',
    options: [
      '401 Unauthorized',
      '403 Forbidden',
      '429 Too Many Requests',
      '503 Service Unavailable',
    ],
    correctIndex: 2,
    explanation:
      '429 Too Many Requests -- специальный код для rate limiting (RFC 6585). В ответе должны быть заголовки: Retry-After (через сколько секунд можно повторить), X-RateLimit-Limit (лимит), X-RateLimit-Remaining (оставшиеся запросы), X-RateLimit-Reset (время сброса счётчика). 503 иногда используется, но менее точен -- он указывает на общую недоступность сервиса, а не на превышение лимита конкретным клиентом.',
  },
  {
    id: 'sd-api-design-036',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Как спроектировать API для поиска с фильтрацией, сортировкой и пагинацией? Приведите пример URL.',
    sampleAnswer:
      'Пример: GET /api/v1/products?category=electronics&price_min=100&price_max=500&in_stock=true&sort=-price,name&page=2&per_page=20. Разбор: 1) Фильтрация через query parameters: category=electronics, price_min/max для диапазонов, in_stock=true для boolean. Для сложных фильтров можно использовать filter[field][operator]=value или JSON в теле POST. 2) Сортировка: sort=-price,name означает сортировку по price descending, затем по name ascending. Минус означает убывание. 3) Пагинация: page/per_page (offset-based) или cursor для cursor-based. Ответ включает метаданные: {"data": [...], "meta": {"total": 150, "page": 2, "per_page": 20, "total_pages": 8}, "links": {"next": "...", "prev": "..."}}.',
    explanation:
      'Консистентность важна: если API использует page/per_page в одном эндпоинте, используйте те же параметры везде. JSON:API и OData предлагают стандартизированные подходы к фильтрации/сортировке. Для сложных поисковых сценариев рассмотрите GraphQL или отдельный Search API.',
  },
  {
    id: 'sd-api-design-037',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое N+1 проблема в GraphQL и как её решить?',
    sampleAnswer:
      'N+1 проблема в GraphQL: при запросе списка объектов с вложенными данными (users { posts }) наивная реализация делает 1 запрос за списком users + N запросов за posts каждого user. Решения: 1) DataLoader: batch + cache. Собирает все ID за один tick event loop и делает один batch-запрос (SELECT * FROM posts WHERE user_id IN (1,2,3...)). Кэширует результаты в рамках запроса. 2) JOIN в SQL: резолвер верхнего уровня сразу загружает связанные данные через JOIN. 3) Lookahead: анализ запроса перед выполнением и оптимизация стратегии загрузки. 4) Persist computed data: для read-heavy сценариев денормализовать данные. DataLoader от Facebook -- стандартное решение, реализации есть для всех языков.',
    explanation:
      'N+1 -- одна из главных проблем производительности GraphQL. Мониторинг количества SQL-запросов на один GraphQL-запрос критически важен. Apollo Server предоставляет плагины для трейсинга и анализа производительности резолверов.',
  },
  {
    id: 'sd-api-design-038',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн рекомендуется для эволюции GraphQL-схемы без breaking changes?',
    options: [
      'Удаление старых полей сразу после добавления новых',
      'Версионирование через /graphql/v1, /graphql/v2',
      'Добавление новых полей, deprecation старых через @deprecated, постепенное удаление',
      'Создание отдельного endpoint для каждого клиента',
    ],
    correctIndex: 2,
    explanation:
      'GraphQL рекомендует evolution over versioning: добавлять новые поля (обратно совместимо), помечать старые как @deprecated с указанием альтернативы, удалять после migration period на основе аналитики использования. Директива @deprecated отображается в инструментах (GraphiQL, Apollo Studio) и генераторах кода. Мониторинг использования deprecated полей через Apollo Studio или custom analytics помогает определить безопасный момент удаления.',
  },
  {
    id: 'sd-api-design-039',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Webhook и чем он отличается от polling?',
    options: [
      'Webhook и polling -- это одно и то же',
      'Webhook -- push-модель, сервер отправляет уведомление клиенту; polling -- pull-модель, клиент периодически запрашивает сервер',
      'Webhook работает через WebSocket, polling -- через HTTP',
      'Webhook используется только для безопасности',
    ],
    correctIndex: 1,
    explanation:
      'Webhook -- push-модель: клиент регистрирует URL (callback), и сервер отправляет HTTP POST на этот URL при наступлении события. Polling -- pull-модель: клиент периодически запрашивает сервер (GET /events?since=timestamp). Преимущества webhook: real-time уведомления, экономия ресурсов (нет пустых запросов). Недостатки: клиент должен иметь публичный URL, необходима обработка retry при ошибках, подтверждение доставки. Stripe, GitHub, Slack активно используют webhooks.',
  },
  {
    id: 'sd-api-design-040',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить надёжность webhook-доставки? Какие механизмы необходимы?',
    sampleAnswer:
      'Механизмы надёжности webhooks: 1) Retry с exponential backoff: при ошибке (5xx, timeout) повторять с увеличивающимся интервалом (1 мин, 5 мин, 30 мин, 1 час). 2) Idempotency: включать уникальный event_id, получатель должен дедуплицировать по нему. 3) Signature verification: подпись payload секретным ключом (HMAC-SHA256), получатель верифицирует. Защита от подделки. 4) Delivery confirmation: ожидать 2xx ответ, иначе считать неудачей. 5) Dead letter queue: после N неудачных попыток сохранять в DLQ для ручного анализа. 6) Event log: хранить историю отправленных webhook-ов с возможностью resend. 7) Webhook endpoints management: UI для регистрации URL, просмотра истории доставки, тестирования. 8) Timeout: короткий (5-30 сек), длинная обработка не должна блокировать webhook.',
    explanation:
      'Получатель webhook должен возвращать 200 быстро и обрабатывать событие асинхронно (через очередь). Stripe Webhook best practices -- отличный reference. Важно: webhook-ы могут приходить не по порядку и дублироваться, получатель должен это учитывать.',
  },
  {
    id: 'sd-api-design-041',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой подход к именованию URL в REST API является правильным?',
    options: [
      '/getUsers, /createUser, /deleteUser/123',
      '/users, /users (POST), /users/123 (DELETE)',
      '/api?action=getUsers',
      '/Users, /USERS/123',
    ],
    correctIndex: 1,
    explanation:
      'В REST URL представляют ресурсы (существительные), а действия определяются HTTP-методами: GET /users (список), POST /users (создание), GET /users/123 (получение), PUT/PATCH /users/123 (обновление), DELETE /users/123 (удаление). URL должны быть в нижнем регистре, множественное число для коллекций. Глаголы в URL (getUsers, deleteUser) -- антипаттерн, нарушающий принципы REST.',
  },
  {
    id: 'sd-api-design-042',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое API Key и для чего он используется?',
    options: [
      'Ключ шифрования для защиты данных в API',
      'Уникальный идентификатор для аутентификации и отслеживания использования API клиентом',
      'Публичный ключ SSL-сертификата',
      'Ключ для кэширования ответов API',
    ],
    correctIndex: 1,
    explanation:
      'API Key -- уникальная строка, идентифицирующая клиента API. Используется для: простой аутентификации (особенно для server-to-server), rate limiting per client, аналитики использования, монетизации (платные API-планы). Передаётся в заголовке (X-API-Key, Authorization: ApiKey xxx) или query parameter (менее безопасно, попадает в логи). API Key -- не замена OAuth для пользовательской аутентификации, он идентифицирует приложение, а не пользователя.',
  },
  {
    id: 'sd-api-design-043',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как спроектировать API для bulk-операций (массовых операций)? Какие подходы существуют?',
    sampleAnswer:
      'Подходы к bulk-операциям: 1) Batch endpoint: POST /users/batch с массивом объектов в теле. Ответ содержит статус каждой операции: {"results": [{"id": "1", "status": "success"}, {"id": "2", "status": "error", "error": {...}}]}. 2) Multipart request: отдельные запросы в одном HTTP-запросе (используется Facebook Graph API). 3) Async job: POST /import-jobs запускает job, возвращает job_id. GET /import-jobs/{id} для проверки статуса. Подходит для очень больших операций. 4) Streaming: клиент отправляет NDJSON (newline-delimited JSON) поток. Сервер обрабатывает по мере получения. Best practices: ограничение размера batch (100-1000 элементов), partial success handling (не откатывать всё при ошибке одного), idempotency key для всего batch или каждого элемента, прогресс для async jobs.',
    explanation:
      'Google API (Gmail, Drive) и Salesforce используют batch endpoints. Stripe использует async approach для больших импортов. Важно документировать поведение при частичных ошибках и предоставлять детальную информацию о каждом элементе.',
  },
  {
    id: 'sd-api-design-044',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Hypermedia (HATEOAS) и почему оно редко используется на практике?',
    options: [
      'Протокол для передачи мультимедиа через API',
      'Принцип REST, при котором ответ содержит ссылки на связанные ресурсы и действия, но сложен в реализации и не даёт явных преимуществ для типичных клиентов',
      'Стандарт документирования API',
      'Метод кэширования медиа-контента',
    ],
    correctIndex: 1,
    explanation:
      'HATEOAS (Hypermedia As The Engine Of Application State) -- высший уровень REST по Ричардсону. Ответ содержит ссылки: {"id": 1, "name": "...", "_links": {"self": "/users/1", "orders": "/users/1/orders", "delete": "/users/1"}}. Теоретически позволяет клиенту навигировать по API без hardcoded URL. На практике редко используется: SPA и мобильные приложения уже знают структуру API, overhead на включение ссылок в каждый ответ, сложность реализации. JSON:API и HAL -- форматы для HATEOAS.',
  },
  {
    id: 'sd-api-design-045',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Как реализовать long-polling и Server-Sent Events (SSE) для real-time обновлений в API?',
    sampleAnswer:
      'Long-polling: клиент отправляет запрос, сервер держит соединение открытым до появления данных или таймаута (30-60 сек). При получении ответа клиент немедленно отправляет новый запрос. Плюсы: работает везде (обычный HTTP). Минусы: overhead на переустановку соединений, сложность на сервере. Server-Sent Events (SSE): однонаправленный поток от сервера к клиенту через HTTP. Клиент подключается GET-запросом, сервер отправляет события в формате "data: {...}\\n\\n". Плюсы: встроенная поддержка в браузерах (EventSource API), автоматический reconnect, проще WebSocket. Минусы: только от сервера к клиенту, ограничение на количество соединений в HTTP/1.1. Выбор: SSE для уведомлений и обновлений (news feed, notifications), WebSocket для bidirectional real-time (chat, gaming), Long-polling как fallback.',
    explanation:
      'HTTP/2 снимает ограничение в 6 соединений на домен, делая SSE более практичным. GraphQL Subscriptions обычно реализуются через WebSocket, но есть реализации через SSE (@graphql-sse). Для большинства use cases SSE проще и достаточен.',
  },
  {
    id: 'sd-api-design-046',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое CORS и зачем он нужен при работе с API из браузера?',
    sampleAnswer:
      'CORS (Cross-Origin Resource Sharing) -- механизм безопасности браузера, ограничивающий запросы к ресурсам с другого origin (домен + порт + протокол). Без CORS JavaScript с site-a.com не может делать запросы к api.site-b.com. Как работает: 1) Simple requests (GET, POST с простыми заголовками) отправляются сразу, браузер проверяет Access-Control-Allow-Origin в ответе. 2) Preflight requests (OPTIONS) отправляются перед сложными запросами для проверки разрешений. Заголовки ответа: Access-Control-Allow-Origin (разрешённые origins), Access-Control-Allow-Methods (методы), Access-Control-Allow-Headers (заголовки), Access-Control-Allow-Credentials (разрешить cookies). Для публичного API: Access-Control-Allow-Origin: *. Для приватного: конкретный origin.',
    explanation:
      'CORS -- частый источник проблем при разработке. Ошибки CORS видны только в браузере, не в Postman или curl. Важно: CORS -- защита пользователя, а не сервера. Сервер без CORS всё равно обработает запрос, просто браузер не покажет ответ JavaScript.',
  },
  {
    id: 'sd-api-design-047',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход к авторизации на уровне полей используется в GraphQL?',
    options: [
      'Авторизация только на уровне всего запроса',
      'Field-level authorization в резолверах или через директивы (@auth, @hasRole)',
      'Авторизация невозможна в GraphQL',
      'Авторизация только через middleware',
    ],
    correctIndex: 1,
    explanation:
      'В GraphQL авторизация реализуется на уровне полей: 1) В резолверах: проверка context.user перед возвратом данных. 2) Через директивы: @auth, @hasRole("admin") в схеме, обрабатываемые middleware. 3) Через wrapper-функции или декораторы. Это важно, потому что в GraphQL клиент выбирает поля, и нужно контролировать доступ к каждому. Пример: поле user.email видно только самому пользователю или админу, а user.name -- всем. Apollo Server, graphql-shield -- инструменты для декларативной авторизации.',
  },
  {
    id: 'sd-api-design-048',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое ETag и для чего он используется в API?',
    options: [
      'Уникальный идентификатор сессии',
      'Хэш или версия ресурса для условных запросов и кэширования',
      'Тег для категоризации API endpoints',
      'Идентификатор ошибки в логах',
    ],
    correctIndex: 1,
    explanation:
      'ETag (Entity Tag) -- идентификатор конкретной версии ресурса, обычно хэш содержимого или номер версии. Использование: 1) Кэширование: клиент отправляет If-None-Match: "etag-value", сервер возвращает 304 Not Modified, если ресурс не изменился. 2) Optimistic locking: при обновлении клиент отправляет If-Match: "etag-value", сервер обновляет только если ETag совпадает, иначе 412 Precondition Failed (кто-то изменил ресурс). Это предотвращает потерю изменений при concurrent updates.',
  },
  {
    id: 'sd-api-design-049',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как спроектировать API для file upload? Какие подходы существуют для больших файлов?',
    sampleAnswer:
      'Подходы к file upload: 1) Multipart form-data: POST /files с Content-Type: multipart/form-data. Подходит для файлов до нескольких сотен MB. Можно включить метаданные в том же запросе. 2) Direct binary: PUT /files/{id} с Content-Type: application/octet-stream. Тело запроса -- сырые байты файла. 3) Base64 в JSON: для небольших файлов (иконки, аватары). Увеличивает размер на 33%. 4) Presigned URL (recommended для больших файлов): сервер генерирует подписанный URL для прямой загрузки в S3/GCS, клиент загружает напрямую в storage, затем уведомляет API о завершении. Разгружает API-сервер. 5) Chunked upload: файл разбивается на части (chunks), каждая загружается отдельно с возможностью retry. Поддерживает resume. TUS protocol -- стандарт для resumable uploads. 6) Streaming: клиент отправляет поток, сервер обрабатывает по мере получения.',
    explanation:
      'Для production-систем presigned URLs + chunked upload -- золотой стандарт. YouTube, Dropbox, Google Drive используют похожие подходы. Важно учитывать таймауты, progress reporting, validation (размер, тип файла), virus scanning.',
  },
  {
    id: 'sd-api-design-050',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход рекомендуется для API, поддерживающего несколько языков (i18n)?',
    options: [
      'Отдельный endpoint для каждого языка: /en/users, /ru/users',
      'Accept-Language header для выбора языка, с fallback на default',
      'Query parameter ?lang=ru для всех запросов',
      'Хранение языка в JWT токене',
    ],
    correctIndex: 1,
    explanation:
      'Accept-Language header -- стандартный HTTP-механизм для content negotiation по языку. Клиент отправляет Accept-Language: ru-RU, en;q=0.9, сервер возвращает контент на предпочитаемом языке (или fallback). Ответ должен включать Content-Language header. Vary: Accept-Language для корректного кэширования. Query parameter (?lang=ru) допустим как альтернатива или override. Язык в URL (/ru/users) нарушает принцип REST (один ресурс -- один URL) и усложняет маршрутизацию.',
  },
];
