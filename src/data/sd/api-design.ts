import type { Question } from '../types';

export const apiDesignQuestions: Question[] = [
  {
    id: 'sd-api-001',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-метод следует использовать для создания нового ресурса в RESTful API?',
    options: [
      'GET',
      'PUT',
      'POST',
      'PATCH',
    ],
    correctIndex: 2,
    explanation:
      'В RESTful API метод POST используется для создания нового ресурса. GET -- для получения, PUT -- для полного обновления (или создания по известному ID), PATCH -- для частичного обновления, DELETE -- для удаления. POST является не-идемпотентным методом: повторный вызов может создать дублирующие ресурсы. Это важно учитывать при проектировании API для обработки сетевых ошибок и ретраев.',
  },
  {
    id: 'sd-api-002',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой подход к версионированию API считается наиболее распространённым?',
    options: [
      'Версия в URL-пути: /api/v1/users',
      'Версия в query-параметре: /api/users?version=1',
      'Версия в кастомном HTTP-заголовке: X-API-Version: 1',
      'Версия в Accept-заголовке: Accept: application/vnd.api.v1+json',
    ],
    correctIndex: 0,
    explanation:
      'Версионирование через URL-путь (/api/v1/users, /api/v2/users) -- самый распространённый и простой подход. Его используют Google, Twitter, Facebook. Преимущества: очевидно и читаемо, легко тестировать в браузере, легко маршрутизировать на разные бэкенды. Недостатки: нарушает принцип REST (URI должен идентифицировать ресурс, а не его версию), при изменении версии меняются все URL. Альтернативы (заголовки, query-параметры, content negotiation) более «правильны» с точки зрения REST, но менее удобны на практике.',
  },
  {
    id: 'sd-api-003',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните REST, GraphQL и gRPC. В каких сценариях каждый подход предпочтителен?',
    sampleAnswer:
      'REST: стандартный подход для публичных веб-API. Использует HTTP-методы и URL для ресурсов. Прост, широко поддерживается, хорошо кэшируется. Подходит для CRUD-операций, публичных API, когда структура данных стабильна. Недостатки: over-fetching (получение лишних полей), under-fetching (необходимость нескольких запросов), нет строгой типизации. GraphQL: единый endpoint, клиент запрашивает ровно те поля, которые нужны. Подходит для: мобильных приложений (экономия трафика), UI с разнообразными представлениями одних данных, BFF (Backend for Frontend). Недостатки: сложность кэширования, N+1 проблема на бэкенде, сложнее авторизация на уровне полей. gRPC: бинарный протокол на основе Protocol Buffers и HTTP/2. Строгая типизация, кодогенерация клиентов, двунаправленный стриминг. Подходит для: межсервисной коммуникации, высоконагруженных систем, real-time стриминга. Недостатки: сложнее отладка (бинарный формат), ограниченная поддержка в браузерах.',
    explanation:
      'На практике часто используется комбинация: gRPC для межсервисной коммуникации внутри кластера (высокая производительность, строгие контракты), REST или GraphQL для внешнего API (удобство для фронтенд-разработчиков). Важно выбирать технологию исходя из конкретных требований, а не моды.',
  },
  {
    id: 'sd-api-004',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как спроектировать API с поддержкой rate limiting? Какие алгоритмы ограничения частоты запросов существуют и какие заголовки должен возвращать API?',
    sampleAnswer:
      'Rate limiting ограничивает количество запросов от клиента за единицу времени. Основные алгоритмы: 1) Token Bucket: виртуальное «ведро» с токенами, каждый запрос потребляет токен, токены добавляются с фиксированной скоростью. Позволяет всплески (burst). 2) Leaky Bucket: запросы ставятся в очередь и обрабатываются с фиксированной скоростью, сглаживая нагрузку. 3) Fixed Window: подсчёт запросов в фиксированных временных окнах (например, 100 запросов в минуту). Проблема: на границе окон возможен двойной лимит. 4) Sliding Window Log: хранение timestamp каждого запроса, подсчёт в скользящем окне. Точный, но расходует память. 5) Sliding Window Counter: комбинация fixed window и sliding window -- эффективный компромисс. API должен возвращать заголовки: X-RateLimit-Limit (лимит), X-RateLimit-Remaining (оставшиеся запросы), X-RateLimit-Reset (время сброса), Retry-After (при превышении). Код ответа при превышении: 429 Too Many Requests.',
    explanation:
      'Rate limiting -- критически важный компонент любого публичного API. Он защищает от злоупотреблений, DDoS-атак и обеспечивает справедливое распределение ресурсов между клиентами. В распределённых системах rate limiting реализуется через централизованное хранилище (Redis) с атомарными операциями (INCR + EXPIRE). Популярные реализации: API Gateway (Kong, AWS API Gateway), middleware (express-rate-limit), Envoy proxy.',
  },
  {
    id: 'sd-api-005',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что означает идемпотентность HTTP-метода?',
    options: [
      'Метод может быть вызван только один раз',
      'Повторный вызов метода с теми же параметрами даёт тот же результат, что и первый вызов',
      'Метод не изменяет состояние сервера',
      'Метод всегда возвращает HTTP 200',
    ],
    correctIndex: 1,
    explanation:
      'Идемпотентный метод -- это метод, многократный вызов которого с одними и теми же параметрами даёт тот же результат, что и однократный вызов. GET, PUT, DELETE -- идемпотентные методы. POST -- не идемпотентный (каждый вызов может создать новый ресурс). Идемпотентность важна для надёжности: если клиент не получил ответ из-за сетевой ошибки, он может безопасно повторить идемпотентный запрос. Это ключевое свойство при проектировании API для распределённых систем с ненадёжной сетью.',
  },
  {
    id: 'sd-api-design-006',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-код ответа следует вернуть, когда запрашиваемый ресурс не найден?',
    options: [
      '200 OK',
      '400 Bad Request',
      '404 Not Found',
      '500 Internal Server Error',
    ],
    correctIndex: 2,
    explanation:
      'HTTP-код 404 Not Found означает, что сервер не нашёл запрашиваемый ресурс. Это один из наиболее часто используемых кодов ответа. 200 OK -- успешный запрос, 400 Bad Request -- ошибка в запросе клиента (неверный формат, отсутствие обязательных полей), 500 Internal Server Error -- необработанная ошибка на сервере. Правильное использование HTTP-кодов -- важный принцип проектирования RESTful API, позволяющий клиентам корректно обрабатывать ответы.',
  },
  {
    id: 'sd-api-design-007',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что описывает спецификация OpenAPI (Swagger)?',
    options: [
      'Протокол шифрования API-запросов',
      'Стандарт для описания REST API: эндпоинты, параметры, тела запросов/ответов, аутентификация',
      'Инструмент для автоматического масштабирования API-серверов',
      'Система управления версиями API',
    ],
    correctIndex: 1,
    explanation:
      'OpenAPI Specification (ранее Swagger) -- это стандарт для описания REST API в машиночитаемом формате (YAML или JSON). Он включает описание эндпоинтов, HTTP-методов, параметров запросов, тел запросов и ответов, схем данных, аутентификации. На основе OpenAPI-спецификации можно: генерировать интерактивную документацию (Swagger UI, ReDoc), генерировать клиентские и серверные SDK, автоматизировать тестирование, настраивать валидацию запросов. Это де-факто стандарт для документирования REST API.',
  },
  {
    id: 'sd-api-design-008',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой основной принцип именования ресурсов в REST API?',
    options: [
      'Использовать глаголы для обозначения действий: /getUsers, /createOrder',
      'Использовать существительные во множественном числе: /users, /orders',
      'Использовать однобуквенные сокращения: /u, /o',
      'Использовать нумерацию эндпоинтов: /endpoint1, /endpoint2',
    ],
    correctIndex: 1,
    explanation:
      'В REST API ресурсы именуются существительными во множественном числе: /users, /orders, /products. Действия определяются HTTP-методами: GET /users (получить список), POST /users (создать), GET /users/123 (получить конкретного), PUT /users/123 (обновить), DELETE /users/123 (удалить). Глаголы в URL (/getUsers, /deleteOrder) -- антипаттерн, нарушающий принципы REST. Исключение -- RPC-style эндпоинты для операций, не укладывающихся в CRUD (например, POST /users/123/activate).',
  },
  {
    id: 'sd-api-design-009',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Richardson Maturity Model (модель зрелости Ричардсона) для REST API?',
    options: [
      'Методология тестирования производительности API',
      'Модель из 4 уровней зрелости REST API: от RPC-стиля (уровень 0) до HATEOAS (уровень 3)',
      'Система оценки безопасности API',
      'Стандарт версионирования API от уровня 1 до уровня 4',
    ],
    correctIndex: 1,
    explanation:
      'Модель зрелости Ричардсона определяет 4 уровня зрелости REST API: Уровень 0 (The Swamp of POX): один URL, один HTTP-метод (обычно POST), RPC-стиль. Уровень 1 (Resources): отдельные URL для каждого ресурса (/users, /orders), но используется один HTTP-метод. Уровень 2 (HTTP Verbs): правильное использование HTTP-методов (GET, POST, PUT, DELETE) и кодов ответа. Большинство современных REST API находятся на этом уровне. Уровень 3 (Hypermedia/HATEOAS): ответы содержат ссылки на связанные ресурсы и доступные действия, позволяя клиенту навигировать по API динамически.',
  },
  {
    id: 'sd-api-design-010',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Какие существуют подходы к пагинации в API? Сравните их преимущества и недостатки.',
    sampleAnswer:
      '1) Offset-based (LIMIT/OFFSET): GET /items?offset=20&limit=10. Плюсы: простота реализации, возможность перехода к произвольной странице. Минусы: плохая производительность на больших offset (БД сканирует все строки до offset), неконсистентность при параллельных вставках/удалениях (элементы могут дублироваться или пропускаться). 2) Cursor-based (keyset pagination): GET /items?cursor=eyJpZCI6MTAwfQ&limit=10. Курсор -- закодированный указатель на последний элемент предыдущей страницы. Плюсы: стабильная производительность на любой «глубине», консистентность при изменениях данных. Минусы: нельзя перейти к произвольной странице, сложнее реализация. 3) Page-based: GET /items?page=3&per_page=10. Плюсы: интуитивность для пользователей. Минусы: те же проблемы, что у offset-based (page * per_page = offset). 4) Time-based: GET /items?since=2024-01-01T00:00:00Z&limit=10. Плюсы: хорошо работает для лент событий. Минусы: проблемы с элементами с одинаковым timestamp. Рекомендация: cursor-based для API с большими данными, offset для небольших коллекций и админ-панелей.',
    explanation:
      'Cursor-based пагинация стала стандартом для API крупных платформ: Facebook Graph API, Twitter API, Stripe API используют курсоры. Важно также возвращать метаданные пагинации: общее количество элементов (если возможно вычислить эффективно), ссылки на следующую/предыдущую страницу, признак наличия следующей страницы (has_next).',
  },
  {
    id: 'sd-api-design-011',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое HATEOAS в REST API?',
    options: [
      'Протокол аутентификации для API',
      'Принцип, при котором ответ API содержит гиперссылки на связанные ресурсы и доступные действия',
      'Формат сериализации данных, альтернативный JSON',
      'Механизм кэширования ответов API на стороне клиента',
    ],
    correctIndex: 1,
    explanation:
      'HATEOAS (Hypermedia As The Engine Of Application State) -- принцип REST, при котором ответ API содержит гиперссылки на связанные ресурсы и доступные действия. Пример: GET /orders/123 возвращает не только данные заказа, но и ссылки: {"self": "/orders/123", "cancel": "/orders/123/cancel", "payment": "/payments/456"}. Это позволяет клиенту навигировать по API динамически, без жёсткого кодирования URL. Это высший уровень зрелости REST API (Level 3 по Ричардсону), но на практике используется редко из-за сложности реализации и отсутствия явных преимуществ для типичных SPA/мобильных приложений.',
  },
  {
    id: 'sd-api-design-012',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое ключи идемпотентности (Idempotency Keys) и как они используются для обеспечения надёжности API?',
    sampleAnswer:
      'Idempotency Key -- это уникальный идентификатор (обычно UUID), который клиент передаёт в заголовке запроса (например, Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000) при выполнении мутирующих операций (POST, PATCH). Сервер сохраняет ключ и результат операции. При повторном запросе с тем же ключом сервер возвращает сохранённый результат без повторного выполнения операции. Алгоритм: 1) Клиент генерирует UUID и отправляет запрос. 2) Сервер проверяет, существует ли ключ в хранилище. 3) Если нет -- выполняет операцию, сохраняет результат с привязкой к ключу. 4) Если да -- возвращает сохранённый результат. 5) Ключи хранятся ограниченное время (например, 24 часа). Это критически важно для финансовых операций: при сетевой ошибке клиент может повторить запрос на списание денег, не боясь двойного списания. Stripe, PayPal, AWS API -- все используют idempotency keys.',
    explanation:
      'Реализация idempotency keys требует атомарности: проверка ключа и выполнение операции должны быть в одной транзакции, иначе возможны race conditions. Хранилище ключей (обычно Redis или таблица в БД) должно быть надёжным и быстрым. Важно обрабатывать edge cases: что делать, если первый запрос ещё выполняется, а пришёл повторный (in-flight collision)? Обычно второй запрос получает ответ 409 Conflict или блокируется до завершения первого.',
  },
  {
    id: 'sd-api-design-013',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить обратную совместимость API при его развитии? Какие изменения являются обратно совместимыми, а какие -- нет?',
    sampleAnswer:
      'Обратно совместимые изменения (не ломают существующих клиентов): 1) Добавление нового необязательного поля в ответ (клиенты, не знающие о поле, его игнорируют). 2) Добавление нового необязательного параметра запроса. 3) Добавление нового эндпоинта. 4) Добавление нового значения enum (если клиент обрабатывает неизвестные значения). 5) Расширение допустимых значений параметра. Обратно несовместимые (breaking) изменения: 1) Удаление или переименование поля в ответе. 2) Изменение типа поля (string -> number). 3) Добавление нового обязательного параметра запроса. 4) Изменение URL эндпоинта. 5) Изменение семантики существующего поля. 6) Удаление значения enum. Стратегии управления: 1) Версионирование API (v1, v2) для breaking changes. 2) Deprecation policy: объявление устаревших полей/эндпоинтов заранее с датой удаления. 3) Feature flags для постепенного перехода. 4) Sunset header (RFC 8594) для уведомления о дате выключения. 5) Расширяемый дизайн: использование объектов вместо примитивов, массивов вместо одиночных значений.',
    explanation:
      'Правило Postels (закон робастности): «Будь консервативен в том, что отправляешь, и либерален в том, что принимаешь». Клиенты должны игнорировать неизвестные поля, а серверы -- принимать запросы с отсутствующими необязательными полями. Это обеспечивает максимальную совместимость при эволюции API.',
  },
  {
    id: 'sd-api-design-014',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'quiz',
    question: 'В чём главное преимущество GraphQL перед REST при разработке клиентских приложений?',
    options: [
      'GraphQL всегда быстрее REST',
      'GraphQL позволяет клиенту запрашивать ровно те поля, которые нужны, решая проблемы over-fetching и under-fetching',
      'GraphQL не требует серверной части',
      'GraphQL автоматически шифрует все данные',
    ],
    correctIndex: 1,
    explanation:
      'Главное преимущество GraphQL -- клиент определяет структуру ответа в запросе, получая ровно те данные, которые нужны. Over-fetching (получение лишних полей) и under-fetching (необходимость нескольких запросов для сбора данных) -- типичные проблемы REST, которые GraphQL решает. Например, вместо двух REST-запросов (GET /users/1 + GET /users/1/posts) в GraphQL достаточно одного запроса, возвращающего только нужные поля пользователя и его постов. Это особенно полезно для мобильных приложений с ограниченной пропускной способностью.',
  },
  {
    id: 'sd-api-design-015',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое паттерн BFF (Backend for Frontend)?',
    options: [
      'Паттерн, при котором frontend-приложение напрямую обращается к базе данных',
      'Паттерн, при котором для каждого типа клиента (web, mobile, IoT) создаётся отдельный серверный API-слой',
      'Паттерн, при котором backend полностью генерирует HTML-страницы',
      'Паттерн, при котором все клиенты используют единый универсальный API',
    ],
    correctIndex: 1,
    explanation:
      'BFF (Backend for Frontend) -- это паттерн, при котором для каждого типа клиентского приложения создаётся отдельный серверный слой. Например: BFF для веб-приложения (отдаёт больше данных, HTML-рендеринг), BFF для мобильного приложения (компактные ответы, учёт слабой сети), BFF для IoT-устройств (минимальные данные, специфичные протоколы). Каждый BFF агрегирует данные из микросервисов и адаптирует их под нужды конкретного клиента. Это позволяет избежать «универсального» API, который плохо подходит всем. Паттерн предложен Сэмом Ньюманом и широко используется в Netflix, SoundCloud.',
  },
  {
    id: 'sd-api-design-016',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое HTTP-коды ответов и на какие группы они делятся? Приведите примеры кодов из каждой группы.',
    sampleAnswer:
      'HTTP-коды ответов -- трёхзначные числа, информирующие клиента о результате запроса. Они делятся на 5 групп: 1) 1xx (Informational): информационные. 100 Continue -- сервер получил заголовки и ждёт тело запроса. 101 Switching Protocols -- переключение протокола (WebSocket). 2) 2xx (Success): успех. 200 OK -- успешный запрос. 201 Created -- ресурс создан (ответ на POST). 204 No Content -- успех без тела ответа (ответ на DELETE). 3) 3xx (Redirection): перенаправление. 301 Moved Permanently -- ресурс перемещён навсегда. 302 Found -- временное перенаправление. 304 Not Modified -- ресурс не изменился (кэш актуален). 4) 4xx (Client Error): ошибка клиента. 400 Bad Request -- неверный запрос. 401 Unauthorized -- не аутентифицирован. 403 Forbidden -- нет прав доступа. 404 Not Found -- ресурс не найден. 429 Too Many Requests -- превышен лимит. 5) 5xx (Server Error): ошибка сервера. 500 Internal Server Error -- внутренняя ошибка. 502 Bad Gateway -- ошибка upstream-сервера. 503 Service Unavailable -- сервис недоступен.',
    explanation:
      'Правильное использование HTTP-кодов -- основа хорошего API-дизайна. Частая ошибка -- возвращать 200 OK с телом {"error": "not found"} вместо 404. Это затрудняет автоматическую обработку ошибок клиентами, мониторинг и алертинг.',
  },
  {
    id: 'sd-api-design-017',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'middle',
    type: 'open',
    question: 'Как реализовать версионирование API? Сравните основные подходы.',
    sampleAnswer:
      '1) Версия в URL-пути: /api/v1/users, /api/v2/users. Плюсы: наглядно, легко тестировать, легко маршрутизировать. Минусы: нарушает принцип REST (URI должен идентифицировать ресурс), требует обновления всех клиентских URL при смене версии. 2) Версия в query-параметре: /api/users?version=2. Плюсы: не меняет базовый URL ресурса, необязательный параметр. Минусы: менее очевидно, может конфликтовать с другими параметрами. 3) Версия в HTTP-заголовке: X-API-Version: 2 или Accept: application/vnd.myapi.v2+json. Плюсы: «чистые» URL, соответствует принципам REST (content negotiation). Минусы: сложнее тестировать (нельзя просто открыть URL в браузере), менее очевидно для разработчиков. 4) Без явного версионирования (evolution): используются только обратно совместимые изменения, deprecated поля помечаются, но не удаляются. Плюсы: один URL, нет фрагментации. Минусы: накопление легаси, сложность поддержки. На практике версия в URL -- самый популярный подход, используется Google, Stripe, GitHub.',
    explanation:
      'Важно определить стратегию поддержки старых версий: сколько версий поддерживать одновременно, какой период deprecation (обычно 6-12 месяцев), как уведомлять клиентов о предстоящих изменениях (Sunset header, email-нотификации, changelog).',
  },
  {
    id: 'sd-api-design-018',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой механизм позволяет сделать POST-запросы безопасными для повторной отправки при сетевых ошибках?',
    options: [
      'Использование HTTPS вместо HTTP',
      'Использование ключей идемпотентности (Idempotency-Key header)',
      'Увеличение таймаута запроса',
      'Отправка запроса через WebSocket вместо HTTP',
    ],
    correctIndex: 1,
    explanation:
      'Ключи идемпотентности (Idempotency-Key) позволяют безопасно повторять POST-запросы. Клиент генерирует уникальный ключ (UUID) и передаёт его в заголовке Idempotency-Key. Сервер при первом запросе сохраняет ключ и результат. При повторном запросе с тем же ключом сервер возвращает сохранённый результат без повторного выполнения операции. Это критически важно для платёжных систем: при таймауте запроса на списание клиент не знает, прошла ли оплата. С idempotency key он может безопасно повторить запрос без риска двойного списания.',
  },
  {
    id: 'sd-api-design-019',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите стратегии обработки ошибок в API. Какие best practices существуют для формирования ответов об ошибках?',
    sampleAnswer:
      'Best practices обработки ошибок в API: 1) Использовать правильные HTTP-коды: 4xx для ошибок клиента, 5xx для серверных. Не возвращать 200 с телом ошибки. 2) Структурированное тело ошибки: {"error": {"code": "VALIDATION_ERROR", "message": "Человекочитаемое описание", "details": [{"field": "email", "issue": "invalid_format"}], "request_id": "abc-123"}}. 3) Машиночитаемые коды ошибок (error codes): строковые константы (INSUFFICIENT_FUNDS, RATE_LIMIT_EXCEEDED), а не только HTTP-коды. Позволяют клиенту программно реагировать на конкретные ошибки. 4) Request ID: уникальный идентификатор запроса для корреляции с логами на сервере. 5) Локализация сообщений: разделять machine-readable code и human-readable message, поддерживать Accept-Language. 6) Не раскрывать внутренние детали: stack traces, SQL-запросы, пути файловой системы не должны попадать в ответы production API. 7) Стандартизация: использовать RFC 7807 (Problem Details for HTTP APIs) для единообразного формата ошибок. 8) Документирование: каждый эндпоинт должен документировать возможные ошибки.',
    explanation:
      'RFC 7807 (Problem Details for HTTP APIs) предлагает стандартный формат: {"type": "https://example.com/errors/insufficient-funds", "title": "Insufficient Funds", "status": 422, "detail": "Your account balance is 10, but the transfer requires 50", "instance": "/transfers/123"}. Stripe API -- хороший пример проектирования ошибок: чёткие коды, полезные сообщения, request_id для отладки.',
  },
  {
    id: 'sd-api-design-020',
    block: 'sd',
    topic: 'api-design',
    topicLabel: 'Проектирование API',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какое утверждение о GraphQL верно с точки зрения безопасности?',
    options: [
      'GraphQL безопаснее REST, так как использует одну точку входа',
      'GraphQL требует дополнительных мер защиты: ограничение глубины и сложности запросов, контроль стоимости запроса (query cost analysis)',
      'GraphQL автоматически предотвращает SQL-инъекции',
      'GraphQL не нуждается в аутентификации, так как клиент сам выбирает данные',
    ],
    correctIndex: 1,
    explanation:
      'GraphQL вводит специфические проблемы безопасности, отсутствующие в REST: 1) Злоумышленник может построить глубоко вложенный запрос (query depth attack), потребляющий огромные ресурсы сервера. 2) Широкие запросы (запрос множества полей и связей) могут перегрузить БД. Меры защиты: ограничение глубины запроса (query depth limiting), анализ стоимости запроса (query cost analysis -- каждому полю присваивается «вес», суммарный вес ограничен), таймауты выполнения, пагинация обязательных связей, персистентные запросы (persisted queries -- сервер принимает только заранее зарегистрированные запросы), авторизация на уровне полей.',
  },
];
