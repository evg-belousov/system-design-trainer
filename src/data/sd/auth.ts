import type { Question } from '../types';

export const authQuestions: Question[] = [
  {
    id: 'sd-auth-001',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Чем отличается аутентификация от авторизации?',
    options: [
      'Аутентификация проверяет, имеет ли пользователь право на действие; авторизация подтверждает его личность',
      'Аутентификация подтверждает личность пользователя (кто ты); авторизация определяет, какие действия ему разрешены (что ты можешь)',
      'Аутентификация и авторизация -- это синонимы, обозначающие проверку пароля',
      'Аутентификация используется только для API, авторизация -- только для веб-интерфейса',
    ],
    correctIndex: 1,
    explanation:
      'Аутентификация (AuthN) -- процесс подтверждения личности: «Ты действительно тот, за кого себя выдаёшь?». Реализуется через пароли, токены, биометрию, сертификаты. Авторизация (AuthZ) -- процесс проверки прав доступа: «Имеешь ли ты право выполнить это действие?». Реализуется через роли, политики, ACL. Аутентификация всегда предшествует авторизации: сначала система определяет пользователя, затем проверяет его права.',
  },
  {
    id: 'sd-auth-002',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Из каких трёх частей состоит JWT (JSON Web Token)?',
    options: [
      'Username, Password, Signature',
      'Header, Payload, Signature',
      'Token, Refresh Token, Session ID',
      'Issuer, Subject, Audience',
    ],
    correctIndex: 1,
    explanation:
      'JWT состоит из трёх частей, разделённых точками: Header (заголовок) -- содержит тип токена (JWT) и алгоритм подписи (HS256, RS256). Payload (полезная нагрузка) -- содержит claims: стандартные (iss, sub, exp, iat) и пользовательские (role, user_id). Signature (подпись) -- HMAC или RSA-подпись для проверки целостности. Каждая часть кодируется в Base64Url. JWT не шифрован по умолчанию -- payload может быть прочитан любым, но не может быть изменён без знания секрета.',
  },
  {
    id: 'sd-auth-003',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое OAuth 2.0?',
    options: [
      'Протокол аутентификации для проверки логина и пароля пользователя',
      'Протокол авторизации, позволяющий приложению получить ограниченный доступ к ресурсам пользователя на другом сервисе без передачи пароля',
      'Формат токенов для хранения сессий на сервере',
      'Стандарт шифрования данных при передаче по сети',
    ],
    correctIndex: 1,
    explanation:
      'OAuth 2.0 -- протокол авторизации (не аутентификации!), позволяющий третьему приложению получить ограниченный доступ к ресурсам пользователя без раскрытия его учётных данных. Ключевые роли: Resource Owner (пользователь), Client (приложение), Authorization Server (выдаёт токены), Resource Server (хранит ресурсы). OAuth 2.0 выдаёт access token, подтверждающий право доступа. Для аутентификации поверх OAuth используется OpenID Connect.',
  },
  {
    id: 'sd-auth-004',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой OAuth 2.0 flow рекомендуется для SPA (Single Page Application) и мобильных приложений?',
    options: [
      'Implicit Flow',
      'Client Credentials Flow',
      'Authorization Code Flow с PKCE',
      'Resource Owner Password Credentials Flow',
    ],
    correctIndex: 2,
    explanation:
      'Authorization Code Flow с PKCE (Proof Key for Code Exchange) рекомендуется для публичных клиентов (SPA, мобильные приложения), которые не могут безопасно хранить client_secret. PKCE добавляет code_verifier (случайная строка) и code_challenge (её хэш). Клиент отправляет code_challenge при запросе авторизации, а code_verifier -- при обмене кода на токен. Это предотвращает перехват authorization code злоумышленником. Implicit Flow считается устаревшим и небезопасным (токен в URL, нет refresh token).',
  },
  {
    id: 'sd-auth-005',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Чем API-ключ (API key) отличается от access token (например, JWT)?',
    options: [
      'API key идентифицирует приложение (клиента); access token авторизует действия от имени конкретного пользователя',
      'API key и access token -- это одно и то же, просто разные названия',
      'API key безопаснее, так как имеет срок действия, а access token -- нет',
      'API key используется только для аутентификации, а access token -- только для шифрования',
    ],
    correctIndex: 0,
    explanation:
      'API key -- длинная строка, идентифицирующая приложение или проект. Используется для rate limiting, биллинга, базового контроля доступа. Обычно не привязан к конкретному пользователю. Access token (например, JWT) -- токен, выданный после аутентификации пользователя, содержащий информацию о его identity и правах. Имеет срок действия. API keys удобны для server-to-server взаимодействия, но не подходят для пользовательской авторизации, так как не содержат контекста пользователя и scope.',
  },
  {
    id: 'sd-auth-006',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое MFA (Multi-Factor Authentication)?',
    options: [
      'Использование нескольких паролей для входа в систему',
      'Аутентификация с использованием двух или более независимых факторов: знание (пароль), владение (телефон/токен), биометрия (отпечаток)',
      'Шифрование пароля несколькими алгоритмами последовательно',
      'Авторизация пользователя одновременно в нескольких системах',
    ],
    correctIndex: 1,
    explanation:
      'MFA (Multi-Factor Authentication) требует подтверждения личности несколькими независимыми факторами: 1) Something you know -- пароль, PIN. 2) Something you have -- телефон (SMS, TOTP-приложение), аппаратный ключ (YubiKey). 3) Something you are -- биометрия (отпечаток, лицо). Ключевое слово -- «независимые»: два пароля -- это не MFA. TOTP (Time-based One-Time Password, RFC 6238) -- наиболее распространённый второй фактор. FIDO2/WebAuthn -- современный стандарт, устойчивый к фишингу.',
  },
  {
    id: 'sd-auth-007',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой OAuth 2.0 flow используется для межсервисной (machine-to-machine) аутентификации?',
    options: [
      'Authorization Code Flow',
      'Implicit Flow',
      'Client Credentials Flow',
      'Device Authorization Flow',
    ],
    correctIndex: 2,
    explanation:
      'Client Credentials Flow используется, когда клиент действует от своего имени, а не от имени пользователя (machine-to-machine). Клиент отправляет свой client_id и client_secret напрямую Authorization Server и получает access token. Нет этапа перенаправления пользователя. Применяется для: backend-сервис вызывает другой backend-сервис, cron-задачи, CLI-инструменты. Важно: client_secret должен храниться безопасно (environment variables, secrets manager), никогда в коде.',
  },
  {
    id: 'sd-auth-008',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем OpenID Connect (OIDC) отличается от OAuth 2.0?',
    options: [
      'OIDC -- это полная замена OAuth 2.0 с несовместимым протоколом',
      'OIDC -- это надстройка над OAuth 2.0, добавляющая слой аутентификации (ID Token с информацией о пользователе)',
      'OIDC используется только для мобильных приложений, а OAuth -- для веба',
      'OIDC и OAuth 2.0 -- идентичные протоколы разных организаций',
    ],
    correctIndex: 1,
    explanation:
      'OpenID Connect (OIDC) -- это identity layer поверх OAuth 2.0. OAuth 2.0 сам по себе -- протокол авторизации, он не сообщает, КТО пользователь. OIDC добавляет: ID Token (JWT с claims о пользователе: sub, name, email); стандартный /userinfo эндпоинт; стандартные scopes (openid, profile, email); процесс Discovery (.well-known/openid-configuration). Таким образом, OIDC = OAuth 2.0 (авторизация) + ID Token (аутентификация). Google Sign-In, Apple Sign-In, Azure AD используют OIDC.',
  },
  {
    id: 'sd-auth-009',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое PKCE (Proof Key for Code Exchange) и какую атаку он предотвращает?',
    options: [
      'Шифрование токенов на клиентской стороне для защиты от XSS',
      'Защита от перехвата authorization code путём привязки его к конкретному клиенту через code_verifier/code_challenge',
      'Подпись JWT с использованием асимметричной криптографии',
      'Механизм ротации refresh tokens для предотвращения replay-атак',
    ],
    correctIndex: 1,
    explanation:
      'PKCE (RFC 7636) предотвращает атаку перехвата authorization code. Процесс: 1) Клиент генерирует случайный code_verifier. 2) Вычисляет code_challenge = SHA256(code_verifier). 3) Отправляет code_challenge в запросе авторизации. 4) Получает authorization code. 5) При обмене code на token отправляет code_verifier. 6) Authorization Server проверяет: SHA256(code_verifier) == code_challenge. Даже если злоумышленник перехватит authorization code (через custom URL scheme, redirect), он не сможет обменять его на токен без code_verifier.',
  },
  {
    id: 'sd-auth-010',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем RBAC отличается от ABAC?',
    options: [
      'RBAC назначает права на основе ролей пользователя; ABAC принимает решения на основе атрибутов пользователя, ресурса, окружения и действия',
      'RBAC используется для API, а ABAC -- для баз данных',
      'RBAC -- это устаревший подход, ABAC -- его прямая замена',
      'RBAC обеспечивает доступ на уровне строк, ABAC -- на уровне таблиц',
    ],
    correctIndex: 0,
    explanation:
      'RBAC (Role-Based Access Control): пользователю назначаются роли (admin, editor, viewer), каждая роль имеет набор permissions. Просто в реализации и понимании, но негибкий при сложных правилах. ABAC (Attribute-Based Access Control): решение принимается на основе политик, учитывающих атрибуты субъекта (department, clearance level), объекта (classification, owner), действия (read, write) и контекста (время суток, IP-адрес). Пример: «Доктор может читать медкарту пациента из своего отделения в рабочее время». RBAC не может выразить такое правило без создания множества ролей.',
  },
  {
    id: 'sd-auth-011',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Как работает SSO (Single Sign-On) на базе SAML 2.0?',
    options: [
      'Пользователь вводит пароль в каждом приложении, но пароль одинаковый',
      'Пользователь аутентифицируется один раз в Identity Provider (IdP), и IdP передаёт SAML Assertion (XML-документ с подписью) приложениям (Service Providers) для подтверждения личности',
      'Все приложения используют общую базу данных пользователей и проверяют пароль напрямую',
      'Пользователь получает единый JWT-токен, который работает во всех приложениях',
    ],
    correctIndex: 1,
    explanation:
      'SAML 2.0 SSO: 1) Пользователь обращается к Service Provider (SP). 2) SP перенаправляет на Identity Provider (IdP) с SAML AuthnRequest. 3) IdP аутентифицирует пользователя (если ещё не аутентифицирован). 4) IdP создаёт SAML Assertion -- XML-документ с информацией о пользователе, подписанный цифровой подписью IdP. 5) IdP перенаправляет пользователя обратно на SP с SAML Response. 6) SP проверяет подпись и извлекает данные пользователя. При обращении к другому SP шаги 1-2 повторяются, но шаг 3 пропускается (IdP уже имеет сессию).',
  },
  {
    id: 'sd-auth-012',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Опишите стратегию refresh token rotation. Почему она важна и как реализуется?',
    sampleAnswer:
      'Refresh Token Rotation -- стратегия, при которой каждый раз при использовании refresh token выдаётся новый refresh token, а старый инвалидируется. Процесс: 1) Клиент отправляет refresh token на /token эндпоинт. 2) Authorization Server проверяет refresh token, выдаёт новый access token и НОВЫЙ refresh token. 3) Старый refresh token помечается как использованный. 4) Если кто-то попытается использовать старый (уже использованный) refresh token, это сигнал о компрометации: сервер инвалидирует ВСЮ цепочку токенов (включая текущий активный refresh token), вынуждая пользователя пройти аутентификацию заново. Это значительно снижает окно уязвимости при утечке refresh token. RFC 6819 и OAuth 2.0 Security Best Current Practice рекомендуют rotation для публичных клиентов.',
    explanation:
      'Без rotation украденный refresh token можно использовать неограниченное время (до истечения). С rotation: если токен украден, либо легитимный пользователь, либо злоумышленник использует его первым. Второе использование триггерит automatic reuse detection и полную инвалидацию. Auth0, Okta и другие провайдеры поддерживают refresh token rotation из коробки.',
  },
  {
    id: 'sd-auth-013',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните хранение сессий на сервере (server-side sessions) и stateless-подход с JWT. Какие у каждого преимущества и недостатки?',
    sampleAnswer:
      'Server-side sessions: сервер хранит состояние сессии (в памяти, Redis, БД), клиент получает session ID в cookie. Плюсы: легко инвалидировать (удалить сессию), малый размер cookie, данные сессии не видны клиенту. Минусы: требует shared storage при нескольких серверах (sticky sessions или Redis), дополнительный запрос к хранилищу на каждый запрос, сложнее масштабировать. JWT (stateless): токен содержит все claims, сервер не хранит состояние. Плюсы: не нужно shared storage, отлично масштабируется, работает across domains. Минусы: нельзя инвалидировать до истечения (нужен blocklist), больший размер (передаётся в каждом запросе), payload видна клиенту (Base64, не шифрование), при добавлении claims размер растёт. На практике часто комбинируют: short-lived JWT (5-15 мин) + server-side refresh token.',
    explanation:
      'Вопрос «JWT vs Sessions» -- один из самых частых на собеседованиях. Ключевое различие -- в управлении состоянием. Для микросервисов JWT удобнее (каждый сервис валидирует подпись без обращения к централизованному хранилищу). Для монолитов server-side sessions проще и безопаснее. Гибридный подход -- наиболее практичный.',
  },
  {
    id: 'sd-auth-014',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое passwordless authentication? Опишите основные подходы и их преимущества.',
    sampleAnswer:
      'Passwordless authentication -- аутентификация без пароля, использующая альтернативные факторы. Основные подходы: 1) Magic Link -- одноразовая ссылка отправляется на email. Пользователь кликает -- аутентифицирован. Просто, но зависит от безопасности email. 2) WebAuthn/FIDO2 -- аутентификация через аппаратные ключи (YubiKey) или платформенные аутентификаторы (Touch ID, Windows Hello). Самый безопасный вариант, устойчив к фишингу. 3) OTP через SMS/email -- одноразовый код. Менее безопасен (SIM swapping, перехват SMS). 4) Passkeys -- развитие WebAuthn, синхронизируемые между устройствами через iCloud Keychain / Google Password Manager. Преимущества passwordless: нет паролей для кражи/утечки, устойчивость к фишингу (WebAuthn), лучший UX (не нужно запоминать пароли), снижение нагрузки на поддержку (сброс паролей).',
    explanation:
      'Apple, Google и Microsoft совместно продвигают Passkeys как замену паролям. NIST рекомендует отказ от SMS OTP в пользу TOTP и FIDO2. Passwordless -- тренд, значительно повышающий безопасность, так как большинство атак (credential stuffing, phishing) эксплуатируют слабые или украденные пароли.',
  },
  {
    id: 'sd-auth-015',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой алгоритм подписи JWT предпочтителен в микросервисной архитектуре, где множество сервисов должны валидировать токен?',
    options: [
      'HS256 (HMAC с общим секретом) -- все сервисы используют один secret',
      'RS256 (RSA) -- Authorization Server подписывает приватным ключом, сервисы проверяют публичным ключом через JWKS endpoint',
      'none (без подписи) -- для ускорения валидации',
      'AES256 -- симметричное шифрование payload',
    ],
    correctIndex: 1,
    explanation:
      'RS256 (RSA-SHA256) использует асимметричную криптографию: Authorization Server подписывает JWT приватным ключом, который хранится только у него. Все Resource Servers проверяют подпись с помощью публичного ключа, доступного через JWKS (JSON Web Key Set) endpoint (/.well-known/jwks.json). Преимущества: компрометация одного сервиса не позволяет подделать токен; публичный ключ можно безопасно распространять; поддерживается key rotation через kid (Key ID) в заголовке JWT. HS256 требует передачи общего секрета всем сервисам, что создаёт один общий point of failure.',
  },
  {
    id: 'sd-auth-016',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какая атака на JWT возможна при неправильной валидации заголовка alg?',
    options: [
      'SQL Injection через payload JWT',
      'Атакующий устанавливает alg: "none" и удаляет подпись, обходя проверку',
      'DDoS-атака через генерацию большого количества токенов',
      'Man-in-the-middle через подмену refresh token',
    ],
    correctIndex: 1,
    explanation:
      'Атака «alg: none»: если сервер доверяет значению alg из заголовка JWT, злоумышленник может установить «alg: "none"», удалить подпись и получить валидный токен. Ещё одна атака: «algorithm confusion» -- при RS256 сервер проверяет подпись публичным ключом; злоумышленник меняет alg на HS256 и подписывает токен публичным ключом (который общедоступен) как HMAC-секретом. Защита: ВСЕГДА явно указывать ожидаемый алгоритм на сервере (whitelist), НИКОГДА не полагаться на значение alg из токена.',
  },
  {
    id: 'sd-auth-017',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Спроектируйте систему аутентификации и авторизации для микросервисной платформы. Опишите выбор протоколов, управление токенами и проверку прав доступа.',
    sampleAnswer:
      'Архитектура: 1) Централизованный Identity Provider (Keycloak/Auth0): поддерживает OIDC, хранит пользователей, роли, permissions. 2) API Gateway как точка входа: валидирует JWT (проверка подписи RS256, exp, iss, aud), извлекает claims, пробрасывает user context в заголовках downstream-сервисам. 3) Токены: short-lived access token (JWT, 5-15 мин) с claims (sub, roles, permissions); long-lived refresh token (opaque, хранится в БД IdP) с rotation. 4) Авторизация: грубая (coarse-grained) на API Gateway по roles из JWT; тонкая (fine-grained) в каждом сервисе по permissions и бизнес-правилам (ABAC). 5) Service-to-service: Client Credentials Flow, mutual TLS или service mesh (Istio). 6) Token introspection endpoint для проверки активности opaque tokens. 7) JWKS endpoint с key rotation (kid header). 8) Blacklist в Redis для инвалидации JWT до истечения (для logout, смены пароля). 9) Rate limiting на /token endpoint против brute force.',
    explanation:
      'Ключевой принцип: «never trust, always verify». Каждый микросервис должен независимо валидировать JWT, а не полагаться только на API Gateway. Для критичных операций (перевод денег) может потребоваться step-up authentication -- повторный запрос второго фактора.',
  },
  {
    id: 'sd-auth-018',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Как безопасно реализовать инвалидацию JWT до истечения срока действия? Опишите подходы и их компромиссы.',
    sampleAnswer:
      'Проблема: JWT stateless -- сервер не хранит состояние, поэтому не может «отозвать» выданный токен. Подходы: 1) Short-lived tokens (5-15 мин): уменьшает окно уязвимости, но не решает проблему полностью. При logout токен живёт ещё 5-15 минут. 2) Token Blacklist (deny list): при logout/смене пароля jti (JWT ID) добавляется в Redis/in-memory store. Каждый запрос проверяет blacklist. Компромисс: вводит stateful-проверку, нагрузка на Redis, нужна синхронизация между инстансами. 3) Token Versioning: в БД хранится token_version для пользователя. JWT содержит version claim. При необходимости инвалидации version увеличивается. Компромисс: запрос к БД на каждый запрос (можно кэшировать). 4) Refresh Token Revocation: access token short-lived, при отзыве refresh token новые access tokens не выдаются. Компромисс: окно уязвимости = TTL access token. 5) Event-driven invalidation: при logout публикуется событие, все сервисы обновляют локальный blocklist. Компромисс: eventual consistency. Рекомендация: short-lived access token (5 мин) + refresh token revocation + blacklist в Redis для критичных случаев.',
    explanation:
      'Это одна из главных проблем JWT-based аутентификации и частый вопрос на senior-собеседованиях. Не существует идеального решения: каждый подход -- компромисс между statelessness и контролем. На практике комбинация short-lived tokens + server-side refresh tokens покрывает большинство сценариев.',
  },
  {
    id: 'sd-auth-019',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните, как реализовать fine-grained авторизацию в распределённой системе. Сравните подходы: embedded policy, centralized policy engine (OPA), и Google Zanzibar.',
    sampleAnswer:
      'Fine-grained авторизация определяет доступ на уровне отдельных объектов и действий. Подходы: 1) Embedded Policy: логика авторизации встроена в код каждого сервиса (if user.role == "admin"). Плюсы: просто, быстро. Минусы: дублирование, сложно поддерживать консистентность, изменения требуют передеплоя. 2) Centralized Policy Engine (OPA/Open Policy Agent): политики описываются декларативно (язык Rego). Сервисы отправляют запрос к OPA с контекстом (user, resource, action) и получают allow/deny. Плюсы: единые политики, аудит, hot reload без передеплоя. Минусы: latency сетевого вызова (решается sidecar), learning curve Rego. 3) Google Zanzibar (ReBAC -- Relationship-Based Access Control): моделирует авторизацию через граф отношений: user:alice → member → group:engineering → viewer → doc:123. Запрос: «Может ли alice просматривать doc:123?» -- обход графа. Реализации: SpiceDB, Authzed, Ory Keto. Плюсы: естественное моделирование сложных иерархий (Google Drive, GitHub), глобальная консистентность, миллисекундные проверки. Минусы: сложность моделирования, потребность в отдельной инфраструктуре.',
    explanation:
      'Google Zanzibar обслуживает авторизацию для Google Drive, YouTube, Cloud и других продуктов с latency p50 < 10ms при триллионах relationship tuples. Для большинства компаний OPA -- оптимальный баланс между гибкостью и сложностью. Для систем с иерархическими структурами доступа (filesystem, organization hierarchy) Zanzibar-подход наиболее естественен.',
  },
  {
    id: 'sd-auth-020',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход безопаснее всего для хранения токенов на клиенте в веб-приложении?',
    options: [
      'localStorage -- удобно для JavaScript, сохраняется между сессиями',
      'sessionStorage -- автоматически очищается при закрытии вкладки',
      'HttpOnly Secure SameSite cookie -- недоступен JavaScript, защищён от XSS, CSRF и перехвата',
      'URL-параметры -- видны в адресной строке, легко передать между страницами',
    ],
    correctIndex: 2,
    explanation:
      'HttpOnly cookie недоступен из JavaScript (document.cookie), что защищает от XSS-атак (даже если злоумышленник внедрит скрипт, он не получит доступ к токену). Secure flag гарантирует передачу только по HTTPS. SameSite=Strict/Lax предотвращает отправку cookie в cross-site запросах (защита от CSRF). localStorage/sessionStorage уязвимы к XSS: любой JS-код на странице может прочитать их содержимое. URL-параметры видны в логах, истории браузера, Referer-заголовках. Рекомендуемый паттерн: access token в HttpOnly cookie, refresh token с rotation.',
  },
];
