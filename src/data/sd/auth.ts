import type { Question } from '../types';

export const authQuestions: Question[] = [
  {
    id: 'sd-auth-001',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Чем отличается аутентификация от авторизации?',
    options: [
      'Аутентификация проверяет, имеет ли пользователь право на действие; авторизация подтверждает его личность',
      'Аутентификация подтверждает личность пользователя (кто ты); авторизация определяет, какие действия ему разрешены (что ты можешь)',
      'Аутентификация и авторизация -- это синонимы, обозначающие проверку пароля',
      'Аутентификация используется только для API, авторизация -- только для веб-интерфейса',
    ],
    correctIndex: 1,
    explanation:
      'Аутентификация (AuthN) -- процесс подтверждения личности: «Ты действительно тот, за кого себя выдаёшь?». Реализуется через пароли, токены, биометрию, сертификаты. Авторизация (AuthZ) -- процесс проверки прав доступа: «Имеешь ли ты право выполнить это действие?». Реализуется через роли, политики, ACL. Аутентификация всегда предшествует авторизации: сначала система определяет пользователя, затем проверяет его права.',
  },
  {
    id: 'sd-auth-002',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Из каких трёх частей состоит JWT (JSON Web Token)?',
    options: [
      'Username, Password, Signature',
      'Header, Payload, Signature',
      'Token, Refresh Token, Session ID',
      'Issuer, Subject, Audience',
    ],
    correctIndex: 1,
    explanation:
      'JWT состоит из трёх частей, разделённых точками: Header (заголовок) -- содержит тип токена (JWT) и алгоритм подписи (HS256, RS256). Payload (полезная нагрузка) -- содержит claims: стандартные (iss, sub, exp, iat) и пользовательские (role, user_id). Signature (подпись) -- HMAC или RSA-подпись для проверки целостности. Каждая часть кодируется в Base64Url. JWT не шифрован по умолчанию -- payload может быть прочитан любым, но не может быть изменён без знания секрета.',
  },
  {
    id: 'sd-auth-003',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое OAuth 2.0?',
    options: [
      'Протокол аутентификации для проверки логина и пароля пользователя',
      'Протокол авторизации, позволяющий приложению получить ограниченный доступ к ресурсам пользователя на другом сервисе без передачи пароля',
      'Формат токенов для хранения сессий на сервере',
      'Стандарт шифрования данных при передаче по сети',
    ],
    correctIndex: 1,
    explanation:
      'OAuth 2.0 -- протокол авторизации (не аутентификации!), позволяющий третьему приложению получить ограниченный доступ к ресурсам пользователя без раскрытия его учётных данных. Ключевые роли: Resource Owner (пользователь), Client (приложение), Authorization Server (выдаёт токены), Resource Server (хранит ресурсы). OAuth 2.0 выдаёт access token, подтверждающий право доступа. Для аутентификации поверх OAuth используется OpenID Connect.',
  },
  {
    id: 'sd-auth-004',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой OAuth 2.0 flow рекомендуется для SPA (Single Page Application) и мобильных приложений?',
    options: [
      'Implicit Flow',
      'Client Credentials Flow',
      'Authorization Code Flow с PKCE',
      'Resource Owner Password Credentials Flow',
    ],
    correctIndex: 2,
    explanation:
      'Authorization Code Flow с PKCE (Proof Key for Code Exchange) рекомендуется для публичных клиентов (SPA, мобильные приложения), которые не могут безопасно хранить client_secret. PKCE добавляет code_verifier (случайная строка) и code_challenge (её хэш). Клиент отправляет code_challenge при запросе авторизации, а code_verifier -- при обмене кода на токен. Это предотвращает перехват authorization code злоумышленником. Implicit Flow считается устаревшим и небезопасным (токен в URL, нет refresh token).',
  },
  {
    id: 'sd-auth-005',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Чем API-ключ (API key) отличается от access token (например, JWT)?',
    options: [
      'API key идентифицирует приложение (клиента); access token авторизует действия от имени конкретного пользователя',
      'API key и access token -- это одно и то же, просто разные названия',
      'API key безопаснее, так как имеет срок действия, а access token -- нет',
      'API key используется только для аутентификации, а access token -- только для шифрования',
    ],
    correctIndex: 0,
    explanation:
      'API key -- длинная строка, идентифицирующая приложение или проект. Используется для rate limiting, биллинга, базового контроля доступа. Обычно не привязан к конкретному пользователю. Access token (например, JWT) -- токен, выданный после аутентификации пользователя, содержащий информацию о его identity и правах. Имеет срок действия. API keys удобны для server-to-server взаимодействия, но не подходят для пользовательской авторизации, так как не содержат контекста пользователя и scope.',
  },
  {
    id: 'sd-auth-006',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое MFA (Multi-Factor Authentication)?',
    options: [
      'Использование нескольких паролей для входа в систему',
      'Аутентификация с использованием двух или более независимых факторов: знание (пароль), владение (телефон/токен), биометрия (отпечаток)',
      'Шифрование пароля несколькими алгоритмами последовательно',
      'Авторизация пользователя одновременно в нескольких системах',
    ],
    correctIndex: 1,
    explanation:
      'MFA (Multi-Factor Authentication) требует подтверждения личности несколькими независимыми факторами: 1) Something you know -- пароль, PIN. 2) Something you have -- телефон (SMS, TOTP-приложение), аппаратный ключ (YubiKey). 3) Something you are -- биометрия (отпечаток, лицо). Ключевое слово -- «независимые»: два пароля -- это не MFA. TOTP (Time-based One-Time Password, RFC 6238) -- наиболее распространённый второй фактор. FIDO2/WebAuthn -- современный стандарт, устойчивый к фишингу.',
  },
  {
    id: 'sd-auth-007',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой OAuth 2.0 flow используется для межсервисной (machine-to-machine) аутентификации?',
    options: [
      'Authorization Code Flow',
      'Implicit Flow',
      'Client Credentials Flow',
      'Device Authorization Flow',
    ],
    correctIndex: 2,
    explanation:
      'Client Credentials Flow используется, когда клиент действует от своего имени, а не от имени пользователя (machine-to-machine). Клиент отправляет свой client_id и client_secret напрямую Authorization Server и получает access token. Нет этапа перенаправления пользователя. Применяется для: backend-сервис вызывает другой backend-сервис, cron-задачи, CLI-инструменты. Важно: client_secret должен храниться безопасно (environment variables, secrets manager), никогда в коде.',
  },
  {
    id: 'sd-auth-008',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем OpenID Connect (OIDC) отличается от OAuth 2.0?',
    options: [
      'OIDC -- это полная замена OAuth 2.0 с несовместимым протоколом',
      'OIDC -- это надстройка над OAuth 2.0, добавляющая слой аутентификации (ID Token с информацией о пользователе)',
      'OIDC используется только для мобильных приложений, а OAuth -- для веба',
      'OIDC и OAuth 2.0 -- идентичные протоколы разных организаций',
    ],
    correctIndex: 1,
    explanation:
      'OpenID Connect (OIDC) -- это identity layer поверх OAuth 2.0. OAuth 2.0 сам по себе -- протокол авторизации, он не сообщает, КТО пользователь. OIDC добавляет: ID Token (JWT с claims о пользователе: sub, name, email); стандартный /userinfo эндпоинт; стандартные scopes (openid, profile, email); процесс Discovery (.well-known/openid-configuration). Таким образом, OIDC = OAuth 2.0 (авторизация) + ID Token (аутентификация). Google Sign-In, Apple Sign-In, Azure AD используют OIDC.',
  },
  {
    id: 'sd-auth-009',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое PKCE (Proof Key for Code Exchange) и какую атаку он предотвращает?',
    options: [
      'Шифрование токенов на клиентской стороне для защиты от XSS',
      'Защита от перехвата authorization code путём привязки его к конкретному клиенту через code_verifier/code_challenge',
      'Подпись JWT с использованием асимметричной криптографии',
      'Механизм ротации refresh tokens для предотвращения replay-атак',
    ],
    correctIndex: 1,
    explanation:
      'PKCE (RFC 7636) предотвращает атаку перехвата authorization code. Процесс: 1) Клиент генерирует случайный code_verifier. 2) Вычисляет code_challenge = SHA256(code_verifier). 3) Отправляет code_challenge в запросе авторизации. 4) Получает authorization code. 5) При обмене code на token отправляет code_verifier. 6) Authorization Server проверяет: SHA256(code_verifier) == code_challenge. Даже если злоумышленник перехватит authorization code (через custom URL scheme, redirect), он не сможет обменять его на токен без code_verifier.',
  },
  {
    id: 'sd-auth-010',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем RBAC отличается от ABAC?',
    options: [
      'RBAC назначает права на основе ролей пользователя; ABAC принимает решения на основе атрибутов пользователя, ресурса, окружения и действия',
      'RBAC используется для API, а ABAC -- для баз данных',
      'RBAC -- это устаревший подход, ABAC -- его прямая замена',
      'RBAC обеспечивает доступ на уровне строк, ABAC -- на уровне таблиц',
    ],
    correctIndex: 0,
    explanation:
      'RBAC (Role-Based Access Control): пользователю назначаются роли (admin, editor, viewer), каждая роль имеет набор permissions. Просто в реализации и понимании, но негибкий при сложных правилах. ABAC (Attribute-Based Access Control): решение принимается на основе политик, учитывающих атрибуты субъекта (department, clearance level), объекта (classification, owner), действия (read, write) и контекста (время суток, IP-адрес). Пример: «Доктор может читать медкарту пациента из своего отделения в рабочее время». RBAC не может выразить такое правило без создания множества ролей.',
  },
  {
    id: 'sd-auth-011',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Как работает SSO (Single Sign-On) на базе SAML 2.0?',
    options: [
      'Пользователь вводит пароль в каждом приложении, но пароль одинаковый',
      'Пользователь аутентифицируется один раз в Identity Provider (IdP), и IdP передаёт SAML Assertion (XML-документ с подписью) приложениям (Service Providers) для подтверждения личности',
      'Все приложения используют общую базу данных пользователей и проверяют пароль напрямую',
      'Пользователь получает единый JWT-токен, который работает во всех приложениях',
    ],
    correctIndex: 1,
    explanation:
      'SAML 2.0 SSO: 1) Пользователь обращается к Service Provider (SP). 2) SP перенаправляет на Identity Provider (IdP) с SAML AuthnRequest. 3) IdP аутентифицирует пользователя (если ещё не аутентифицирован). 4) IdP создаёт SAML Assertion -- XML-документ с информацией о пользователе, подписанный цифровой подписью IdP. 5) IdP перенаправляет пользователя обратно на SP с SAML Response. 6) SP проверяет подпись и извлекает данные пользователя. При обращении к другому SP шаги 1-2 повторяются, но шаг 3 пропускается (IdP уже имеет сессию).',
  },
  {
    id: 'sd-auth-012',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Опишите стратегию refresh token rotation. Почему она важна и как реализуется?',
    sampleAnswer:
      'Refresh Token Rotation -- стратегия, при которой каждый раз при использовании refresh token выдаётся новый refresh token, а старый инвалидируется. Процесс: 1) Клиент отправляет refresh token на /token эндпоинт. 2) Authorization Server проверяет refresh token, выдаёт новый access token и НОВЫЙ refresh token. 3) Старый refresh token помечается как использованный. 4) Если кто-то попытается использовать старый (уже использованный) refresh token, это сигнал о компрометации: сервер инвалидирует ВСЮ цепочку токенов (включая текущий активный refresh token), вынуждая пользователя пройти аутентификацию заново. Это значительно снижает окно уязвимости при утечке refresh token. RFC 6819 и OAuth 2.0 Security Best Current Practice рекомендуют rotation для публичных клиентов.',
    explanation:
      'Без rotation украденный refresh token можно использовать неограниченное время (до истечения). С rotation: если токен украден, либо легитимный пользователь, либо злоумышленник использует его первым. Второе использование триггерит automatic reuse detection и полную инвалидацию. Auth0, Okta и другие провайдеры поддерживают refresh token rotation из коробки.',
  },
  {
    id: 'sd-auth-013',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Сравните хранение сессий на сервере (server-side sessions) и stateless-подход с JWT. Какие у каждого преимущества и недостатки?',
    sampleAnswer:
      'Server-side sessions: сервер хранит состояние сессии (в памяти, Redis, БД), клиент получает session ID в cookie. Плюсы: легко инвалидировать (удалить сессию), малый размер cookie, данные сессии не видны клиенту. Минусы: требует shared storage при нескольких серверах (sticky sessions или Redis), дополнительный запрос к хранилищу на каждый запрос, сложнее масштабировать. JWT (stateless): токен содержит все claims, сервер не хранит состояние. Плюсы: не нужно shared storage, отлично масштабируется, работает across domains. Минусы: нельзя инвалидировать до истечения (нужен blocklist), больший размер (передаётся в каждом запросе), payload видна клиенту (Base64, не шифрование), при добавлении claims размер растёт. На практике часто комбинируют: short-lived JWT (5-15 мин) + server-side refresh token.',
    explanation:
      'Вопрос «JWT vs Sessions» -- один из самых частых на собеседованиях. Ключевое различие -- в управлении состоянием. Для микросервисов JWT удобнее (каждый сервис валидирует подпись без обращения к централизованному хранилищу). Для монолитов server-side sessions проще и безопаснее. Гибридный подход -- наиболее практичный.',
  },
  {
    id: 'sd-auth-014',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое passwordless authentication? Опишите основные подходы и их преимущества.',
    sampleAnswer:
      'Passwordless authentication -- аутентификация без пароля, использующая альтернативные факторы. Основные подходы: 1) Magic Link -- одноразовая ссылка отправляется на email. Пользователь кликает -- аутентифицирован. Просто, но зависит от безопасности email. 2) WebAuthn/FIDO2 -- аутентификация через аппаратные ключи (YubiKey) или платформенные аутентификаторы (Touch ID, Windows Hello). Самый безопасный вариант, устойчив к фишингу. 3) OTP через SMS/email -- одноразовый код. Менее безопасен (SIM swapping, перехват SMS). 4) Passkeys -- развитие WebAuthn, синхронизируемые между устройствами через iCloud Keychain / Google Password Manager. Преимущества passwordless: нет паролей для кражи/утечки, устойчивость к фишингу (WebAuthn), лучший UX (не нужно запоминать пароли), снижение нагрузки на поддержку (сброс паролей).',
    explanation:
      'Apple, Google и Microsoft совместно продвигают Passkeys как замену паролям. NIST рекомендует отказ от SMS OTP в пользу TOTP и FIDO2. Passwordless -- тренд, значительно повышающий безопасность, так как большинство атак (credential stuffing, phishing) эксплуатируют слабые или украденные пароли.',
  },
  {
    id: 'sd-auth-015',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой алгоритм подписи JWT предпочтителен в микросервисной архитектуре, где множество сервисов должны валидировать токен?',
    options: [
      'HS256 (HMAC с общим секретом) -- все сервисы используют один secret',
      'RS256 (RSA) -- Authorization Server подписывает приватным ключом, сервисы проверяют публичным ключом через JWKS endpoint',
      'none (без подписи) -- для ускорения валидации',
      'AES256 -- симметричное шифрование payload',
    ],
    correctIndex: 1,
    explanation:
      'RS256 (RSA-SHA256) использует асимметричную криптографию: Authorization Server подписывает JWT приватным ключом, который хранится только у него. Все Resource Servers проверяют подпись с помощью публичного ключа, доступного через JWKS (JSON Web Key Set) endpoint (/.well-known/jwks.json). Преимущества: компрометация одного сервиса не позволяет подделать токен; публичный ключ можно безопасно распространять; поддерживается key rotation через kid (Key ID) в заголовке JWT. HS256 требует передачи общего секрета всем сервисам, что создаёт один общий point of failure.',
  },
  {
    id: 'sd-auth-016',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какая атака на JWT возможна при неправильной валидации заголовка alg?',
    options: [
      'SQL Injection через payload JWT',
      'Атакующий устанавливает alg: "none" и удаляет подпись, обходя проверку',
      'DDoS-атака через генерацию большого количества токенов',
      'Man-in-the-middle через подмену refresh token',
    ],
    correctIndex: 1,
    explanation:
      'Атака «alg: none»: если сервер доверяет значению alg из заголовка JWT, злоумышленник может установить «alg: "none"», удалить подпись и получить валидный токен. Ещё одна атака: «algorithm confusion» -- при RS256 сервер проверяет подпись публичным ключом; злоумышленник меняет alg на HS256 и подписывает токен публичным ключом (который общедоступен) как HMAC-секретом. Защита: ВСЕГДА явно указывать ожидаемый алгоритм на сервере (whitelist), НИКОГДА не полагаться на значение alg из токена.',
  },
  {
    id: 'sd-auth-017',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Спроектируйте систему аутентификации и авторизации для микросервисной платформы. Опишите выбор протоколов, управление токенами и проверку прав доступа.',
    sampleAnswer:
      'Архитектура: 1) Централизованный Identity Provider (Keycloak/Auth0): поддерживает OIDC, хранит пользователей, роли, permissions. 2) API Gateway как точка входа: валидирует JWT (проверка подписи RS256, exp, iss, aud), извлекает claims, пробрасывает user context в заголовках downstream-сервисам. 3) Токены: short-lived access token (JWT, 5-15 мин) с claims (sub, roles, permissions); long-lived refresh token (opaque, хранится в БД IdP) с rotation. 4) Авторизация: грубая (coarse-grained) на API Gateway по roles из JWT; тонкая (fine-grained) в каждом сервисе по permissions и бизнес-правилам (ABAC). 5) Service-to-service: Client Credentials Flow, mutual TLS или service mesh (Istio). 6) Token introspection endpoint для проверки активности opaque tokens. 7) JWKS endpoint с key rotation (kid header). 8) Blacklist в Redis для инвалидации JWT до истечения (для logout, смены пароля). 9) Rate limiting на /token endpoint против brute force.',
    explanation:
      'Ключевой принцип: «never trust, always verify». Каждый микросервис должен независимо валидировать JWT, а не полагаться только на API Gateway. Для критичных операций (перевод денег) может потребоваться step-up authentication -- повторный запрос второго фактора.',
  },
  {
    id: 'sd-auth-018',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Как безопасно реализовать инвалидацию JWT до истечения срока действия? Опишите подходы и их компромиссы.',
    sampleAnswer:
      'Проблема: JWT stateless -- сервер не хранит состояние, поэтому не может «отозвать» выданный токен. Подходы: 1) Short-lived tokens (5-15 мин): уменьшает окно уязвимости, но не решает проблему полностью. При logout токен живёт ещё 5-15 минут. 2) Token Blacklist (deny list): при logout/смене пароля jti (JWT ID) добавляется в Redis/in-memory store. Каждый запрос проверяет blacklist. Компромисс: вводит stateful-проверку, нагрузка на Redis, нужна синхронизация между инстансами. 3) Token Versioning: в БД хранится token_version для пользователя. JWT содержит version claim. При необходимости инвалидации version увеличивается. Компромисс: запрос к БД на каждый запрос (можно кэшировать). 4) Refresh Token Revocation: access token short-lived, при отзыве refresh token новые access tokens не выдаются. Компромисс: окно уязвимости = TTL access token. 5) Event-driven invalidation: при logout публикуется событие, все сервисы обновляют локальный blocklist. Компромисс: eventual consistency. Рекомендация: short-lived access token (5 мин) + refresh token revocation + blacklist в Redis для критичных случаев.',
    explanation:
      'Это одна из главных проблем JWT-based аутентификации и частый вопрос на senior-собеседованиях. Не существует идеального решения: каждый подход -- компромисс между statelessness и контролем. На практике комбинация short-lived tokens + server-side refresh tokens покрывает большинство сценариев.',
  },
  {
    id: 'sd-auth-019',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните, как реализовать fine-grained авторизацию в распределённой системе. Сравните подходы: embedded policy, centralized policy engine (OPA), и Google Zanzibar.',
    sampleAnswer:
      'Fine-grained авторизация определяет доступ на уровне отдельных объектов и действий. Подходы: 1) Embedded Policy: логика авторизации встроена в код каждого сервиса (if user.role == "admin"). Плюсы: просто, быстро. Минусы: дублирование, сложно поддерживать консистентность, изменения требуют передеплоя. 2) Centralized Policy Engine (OPA/Open Policy Agent): политики описываются декларативно (язык Rego). Сервисы отправляют запрос к OPA с контекстом (user, resource, action) и получают allow/deny. Плюсы: единые политики, аудит, hot reload без передеплоя. Минусы: latency сетевого вызова (решается sidecar), learning curve Rego. 3) Google Zanzibar (ReBAC -- Relationship-Based Access Control): моделирует авторизацию через граф отношений: user:alice → member → group:engineering → viewer → doc:123. Запрос: «Может ли alice просматривать doc:123?» -- обход графа. Реализации: SpiceDB, Authzed, Ory Keto. Плюсы: естественное моделирование сложных иерархий (Google Drive, GitHub), глобальная консистентность, миллисекундные проверки. Минусы: сложность моделирования, потребность в отдельной инфраструктуре.',
    explanation:
      'Google Zanzibar обслуживает авторизацию для Google Drive, YouTube, Cloud и других продуктов с latency p50 < 10ms при триллионах relationship tuples. Для большинства компаний OPA -- оптимальный баланс между гибкостью и сложностью. Для систем с иерархическими структурами доступа (filesystem, organization hierarchy) Zanzibar-подход наиболее естественен.',
  },
  {
    id: 'sd-auth-020',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой подход безопаснее всего для хранения токенов на клиенте в веб-приложении?',
    options: [
      'localStorage -- удобно для JavaScript, сохраняется между сессиями',
      'sessionStorage -- автоматически очищается при закрытии вкладки',
      'HttpOnly Secure SameSite cookie -- недоступен JavaScript, защищён от XSS, CSRF и перехвата',
      'URL-параметры -- видны в адресной строке, легко передать между страницами',
    ],
    correctIndex: 2,
    explanation:
      'HttpOnly cookie недоступен из JavaScript (document.cookie), что защищает от XSS-атак (даже если злоумышленник внедрит скрипт, он не получит доступ к токену). Secure flag гарантирует передачу только по HTTPS. SameSite=Strict/Lax предотвращает отправку cookie в cross-site запросах (защита от CSRF). localStorage/sessionStorage уязвимы к XSS: любой JS-код на странице может прочитать их содержимое. URL-параметры видны в логах, истории браузера, Referer-заголовках. Рекомендуемый паттерн: access token в HttpOnly cookie, refresh token с rotation.',
  },
  {
    id: 'sd-auth-021',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Zero Trust Security и каков его основной принцип?',
    options: [
      'Модель безопасности, где внутренняя сеть считается полностью защищённой',
      'Модель безопасности, где ни один пользователь или система не получает автоматического доверия, и каждый запрос должен быть аутентифицирован и авторизован',
      'Технология шифрования данных в состоянии покоя',
      'Метод защиты от DDoS-атак',
    ],
    correctIndex: 1,
    explanation:
      'Zero Trust -- модель безопасности с принципом "никогда не доверяй, всегда проверяй" (never trust, always verify). В отличие от периметровой безопасности (castle-and-moat), где внутренняя сеть считается доверенной, Zero Trust требует: аутентификации и авторизации каждого запроса, микросегментации сети, минимальных привилегий (least privilege), непрерывного мониторинга. Реализация: mTLS между сервисами, identity-based access вместо network-based, MFA везде.',
  },
  {
    id: 'sd-auth-022',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Identity Provider (IdP)?',
    options: [
      'База данных для хранения паролей пользователей',
      'Сервис, который аутентифицирует пользователей и выдаёт токены или утверждения (assertions) для доступа к другим сервисам',
      'Прокси-сервер для защиты API',
      'Инструмент для генерации API-ключей',
    ],
    correctIndex: 1,
    explanation:
      'Identity Provider (IdP) -- централизованный сервис управления идентификацией. Функции: хранение учётных данных, аутентификация пользователей, выдача токенов (OAuth 2.0) или assertions (SAML), управление пользователями и группами, MFA. Примеры: Okta, Auth0, Azure AD, Keycloak (open-source), Google Identity. IdP отделяет логику аутентификации от приложений -- приложения доверяют токенам IdP, не храня пароли.',
  },
  {
    id: 'sd-auth-023',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой HTTP-заголовок используется для передачи Bearer token в API-запросах?',
    options: [
      'X-API-Key',
      'Authorization: Bearer <token>',
      'Cookie: token=<token>',
      'X-Auth-Token',
    ],
    correctIndex: 1,
    explanation:
      'Authorization header с Bearer scheme -- стандартный способ передачи access token (RFC 6750). Формат: Authorization: Bearer eyJhbGciOiJIUzI1NiIs... Bearer token обычно JWT, но может быть opaque. Преимущества: стандартизирован, работает cross-domain (в отличие от cookies), явно указывает тип авторизации. X-API-Key используется для API-ключей (идентификация приложения), Cookie -- для session-based auth.',
  },
  {
    id: 'sd-auth-024',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое CORS и как он связан с безопасностью аутентификации?',
    sampleAnswer:
      'CORS (Cross-Origin Resource Sharing) -- механизм браузера, контролирующий доступ к ресурсам с других origins (domain + protocol + port). Без CORS браузер блокирует cross-origin запросы из JavaScript. Для аутентификации: если frontend (app.example.com) обращается к API (api.example.com), сервер должен вернуть CORS-заголовки: Access-Control-Allow-Origin, Access-Control-Allow-Credentials: true (для cookies). Безопасность: неправильная настройка CORS может позволить злоумышленнику с вредоносного сайта отправлять запросы к API от имени пользователя. Рекомендации: whitelist разрешённых origins (не *), не использовать Access-Control-Allow-Credentials с wildcard origin.',
    explanation:
      'CORS -- частая причина проблем при разработке SPA с отдельным API. Preflight запросы (OPTIONS) добавляют latency. Для credentials (cookies, Authorization header) требуется явное Access-Control-Allow-Credentials: true и конкретный origin (не *).',
  },
  {
    id: 'sd-auth-025',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Identity Federation и какую проблему она решает?',
    options: [
      'Объединение нескольких баз данных пользователей в одну',
      'Возможность использовать учётные данные из одной системы для доступа к другой без создания новой учётной записи, через доверительные отношения между IdP',
      'Шифрование идентификационных данных при передаче',
      'Репликация пользователей между дата-центрами',
    ],
    correctIndex: 1,
    explanation:
      'Identity Federation позволяет пользователям аутентифицироваться в одной системе (home IdP) и получать доступ к ресурсам другой системы (service provider) без создания отдельной учётной записи. Примеры: вход в корпоративные приложения через Azure AD, вход в SaaS через Google/Okta, B2B интеграции. Протоколы: SAML 2.0, OIDC, WS-Federation. Преимущества: SSO, централизованное управление, onboarding/offboarding в одном месте. Trust устанавливается через обмен сертификатами/metadata.',
  },
  {
    id: 'sd-auth-026',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое scope в OAuth 2.0?',
    options: [
      'Время жизни access token',
      'Географический регион, где токен действителен',
      'Набор разрешений, определяющий, к каким ресурсам и действиям клиент запрашивает доступ',
      'Идентификатор приложения в OAuth',
    ],
    correctIndex: 2,
    explanation:
      'Scope -- механизм ограничения доступа в OAuth 2.0. Клиент запрашивает scopes при авторизации, пользователь подтверждает согласие, токен содержит granted scopes. Примеры: openid (OIDC identity), profile (имя, фото), email, read:users, write:posts. Principle of least privilege: запрашивать только необходимые scopes. Resource server проверяет scopes в токене перед выполнением операции. Scopes позволяют granular control: приложение может читать email, но не отправлять.',
  },
  {
    id: 'sd-auth-027',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Чем API Gateway аутентификация отличается от аутентификации в каждом микросервисе?',
    options: [
      'API Gateway аутентификация медленнее',
      'API Gateway валидирует токен централизованно на входе и передаёт identity context downstream, избегая дублирования логики в каждом сервисе',
      'Микросервисы не могут валидировать токены',
      'API Gateway поддерживает только API keys',
    ],
    correctIndex: 1,
    explanation:
      'Централизованная аутентификация на API Gateway: Gateway валидирует JWT (проверяет подпись, exp, iss, aud), извлекает claims (user_id, roles) и передаёт их downstream сервисам в заголовках (X-User-ID, X-User-Roles). Преимущества: единая точка валидации, упрощение микросервисов, централизованное управление ключами (JWKS). Однако каждый микросервис должен независимо проверять авторизацию (может ли user_id выполнить действие над ресурсом). Zero Trust рекомендует re-validate token в каждом сервисе.',
  },
  {
    id: 'sd-auth-028',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Как защитить API от credential stuffing атак?',
    sampleAnswer:
      'Credential stuffing -- автоматическое тестирование украденных пар login/password на множестве сервисов. Защита: 1) Rate limiting на /login endpoint: лимит попыток по IP и по username. 2) Account lockout: временная блокировка после N неудачных попыток (с уведомлением пользователя). 3) CAPTCHA: после нескольких неудач или при подозрительной активности (reCAPTCHA v3 invisible). 4) MFA: даже при утечке пароля второй фактор защищает. 5) Bot detection: анализ fingerprint, поведения, headless browser detection. 6) Passwordless: magic link, WebAuthn устраняют пароли. 7) Breach password check: проверка пароля через haveibeenpwned API при регистрации/смене. 8) Device fingerprinting: алерт при входе с нового устройства. Мониторинг: отслеживание failed login rate, географии входов.',
    explanation:
      'Credential stuffing -- одна из самых распространённых атак. По данным Akamai, до 90% login-трафика на некоторых сайтах -- credential stuffing боты. Комбинация rate limiting + MFA + bot detection значительно снижает success rate атаки.',
  },
  {
    id: 'sd-auth-029',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните концепцию least privilege (минимальных привилегий) в контексте авторизации. Как её применить на практике?',
    sampleAnswer:
      'Principle of Least Privilege (PoLP): пользователь или система должны иметь только минимально необходимые права для выполнения своих задач. Применение: 1) RBAC с granular roles: вместо "admin" -- "billing_admin", "user_admin", "content_editor". 2) Service accounts: каждый микросервис имеет свой service account с минимальными правами (read-only к нужным ресурсам). 3) Temporary credentials: AWS IAM roles вместо long-lived keys. 4) Just-in-time access: права выдаются на время выполнения задачи (PIM в Azure AD). 5) Scope в OAuth: запрашивать только нужные scopes. 6) Database: отдельные users с правами только на свои таблицы. 7) Infrastructure as Code: ревью изменений в permissions. Мониторинг: unused permissions, access patterns. Регулярный audit: ревью и отзыв неиспользуемых прав.',
    explanation:
      'PoLP -- фундаментальный принцип безопасности, снижающий blast radius при компрометации. AWS рекомендует IAM Access Analyzer для выявления overly permissive policies. Сложность: баланс между безопасностью и удобством, управление at scale.',
  },
  {
    id: 'sd-auth-030',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое API Security и какие основные угрозы для API существуют?',
    options: [
      'Защита исходного кода API от копирования',
      'Комплекс мер защиты API от атак: authentication, authorization, input validation, rate limiting, защита от OWASP API Security Top 10',
      'Шифрование всех API-ответов',
      'Использование только внутренних IP для API',
    ],
    correctIndex: 1,
    explanation:
      'API Security включает защиту от угроз OWASP API Security Top 10: Broken Object Level Authorization (BOLA/IDOR), Broken Authentication, Excessive Data Exposure, Lack of Resources & Rate Limiting, Broken Function Level Authorization, Mass Assignment, Security Misconfiguration, Injection, Improper Assets Management, Insufficient Logging & Monitoring. Меры защиты: строгая аутентификация (OAuth 2.0), granular authorization (проверка ownership), input validation, rate limiting, WAF, мониторинг аномалий, API gateway для централизованной защиты.',
  },
  {
    id: 'sd-auth-031',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое BOLA (Broken Object Level Authorization) и как от неё защититься?',
    options: [
      'Уязвимость в криптографических алгоритмах',
      'Уязвимость, когда API не проверяет, имеет ли пользователь доступ к конкретному объекту, позволяя получить чужие данные через манипуляцию ID',
      'Атака на DNS-записи',
      'Проблема с балансировкой нагрузки',
    ],
    correctIndex: 1,
    explanation:
      'BOLA (также IDOR -- Insecure Direct Object References) -- #1 в OWASP API Security Top 10. Пример: GET /api/users/123/orders -- если API не проверяет, что текущий пользователь = 123, атакующий может получить заказы любого пользователя, меняя ID. Защита: 1) Всегда проверять ownership объекта (order.user_id == current_user.id). 2) Использовать непредсказуемые ID (UUID вместо sequential). 3) Authorization checks в каждом endpoint, не только authentication. 4) Автоматизированные тесты на BOLA. 5) API Gateway policies для проверки.',
  },
  {
    id: 'sd-auth-032',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Как реализовать secure token storage на мобильных устройствах?',
    options: [
      'Хранить токены в SharedPreferences / UserDefaults в открытом виде',
      'Использовать platform-specific secure storage: Android Keystore / iOS Keychain с биометрической защитой',
      'Хранить токены в локальной SQLite базе',
      'Отправлять токен на сервер и запрашивать при каждом запуске',
    ],
    correctIndex: 1,
    explanation:
      'Secure token storage на мобильных: Android: Keystore System -- hardware-backed хранилище для криптографических ключей. EncryptedSharedPreferences использует ключи из Keystore. iOS: Keychain Services -- secure enclave для хранения credentials. Атрибуты: kSecAttrAccessibleWhenUnlocked (доступ только при разблокированном устройстве), биометрическая защита (Face ID/Touch ID для доступа к элементу). Дополнительно: device binding (токен привязан к device ID), certificate pinning для защиты от MITM, jailbreak/root detection.',
  },
  {
    id: 'sd-auth-033',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите архитектуру системы аутентификации для compliance требований (SOC 2, HIPAA). Какие контроли необходимы?',
    sampleAnswer:
      'Compliance требования к аутентификации: 1) Strong authentication: MFA обязательна для всех пользователей (особенно для доступа к PHI в HIPAA). 2) Audit logging: логирование всех authentication events (login, logout, failed attempts, MFA events) с retention согласно политике (SOC 2 обычно 1 год). 3) Password policies: минимальная длина, complexity, rotation (хотя NIST 800-63 не рекомендует принудительную rotation), проверка на breached passwords. 4) Session management: timeout, concurrent session limits, secure logout. 5) Access reviews: периодический audit прав доступа, удаление неактивных аккаунтов. 6) Encryption: TLS 1.2+ для передачи, hashing паролей (bcrypt/Argon2). 7) Break-glass procedures: документированный emergency access. 8) Segregation of duties: разделение admin прав. Инструменты: IdP с compliance certifications (Okta, Azure AD), SIEM для audit logs.',
    explanation:
      'SOC 2 Type II требует демонстрации работы контролей в течение периода (обычно 6-12 месяцев). HIPAA требует защиты PHI (Protected Health Information) с документированными policies. Compliance -- не checkbox, а continuous process с регулярными audits.',
  },
  {
    id: 'sd-auth-034',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать secure service-to-service authentication в микросервисной архитектуре?',
    sampleAnswer:
      'Подходы к service-to-service auth: 1) mTLS (mutual TLS): каждый сервис имеет сертификат, выданный internal CA. При соединении обе стороны верифицируют сертификаты. Service mesh (Istio) автоматизирует выдачу и ротацию сертификатов через sidecar. 2) JWT с service identity: каждый сервис имеет свой client credentials (client_id/client_secret), получает JWT от IdP, передаёт в Authorization header. 3) API keys с HMAC signing: request signing с shared secret для integrity и authentication. 4) SPIFFE/SPIRE: открытый стандарт для service identity. SPIFFE ID (spiffe://trust-domain/workload-id), SPIRE выдаёт x509 SVID или JWT SVID. Рекомендации: mTLS для network-level security + JWT для application-level authorization (claims с permissions). Zero Trust: не доверять network location, всегда проверять identity.',
    explanation:
      'Service mesh с mTLS стал стандартом для Kubernetes. SPIFFE обеспечивает interoperability между разными системами. Важно: ротация secrets и certificates автоматизирована, человеческий фактор минимизирован.',
  },
  {
    id: 'sd-auth-035',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните концепцию Policy as Code для авторизации. Сравните OPA и Cedar.',
    sampleAnswer:
      'Policy as Code: авторизационные правила описываются в декларативном языке, версионируются, тестируются, деплоятся как код. OPA (Open Policy Agent): язык Rego, универсальный (Kubernetes admission, API authorization, Terraform). Пример: allow { input.user.role == "admin" }. Decoupled: политики отдельно от приложения, OPA как sidecar или remote service. Cedar (AWS): типизированный язык, разработан для AWS Verified Permissions. Пример: permit(principal, action, resource) when { principal.role == "admin" }. Сильная типизация, встроенная поддержка hierarchies. Сравнение: OPA -- mature, широкая экосистема, универсальный. Cedar -- новее, лучший DX для authorization-specific use cases, AWS-native интеграция. Оба поддерживают: unit testing политик, explain (почему decision), audit logging.',
    explanation:
      'Policy as Code -- эволюция от hardcoded authorization. Преимущества: single source of truth, git history для audit, consistent enforcement, testability. Netflix, Airbnb используют OPA для API authorization. AWS продвигает Cedar как часть Verified Permissions service.',
  },
  {
    id: 'sd-auth-036',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое session fixation атака и как от неё защититься?',
    options: [
      'Атака, при которой злоумышленник фиксирует курс валют',
      'Атака, при которой злоумышленник устанавливает жертве известный session ID до аутентификации, а затем использует этот ID для доступа к аккаунту',
      'Атака на базу данных сессий',
      'DDoS-атака на session storage',
    ],
    correctIndex: 1,
    explanation:
      'Session fixation: 1) Атакующий получает session ID (создаёт сессию на сайте). 2) Заставляет жертву аутентифицироваться с этим session ID (через URL параметр или cookie injection). 3) После аутентификации жертвы атакующий использует тот же session ID. Защита: regenerate session ID при login (создавать новый session после успешной аутентификации), не принимать session ID из URL параметров, установить httpOnly и secure flags на session cookie, привязать session к IP/User-Agent (с осторожностью -- может ломать легитимные сценарии).',
  },
  {
    id: 'sd-auth-037',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'open',
    question: 'Как безопасно хранить пароли пользователей? Объясните принципы хеширования паролей.',
    sampleAnswer:
      'Принципы хранения паролей: 1) Никогда не хранить в открытом виде или с reversible encryption. 2) Использовать специализированные password hashing функции: bcrypt, Argon2, scrypt. НЕ использовать MD5, SHA-1, SHA-256 без salt и key stretching. 3) Salt: уникальная случайная строка для каждого пароля, хранится вместе с хешем. Предотвращает rainbow table атаки. 4) Work factor / iterations: bcrypt cost, Argon2 memory/time. Замедляет brute-force. Настройка: хеширование должно занимать ~100-500ms. 5) Pepper: секретный ключ, общий для всех паролей, хранится отдельно от БД (HSM, environment variable). Добавляет defence-in-depth при утечке БД. Современный стандарт: Argon2id (winner Password Hashing Competition). Bcrypt -- проверенный временем вариант. Регулярно увеличивать work factor с ростом вычислительных мощностей.',
    explanation:
      'Правильное хеширование паролей -- базовый hygiene. LinkedIn leak (2012) использовал unsalted SHA-1 -- миллионы паролей были взломаны. Argon2 рекомендован OWASP. Bcrypt с cost 12+ -- хороший default.',
  },
  {
    id: 'sd-auth-038',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Device Authorization Grant (Device Flow) в OAuth 2.0?',
    options: [
      'Flow для авторизации мобильных устройств',
      'Flow для устройств с ограниченными возможностями ввода (Smart TV, CLI, IoT), где пользователь авторизуется на другом устройстве по коду',
      'Авторизация с использованием биометрии устройства',
      'Регистрация устройства в MDM системе',
    ],
    correctIndex: 1,
    explanation:
      'Device Authorization Grant (RFC 8628): для устройств без браузера или удобного ввода (TV приложения, CLI, IoT). Процесс: 1) Устройство запрашивает device_code и user_code у Authorization Server. 2) Показывает user_code и URL (например, https://example.com/activate). 3) Пользователь на телефоне/компьютере переходит по URL, вводит код, авторизуется. 4) Устройство периодически опрашивает (polling) Authorization Server. 5) После авторизации пользователем, устройство получает access token. Используется: GitHub CLI, Netflix на TV, AWS CLI.',
  },
  {
    id: 'sd-auth-039',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Token Binding и какую проблему он решает?',
    options: [
      'Привязка токена к конкретному TLS-соединению для предотвращения replay атак при утечке токена',
      'Связывание нескольких токенов в один',
      'Шифрование токена перед передачей',
      'Автоматическое обновление токена',
    ],
    correctIndex: 0,
    explanation:
      'Token Binding (RFC 8471) -- механизм привязки токена к TLS connection через криптографическую связь. Если токен украден, он бесполезен без приватного ключа TLS. Как работает: клиент генерирует key pair, публичный ключ включается в TLS handshake (Token Binding ID), токен содержит hash этого ID. Сервер проверяет, что токен был выдан для этого конкретного TLS соединения. Проблема: ограниченная поддержка браузерами (Chrome убрал поддержку). Альтернатива: DPoP (Demonstrating Proof of Possession) -- подписывание запросов приватным ключом клиента.',
  },
  {
    id: 'sd-auth-040',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Как реализовать impersonation (действие от имени другого пользователя) для support-команды безопасно?',
    sampleAnswer:
      'Impersonation (su, acting as) -- функция для support/admin доступа к аккаунту пользователя. Безопасная реализация: 1) Strict authorization: только определённые роли (support_admin), with approval workflow для sensitive accounts. 2) Audit trail: логирование всех действий с пометкой impersonation (actor_id + target_user_id), отображение в audit log пользователя. 3) Limited scope: impersonator видит данные, но не может менять пароль, MFA, billing. 4) Visual indicator: UI показывает "Viewing as user X" banner, предотвращая случайные действия. 5) Time-limited: сессия impersonation автоматически истекает (30 мин). 6) Notification: email пользователю о факте impersonation (опционально). 7) Токен: отдельный impersonation token с claims {sub: admin_id, act: {sub: user_id}} или JWT with actor claim. 8) Disable for sensitive accounts: VIP, admin аккаунты защищены от impersonation.',
    explanation:
      'Impersonation -- необходимая функция для support, но высокорисковая. Без proper controls злоупотребления неизбежны. Stripe, GitHub документируют свои impersonation practices. GDPR требует logging доступа к personal data.',
  },
  {
    id: 'sd-auth-041',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Verifiable Credentials и как они связаны с децентрализованной идентификацией?',
    options: [
      'Credentials, проверяемые через blockchain',
      'W3C стандарт для цифровых удостоверений, которые можно криптографически верифицировать, выданы issuer, хранятся у holder и предъявляются verifier',
      'Многофакторная аутентификация',
      'Биометрические данные для аутентификации',
    ],
    correctIndex: 1,
    explanation:
      'Verifiable Credentials (W3C стандарт) -- модель для цифровых удостоверений. Участники: Issuer (выдаёт credential, например, университет -- диплом), Holder (хранит в wallet, контролирует), Verifier (проверяет подлинность). Credential содержит claims, подписанные issuer. Holder может selective disclosure -- показать только нужные claims (возраст > 18 без даты рождения). Связано с DID (Decentralized Identifiers) -- идентификаторы, не зависящие от central authority. Применение: digital identity, education credentials, healthcare records. Microsoft Entra Verified ID, IBM Digital Health Pass -- примеры реализации.',
  },
  {
    id: 'sd-auth-042',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать step-up authentication для критичных операций?',
    sampleAnswer:
      'Step-up authentication -- повторная или усиленная аутентификация для высокорисковых действий (перевод денег, смена пароля, доступ к PII). Реализация: 1) Risk assessment: определить, какие операции требуют step-up (risk-based). 2) Authentication Context (acr claim): JWT содержит level of assurance (loa). Уровни: password only (loa1), password + TOTP (loa2), hardware key (loa3). 3) При запросе критичной операции: backend проверяет acr в токене. Если недостаточен, возвращает 403 с требованием step-up. 4) Frontend перенаправляет на re-authentication с required acr. 5) После step-up: выдаётся токен с повышенным acr и коротким TTL (5-10 минут). 6) Audit: логирование всех step-up events. Пример flow: пользователь залогинен с паролем (acr: pwd), хочет перевести деньги → требуется acr: mfa → вводит TOTP → получает short-lived token с acr: mfa → выполняет перевод.',
    explanation:
      'Step-up auth -- баланс между UX и безопасностью. Не требовать MFA для каждого действия, но защитить критичные. OIDC spec включает acr_values для запроса specific authentication level. Банковские приложения используют step-up extensively.',
  },
  {
    id: 'sd-auth-043',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите best practices для управления secrets (API keys, credentials) в приложениях.',
    sampleAnswer:
      'Secrets management best practices: 1) Никогда в коде/git: использовать .gitignore, pre-commit hooks (git-secrets), scan repositories (truffleHog, GitGuardian). 2) Environment variables: basic approach, но видны в process list. 3) Secrets managers: HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, GCP Secret Manager. Централизованное хранение, доступ через API, audit logging. 4) Rotation: автоматическая ротация secrets (Vault dynamic secrets, AWS automatic rotation). 5) Least privilege: каждый сервис получает только свои secrets. 6) Encryption at rest и in transit. 7) Short-lived credentials: temporary tokens вместо long-lived keys (AWS IAM roles, Vault dynamic database credentials). 8) Kubernetes: Secrets (base64, не шифрование!), лучше External Secrets Operator + Vault. 9) CI/CD: dedicated secrets management (GitHub Secrets, GitLab CI variables, HashiCorp Vault). Никогда не логировать secrets.',
    explanation:
      'Утечка secrets -- одна из самых частых причин breaches. HashiCorp Vault стал стандартом для secrets management. AWS/GCP/Azure native secrets managers интегрированы с cloud services. 12-factor app рекомендует environment variables, но secrets managers безопаснее.',
  },
  {
    id: 'sd-auth-044',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое CSRF (Cross-Site Request Forgery) атака?',
    options: [
      'Атака, при которой злоумышленник внедряет скрипт на сайт',
      'Атака, при которой вредоносный сайт заставляет браузер пользователя отправить запрос к другому сайту, используя существующую сессию жертвы',
      'Перехват сетевого трафика',
      'Подбор пароля пользователя',
    ],
    correctIndex: 1,
    explanation:
      'CSRF: пользователь аутентифицирован на bank.com (cookie сессии). Заходит на evil.com, который содержит <form action="bank.com/transfer" method="POST">. Браузер автоматически отправляет cookie bank.com с запросом. Защита: 1) CSRF tokens -- уникальный токен в каждой форме, проверяется сервером. 2) SameSite cookie attribute: Strict (cookie не отправляется в cross-site запросах), Lax (не отправляется в POST cross-site). 3) Проверка Origin/Referer headers. 4) Custom headers (X-Requested-With) -- cross-origin запросы не могут добавлять custom headers без CORS preflight.',
  },
  {
    id: 'sd-auth-045',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое OAuth 2.0 Token Introspection?',
    options: [
      'Процесс создания нового токена',
      'Механизм проверки активности и метаданных opaque token через запрос к Authorization Server',
      'Декодирование JWT токена на клиенте',
      'Шифрование токена перед передачей',
    ],
    correctIndex: 1,
    explanation:
      'Token Introspection (RFC 7662) -- endpoint для проверки статуса токена. Resource Server отправляет POST /introspect с токеном, Authorization Server возвращает: {active: true/false, sub, client_id, scope, exp...}. Используется для opaque tokens (не JWT), которые нельзя валидировать локально. Также полезно для JWT: проверка revocation (если токен в blacklist). Минус: latency на каждый запрос к Authorization Server. Оптимизация: кэширование результата (с учётом exp), использование короткоживущих JWT + introspection для refresh tokens.',
  },
  {
    id: 'sd-auth-046',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'open',
    question: 'Как реализовать multi-tenant авторизацию в SaaS-приложении?',
    sampleAnswer:
      'Multi-tenant authorization challenges: изоляция данных между tenants, разные роли/permissions в разных tenants, один пользователь в нескольких tenants. Подходы: 1) Tenant context: каждый запрос содержит tenant_id (в JWT claims, header, URL path /org/{tenant_id}/...). 2) Row-level security: все запросы к БД фильтруются по tenant_id (PostgreSQL RLS policies). 3) Separate schemas/databases: полная изоляция на уровне БД (сложнее управление). 4) Roles per tenant: user может быть admin в tenant A и viewer в tenant B. JWT: {tenants: [{id: A, roles: [admin]}, {id: B, roles: [viewer]}]}. 5) Invitation flow: добавление пользователя в tenant через invite. 6) Tenant switching: UI позволяет переключаться между tenants. 7) Audit: логирование включает tenant_id. 8) Billing/limits: enforcement quotas per tenant. Реализация: tenant_id в JWT, middleware для extraction и validation, ABAC policies с tenant context.',
    explanation:
      'Multi-tenancy -- фундаментальный паттерн SaaS. Isolation -- критична для compliance (один tenant не должен видеть данные другого). Slack, Notion, GitHub -- примеры multi-tenant authorization с per-workspace roles.',
  },
  {
    id: 'sd-auth-047',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое DPoP (Demonstrating Proof of Possession) в OAuth 2.0?',
    options: [
      'Метод шифрования токенов',
      'Механизм привязки токена к клиенту через подписывание запросов приватным ключом, предотвращающий использование украденного токена',
      'Протокол для device authentication',
      'Способ хранения токенов на сервере',
    ],
    correctIndex: 1,
    explanation:
      'DPoP (RFC 9449) -- sender-constrained tokens. Клиент генерирует key pair, при запросе токена отправляет DPoP proof (подписанный JWT с публичным ключом). Access token содержит hash публичного ключа (cnf claim). При использовании токена клиент подписывает каждый запрос новым DPoP proof. Resource server проверяет: подпись proof, соответствие публичного ключа cnf в токене. Если токен украден, атакующий не может его использовать без приватного ключа. Преимущества над Token Binding: работает на application layer, не зависит от TLS. Поддерживается Okta, Auth0.',
  },
  {
    id: 'sd-auth-048',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить secure logout в распределённой системе с JWT?',
    sampleAnswer:
      'Проблема: JWT stateless, нет централизованного состояния сессии для инвалидации. Стратегии logout: 1) Short-lived access tokens: TTL 5-15 минут, при logout просто не refresh. Остаточный риск: токен валиден до exp. 2) Token blacklist: при logout jti добавляется в Redis/БД blacklist. Каждый запрос проверяет blacklist. Trade-off: добавляет state, latency Redis запроса. 3) Token versioning: user.token_version в БД, JWT содержит version. При logout version увеличивается, старые токены невалидны. 4) Refresh token revocation: revoke refresh token, access token истечёт естественно. 5) Distributed cache invalidation: publish logout event, все сервисы обновляют local blacklist. 6) Logout from all devices: revoke все refresh tokens пользователя, увеличить global token_version. Рекомендация: short-lived access (5 min) + refresh token revocation + blacklist в Redis для критичных случаев (password change, security breach).',
    explanation:
      'Secure logout -- одна из сложнейших проблем JWT. Нет perfect solution, все подходы -- trade-offs. Для большинства приложений short-lived access + refresh revocation достаточно. Для высокобезопасных систем (banking) может требоваться real-time invalidation через blacklist.',
  },
  {
    id: 'sd-auth-049',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое consent management в контексте OAuth/OIDC?',
    options: [
      'Управление паролями пользователей',
      'Процесс запроса и хранения согласия пользователя на доступ приложения к его данным с возможностью отзыва',
      'Синхронизация настроек между устройствами',
      'Управление ролями администраторов',
    ],
    correctIndex: 1,
    explanation:
      'Consent management: когда third-party приложение запрашивает доступ к данным пользователя, IdP показывает consent screen с запрашиваемыми scopes (Read your email, Access your calendar). Пользователь явно соглашается. Consent сохраняется -- при повторном входе не запрашивается (если scopes те же). Пользователь может revoke consent в настройках IdP. GDPR требует granular consent, возможность отзыва, прозрачность. OAuth 2.0 prompt=consent принудительно показывает экран согласия. Incremental consent: приложение запрашивает новые scopes по мере необходимости.',
  },
  {
    id: 'sd-auth-050',
    block: 'sd',
    topic: 'auth',
    topicLabel: 'Аутентификация и авторизация',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите архитектуру безопасной аутентификации для IoT устройств.',
    sampleAnswer:
      'IoT authentication challenges: ограниченные ресурсы (CPU, память), нет UI для ввода credentials, физический доступ к устройству, масштаб (миллионы устройств). Архитектура: 1) Device provisioning: при производстве устройство получает уникальный identity (certificate или symmetric key), stored в secure element (TPM, HSM). 2) Initial bootstrap: устройство регистрируется в IoT platform (AWS IoT, Azure IoT Hub) с provisioning certificate. 3) Runtime auth: mTLS с device certificate для каждого соединения с cloud. Certificate rotation периодически. 4) Token-based: для constrained devices -- OAuth 2.0 Device Flow или pre-provisioned tokens. 5) Fleet management: group policies, remote certificate rotation, revocation list. 6) Secure boot: проверка integrity firmware при загрузке. 7) Physical security: tamper detection, secure element для хранения keys. Протоколы: MQTT over TLS, CoAP with DTLS. Standards: FIDO Device Onboard (FDO) для zero-touch provisioning.',
    explanation:
      'IoT security критична -- компрометированные устройства используются для DDoS (Mirai botnet). AWS IoT Core, Azure IoT Hub предоставляют managed device authentication. Secure element (hardware) -- необходим для защиты credentials от physical extraction.',
  },
];
