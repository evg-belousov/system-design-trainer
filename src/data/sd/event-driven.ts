import type { Question } from '../types';

export const eventDrivenQuestions: Question[] = [
  {
    id: 'sd-event-driven-001',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'quiz',
    question:
      'Что такое событийно-ориентированная архитектура (Event-Driven Architecture)?',
    options: [
      'Архитектура, в которой все сервисы общаются исключительно через синхронные HTTP-запросы',
      'Архитектура, в которой компоненты взаимодействуют через отправку и получение событий (асинхронных сообщений о произошедших фактах)',
      'Архитектура, в которой база данных автоматически оповещает все сервисы при изменении любой записи',
      'Архитектура, в которой каждый сервис работает независимо и не взаимодействует с другими',
    ],
    correctIndex: 1,
    explanation:
      'Event-Driven Architecture (EDA) — это архитектурный стиль, в котором компоненты системы взаимодействуют путём отправки и получения событий. Событие (event) — это неизменяемая запись о факте, который произошёл в системе (например, «заказ создан», «платёж обработан»). Это позволяет достичь слабой связанности между сервисами, высокой масштабируемости и гибкости в обработке бизнес-логики.',
  },
  {
    id: 'sd-event-driven-002',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'quiz',
    question:
      'Какой из перечисленных компонентов является посредником для передачи событий между сервисами?',
    options: [
      'Load Balancer',
      'Event Broker (например, Apache Kafka, RabbitMQ)',
      'API Gateway',
      'CDN (Content Delivery Network)',
    ],
    correctIndex: 1,
    explanation:
      'Event Broker (брокер событий) — это инфраструктурный компонент, который принимает события от продюсеров (publishers) и доставляет их потребителям (subscribers). Примеры: Apache Kafka, RabbitMQ, Amazon EventBridge, NATS. Брокер обеспечивает развязку продюсеров и потребителей, буферизацию сообщений, гарантии доставки и масштабируемость.',
  },
  {
    id: 'sd-event-driven-003',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Dead Letter Queue (DLQ)?',
    options: [
      'Очередь для хранения устаревших событий, срок хранения которых истёк',
      'Очередь, в которую попадают сообщения, которые не удалось обработать после заданного числа попыток',
      'Основная очередь, через которую проходят все события системы',
      'Специальная очередь для приоритетных событий, требующих немедленной обработки',
    ],
    correctIndex: 1,
    explanation:
      'Dead Letter Queue (DLQ) — это специальная очередь, куда помещаются сообщения, которые не удалось успешно обработать после заданного числа попыток (retry). Это позволяет не блокировать основную очередь и не терять проблемные сообщения. Команда может позже проанализировать DLQ, выявить причину ошибок и переотправить сообщения после исправления. DLQ — критически важный элемент отказоустойчивой EDA.',
  },
  {
    id: 'sd-event-driven-004',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что означает идемпотентность обработки событий?',
    options: [
      'Событие может быть отправлено только одному потребителю',
      'Повторная обработка одного и того же события приводит к тому же результату, что и при первой обработке',
      'Каждое событие обрабатывается строго один раз без возможности повтора',
      'Потребитель может обрабатывать события только в порядке их поступления',
    ],
    correctIndex: 1,
    explanation:
      'Идемпотентность (idempotency) — свойство операции, при котором многократное применение с одними и теми же параметрами даёт тот же результат, что и однократное. В EDA это критически важно, потому что сообщения могут доставляться повторно (at-least-once delivery). Типичные подходы: хранение обработанных event ID в базе, использование идемпотентных ключей (idempotency key), версионирование состояния.',
  },
  {
    id: 'sd-event-driven-005',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'quiz',
    question:
      'Чем доменное событие (domain event) отличается от технического события (integration event)?',
    options: [
      'Доменное событие всегда синхронное, а техническое — асинхронное',
      'Доменное событие описывает факт внутри bounded context и имеет бизнес-смысл, а интеграционное событие предназначено для общения между сервисами',
      'Доменные события хранятся только в оперативной памяти, а технические — в базе данных',
      'Доменные события не содержат данных, а только идентификатор произошедшего действия',
    ],
    correctIndex: 1,
    explanation:
      'Доменное событие (domain event) — это запись о значимом факте внутри конкретного ограниченного контекста (bounded context). Например, OrderPlaced, PaymentReceived. Оно имеет чёткий бизнес-смысл и принадлежит модели предметной области. Интеграционное событие (integration event) используется для коммуникации между разными bounded context / сервисами. Оно может быть результатом доменного события, но содержит только ту информацию, которая нужна внешним потребителям, и не раскрывает внутреннюю модель.',
  },
  {
    id: 'sd-event-driven-006',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'junior',
    type: 'open',
    question:
      'Опишите, в чём преимущества событийно-ориентированной архитектуры перед синхронным взаимодействием между сервисами. Назовите минимум три преимущества.',
    sampleAnswer:
      '1) Слабая связанность (loose coupling): продюсеры не знают о потребителях, что позволяет добавлять, удалять и изменять сервисы независимо. 2) Масштабируемость: потребители могут обрабатывать события параллельно и независимо масштабироваться. 3) Отказоустойчивость: если потребитель временно недоступен, события сохраняются в брокере и обрабатываются после восстановления. 4) Гибкость: можно добавить нового потребителя для уже существующих событий без модификации продюсера. 5) Буферизация нагрузки: брокер сглаживает пики нагрузки.',
    explanation:
      'EDA позволяет строить распределённые системы, которые лучше переносят сбои, легче масштабируются и проще эволюционируют. Однако у этого подхода есть и недостатки: сложность отладки (трассировка событий через несколько сервисов), eventual consistency, необходимость обеспечения идемпотентности и упорядочивания событий.',
  },
  {
    id: 'sd-event-driven-007',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Event Sourcing?',
    options: [
      'Паттерн, при котором текущее состояние объекта восстанавливается путём последовательного воспроизведения всех произошедших с ним событий',
      'Механизм подписки нескольких потребителей на одно событие через fan-out',
      'Метод фильтрации событий на уровне брокера до отправки потребителям',
      'Стратегия кэширования событий для ускорения повторной обработки',
    ],
    correctIndex: 0,
    explanation:
      'Event Sourcing — паттерн, при котором вместо хранения текущего состояния объекта в базе данных сохраняется полная последовательность событий (event log), которые привели к этому состоянию. Текущее состояние восстанавливается путём «проигрывания» всех событий. Преимущества: полная аудитность, возможность воспроизвести любое прошлое состояние, естественная интеграция с EDA. Недостатки: сложность запросов к текущему состоянию, рост хранилища, необходимость снимков (snapshots) для оптимизации.',
  },
  {
    id: 'sd-event-driven-008',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'quiz',
    question:
      'Какой паттерн разделяет модели чтения и записи данных, позволяя оптимизировать каждую из них независимо?',
    options: [
      'Saga Pattern',
      'Outbox Pattern',
      'CQRS (Command Query Responsibility Segregation)',
      'Event Mesh',
    ],
    correctIndex: 2,
    explanation:
      'CQRS (Command Query Responsibility Segregation) — паттерн, разделяющий операции чтения (Query) и записи (Command) на уровне модели. Модель записи оптимизирована для обработки команд и бизнес-логики, а модель чтения — для быстрых запросов (может быть денормализованной, использовать отдельное хранилище). Часто применяется вместе с Event Sourcing: события из модели записи проецируются (project) в модель чтения. Это повышает производительность и масштабируемость, но увеличивает сложность системы.',
  },
  {
    id: 'sd-event-driven-009',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'quiz',
    question:
      'Чем отличается оркестрация (orchestration) от хореографии (choreography) в паттерне Saga?',
    options: [
      'Оркестрация использует синхронные вызовы, а хореография — асинхронные',
      'Оркестрация предполагает центральный координатор, управляющий шагами саги, а хореография — децентрализованное взаимодействие через события',
      'Оркестрация применяется только для монолитов, а хореография — только для микросервисов',
      'Оркестрация гарантирует строгую консистентность, а хореография — нет',
    ],
    correctIndex: 1,
    explanation:
      'В оркестрации (orchestration-based saga) существует центральный координатор (оркестратор), который последовательно вызывает участников саги и управляет потоком. Он знает обо всех шагах и компенсирующих действиях. В хореографии (choreography-based saga) каждый сервис самостоятельно реагирует на события и публикует свои, нет центрального координатора. Оркестрация проще для понимания и отладки, но создаёт единую точку отказа. Хореография обеспечивает лучшую связанность, но поток сложнее отслеживать.',
  },
  {
    id: 'sd-event-driven-010',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Для чего используется Outbox Pattern?',
    options: [
      'Для кэширования событий перед отправкой потребителям с целью снижения нагрузки на брокер',
      'Для гарантии атомарной записи изменений в БД и публикации события, без потери данных при сбоях',
      'Для маршрутизации событий по различным топикам в зависимости от содержимого',
      'Для дедупликации событий на стороне потребителя',
    ],
    correctIndex: 1,
    explanation:
      'Outbox Pattern решает проблему «двойной записи» (dual write): когда нужно атомарно сохранить данные в БД и опубликовать событие в брокер. Без паттерна возможна ситуация, когда данные сохранены, а событие потеряно (или наоборот). Решение: вместо отправки события напрямую, оно записывается в таблицу outbox в той же транзакции, что и бизнес-данные. Отдельный процесс (polling publisher или CDC — Change Data Capture, например Debezium) читает outbox и публикует события в брокер. Это гарантирует at-least-once доставку.',
  },
  {
    id: 'sd-event-driven-011',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'quiz',
    question:
      'Какой подход к эволюции схемы событий позволяет добавлять новые поля без нарушения совместимости с существующими потребителями?',
    options: [
      'Strict Schema — полный запрет на изменение схемы после публикации',
      'Backward-compatible (обратно совместимая) эволюция с необязательными полями и Schema Registry',
      'Полная замена схемы с принудительным обновлением всех потребителей',
      'Двойная публикация события в старом и новом формате одновременно',
    ],
    correctIndex: 1,
    explanation:
      'Backward-compatible evolution — основной подход к эволюции схемы событий. Новые поля добавляются как необязательные (optional), старые поля не удаляются и не меняют тип. Schema Registry (например, Confluent Schema Registry с Avro/Protobuf/JSON Schema) автоматически проверяет совместимость при регистрации новой версии схемы. Существуют уровни совместимости: backward (новый потребитель читает старые события), forward (старый потребитель читает новые события), full (обе стороны).',
  },
  {
    id: 'sd-event-driven-012',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'open',
    question:
      'Объясните, что такое eventual consistency и почему она неизбежна в событийно-ориентированных системах. Как минимизировать её негативное влияние на пользовательский опыт?',
    sampleAnswer:
      'Eventual consistency — модель консистентности, при которой система гарантирует, что все реплики данных со временем придут к одному состоянию, но в любой момент времени данные могут быть неконсистентны. В EDA она неизбежна, потому что события обрабатываются асинхронно: после публикации события изменения в модели чтения происходят с задержкой. Способы минимизации влияния: 1) Read-your-writes: после записи перенаправлять пользователя на чтение из модели записи. 2) Оптимистичный UI: показывать предполагаемый результат до подтверждения. 3) Уведомления: сообщать пользователю о статусе обработки (WebSocket, polling). 4) Каузальная консистентность: гарантировать порядок обработки зависимых событий.',
    explanation:
      'Eventual consistency — это фундаментальный компромисс в распределённых системах (CAP-теорема). В EDA-системах важно проектировать UX с учётом асинхронности: использовать паттерны вроде «заказ принят к обработке» вместо «заказ создан», предоставлять механизмы отслеживания статуса и обрабатывать конфликты.',
  },
  {
    id: 'sd-event-driven-013',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'open',
    question:
      'Что такое паттерн Saga? Объясните, как он обеспечивает консистентность данных в распределённой системе при отсутствии распределённых транзакций. Приведите пример.',
    sampleAnswer:
      'Saga — паттерн управления распределёнными транзакциями, который заменяет одну ACID-транзакцию последовательностью локальных транзакций в разных сервисах. Каждый шаг имеет компенсирующее действие (compensating transaction), которое выполняется при сбое. Пример: оформление заказа — 1) Сервис заказов создаёт заказ (компенсация: отменить заказ). 2) Сервис оплаты списывает средства (компенсация: вернуть средства). 3) Сервис склада резервирует товар (компенсация: снять резерв). 4) Сервис доставки создаёт отправку. Если шаг 3 неуспешен, выполняются компенсации в обратном порядке: возврат средств → отмена заказа. Saga обеспечивает eventual consistency, а не строгую ACID.',
    explanation:
      'Saga — один из ключевых паттернов в микросервисной архитектуре. Его правильная реализация требует тщательного проектирования компенсирующих действий, обработки тайм-аутов и обеспечения идемпотентности каждого шага. Два подхода реализации — оркестрация и хореография — имеют свои компромиссы по сложности и связанности.',
  },
  {
    id: 'sd-event-driven-014',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'middle',
    type: 'open',
    question:
      'Сравните модели доставки сообщений: at-most-once, at-least-once и exactly-once. Какая из них наиболее реалистична для распределённых систем и почему?',
    sampleAnswer:
      'At-most-once: сообщение доставляется не более одного раза, возможна потеря. Продюсер отправляет и не ждёт подтверждения (fire-and-forget). At-least-once: сообщение доставляется минимум один раз, возможны дубликаты. Продюсер повторяет отправку при отсутствии подтверждения. At-least-once — наиболее реалистичная и распространённая модель, потому что true exactly-once в распределённой системе практически невозможна (Two Generals Problem). Exactly-once семантика достигается через at-least-once delivery + идемпотентная обработка на стороне потребителя (effectively-once). Kafka Streams и Apache Flink реализуют exactly-once через транзакции и идемпотентных продюсеров в рамках своей экосистемы.',
    explanation:
      'Выбор гарантии доставки — ключевое архитектурное решение. At-most-once подходит для метрик и логов, where потеря отдельных сообщений допустима. At-least-once + идемпотентность — стандарт для бизнес-критичных операций. «Exactly-once» в маркетинге брокеров обычно означает «effectively-once» в рамках конкретной платформы.',
  },
  {
    id: 'sd-event-driven-015',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'quiz',
    question:
      'Что такое Event Mesh и чем он отличается от простого Event Broker?',
    options: [
      'Event Mesh — это кэширующий слой поверх Event Broker для ускорения доставки',
      'Event Mesh — это сеть взаимосвязанных Event Broker-ов, обеспечивающая маршрутизацию событий между различными средами, облаками и регионами',
      'Event Mesh — это паттерн организации хранения событий в файловой системе',
      'Event Mesh и Event Broker — это синонимы одной и той же технологии',
    ],
    correctIndex: 1,
    explanation:
      'Event Mesh — это архитектурный слой, состоящий из сети взаимосвязанных event broker-ов, которая динамически маршрутизирует события между приложениями, облачными провайдерами, средами (dev/staging/prod) и дата-центрами. В отличие от одного брокера, event mesh обеспечивает глобальную маршрутизацию, протокольную трансляцию (MQTT, AMQP, REST), отказоустойчивость на уровне инфраструктуры. Примеры: Solace PubSub+ Event Mesh, Confluent Platform с Multi-Region Clusters.',
  },
  {
    id: 'sd-event-driven-016',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'quiz',
    question:
      'Какая стратегия в Event Sourcing решает проблему длительного восстановления состояния при большом количестве событий?',
    options: [
      'Event Compaction — удаление всех событий и сохранение только последнего состояния',
      'Snapshotting — периодическое сохранение агрегированного состояния, от которого начинается воспроизведение последующих событий',
      'Event Batching — группировка нескольких событий в одно агрегированное событие',
      'Parallel Replay — параллельное воспроизведение всех событий на нескольких потоках',
    ],
    correctIndex: 1,
    explanation:
      'Snapshotting — ключевая оптимизация в Event Sourcing. Вместо воспроизведения всех событий с начала жизни агрегата, система периодически (например, каждые N событий) сохраняет «снимок» текущего состояния. При восстановлении загружается последний snapshot и воспроизводятся только события после него. Это кардинально сокращает время восстановления — с O(n) для всех событий до O(1) для snapshot + O(k) для оставшихся событий. Важно: snapshot — это оптимизация, источником истины остаётся лог событий.',
  },
  {
    id: 'sd-event-driven-017',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'open',
    question:
      'Как реализовать Outbox Pattern с использованием Change Data Capture (CDC)? Опишите архитектуру, компоненты и гарантии, которые обеспечивает этот подход.',
    sampleAnswer:
      'Архитектура: 1) Сервис записывает бизнес-данные и событие в таблицу outbox в одной транзакции БД. 2) CDC-коннектор (например, Debezium) подключается к WAL (Write-Ahead Log) / binlog базы данных и отслеживает изменения в таблице outbox. 3) Каждая новая запись в outbox автоматически захватывается CDC и публикуется в Kafka-топик. 4) Потребители подписываются на топик и обрабатывают события. Компоненты: PostgreSQL/MySQL (БД с outbox-таблицей), Debezium (CDC-коннектор), Apache Kafka Connect (инфраструктура), Kafka (брокер). Гарантии: атомарность (событие и данные в одной транзакции), at-least-once доставка (CDC гарантирует захват всех изменений из WAL), низкая задержка (CDC читает WAL почти в реальном времени, без polling). Потребитель должен быть идемпотентным.',
    explanation:
      'CDC-based Outbox Pattern — это production-grade решение, используемое в Netflix, Uber, Airbnb. Debezium + Kafka Connect — де-факто стандарт. Альтернатива — polling publisher (SELECT из outbox по крону), но CDC эффективнее, так как не нагружает БД запросами и обеспечивает меньшую задержку.',
  },
  {
    id: 'sd-event-driven-018',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'open',
    question:
      'Спроектируйте систему обработки заказов на основе Event Sourcing и CQRS. Опишите основные агрегаты, события, модели чтения и потоки данных.',
    sampleAnswer:
      'Агрегат Order: управляет жизненным циклом заказа. События: OrderCreated(orderId, items, customerId), OrderPaymentReceived(orderId, paymentId, amount), OrderItemReserved(orderId, itemId), OrderShipped(orderId, trackingNumber), OrderCancelled(orderId, reason). Модель записи: Event Store хранит все события. Агрегат Order загружается из событий, применяет бизнес-правила (нельзя оплатить отменённый заказ), генерирует новые события. Модели чтения (проекции): 1) OrderSummaryView — денормализованная таблица для быстрого отображения списка заказов. 2) OrderDetailView — полная информация о заказе с историей статусов. 3) CustomerOrdersView — заказы клиента для личного кабинета. 4) AnalyticsView — агрегированные данные для аналитики. Потоки: Command → Aggregate → Event Store → Event Bus → Projectors → Read Models. Проекторы подписываются на поток событий и обновляют соответствующие read-модели. Read API обращается к денормализованным моделям чтения.',
    explanation:
      'Event Sourcing + CQRS — мощная комбинация для сложных доменов. Ключевые решения: выбор Event Store (EventStoreDB, Kafka, PostgreSQL), стратегия проецирования (синхронная/асинхронная), обработка ошибок проекций (replay, dead letter), снимки для агрегатов с большим числом событий.',
  },
  {
    id: 'sd-event-driven-019',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'open',
    question:
      'Как обеспечить строгий порядок обработки событий в распределённой системе с несколькими партициями (partitions) в Kafka? Какие компромиссы возникают?',
    sampleAnswer:
      'Kafka гарантирует порядок событий только внутри одной партиции. Стратегии обеспечения порядка: 1) Партиционирование по ключу: все события одной сущности (например, orderId) направляются в одну партицию через partition key. Это гарантирует порядок для конкретного агрегата. 2) Одна партиция: использовать один partition для всего топика — порядок глобальный, но пропускная способность сильно ограничена (один consumer). 3) Sequence numbers: каждое событие содержит порядковый номер, потребитель обнаруживает пропуски и ожидает недостающие события. 4) Causal ordering: включать в событие ссылку на предыдущее (causation ID), потребитель выстраивает цепочку. Компромиссы: строгий порядок ограничивает параллелизм (только один потребитель на партицию), увеличивает задержку (ожидание недостающих событий), усложняет ребалансировку. Оптимальный подход — порядок на уровне entity key, а не глобальный.',
    explanation:
      'Ordering — одна из самых сложных проблем в EDA. В реальных системах глобальный порядок обычно не нужен — достаточно порядка для конкретной сущности. Kafka с partition key по entity ID — стандартное решение. При ребалансировке потребителей важно учитывать, что новый consumer должен «дочитать» текущее смещение до начала обработки новых сообщений.',
  },
  {
    id: 'sd-event-driven-020',
    block: 'sd',
    topic: 'event-driven',
    topicLabel: 'Event-Driven Architecture',
    difficulty: 'senior',
    type: 'quiz',
    question:
      'Какая проблема возникает при использовании Event Sourcing, если необходимо изменить структуру уже сохранённых событий?',
    options: [
      'Невозможность добавить новые типы событий в систему',
      'Event upcasting — необходимость преобразования старых событий к новой схеме при воспроизведении, что требует поддержки версионирования и миграции схем',
      'Автоматическое удаление всех событий при изменении схемы',
      'Невозможность создать snapshot до обновления всех событий',
    ],
    correctIndex: 1,
    explanation:
      'Event upcasting — процесс преобразования событий из старой версии схемы в новую «на лету» при загрузке из Event Store. Поскольку события неизменяемы (immutable), мы не можем переписать историю. Подходы: 1) Upcasters — трансформеры, которые конвертируют v1 → v2 → v3 при загрузке. 2) Lazy migration — событие хранит номер версии, агрегат умеет обрабатывать все версии. 3) Copy-transform — создание нового потока с трансформированными событиями (дорого). Schema Registry помогает контролировать совместимость, но upcasting остаётся ответственностью приложения.',
  },
];
