import type { Question } from '../types';

export const microservicesQuestions: Question[] = [
  {
    id: 'sd-ms-001',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какое основное преимущество микросервисной архитектуры перед монолитной?',
    options: [
      'Микросервисы всегда работают быстрее монолита',
      'Микросервисы проще разрабатывать, чем монолит',
      'Каждый микросервис можно разрабатывать, деплоить и масштабировать независимо',
      'Микросервисы не требуют мониторинга',
    ],
    correctIndex: 2,
    explanation:
      'Главное преимущество микросервисной архитектуры -- независимость компонентов. Каждый сервис может разрабатываться отдельной командой, использовать подходящий технологический стек, деплоиться по собственному расписанию и масштабироваться в зависимости от нагрузки. Это позволяет большим организациям двигаться быстрее. Однако микросервисы привносят значительную операционную сложность: распределённые транзакции, сетевая коммуникация, мониторинг, отладка, согласованность данных.',
  },
  {
    id: 'sd-ms-002',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое паттерн Circuit Breaker в микросервисной архитектуре?',
    options: [
      'Механизм маршрутизации запросов между сервисами',
      'Паттерн, предотвращающий каскадные отказы путём прекращения вызовов к недоступному сервису',
      'Способ разделения данных между микросервисами',
      'Инструмент для автоматического масштабирования сервисов',
    ],
    correctIndex: 1,
    explanation:
      'Circuit Breaker (автоматический выключатель) -- паттерн, заимствованный из электротехники. Он отслеживает количество ошибок при вызове внешнего сервиса. Когда ошибки превышают порог, «выключатель» размыкается и последующие запросы немедленно возвращают ошибку без попытки вызова (fail fast). Через заданное время выключатель переходит в полуоткрытое состояние, пропуская пробный запрос. Если он успешен -- выключатель замыкается. Это предотвращает каскадные отказы, экономит ресурсы и даёт время на восстановление. Реализации: Netflix Hystrix (устарел), Resilience4j, Polly.',
  },
  {
    id: 'sd-ms-003',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн Saga для управления распределёнными транзакциями в микросервисной архитектуре. Какие виды Saga существуют и какие у них недостатки?',
    sampleAnswer:
      'Saga -- паттерн управления распределёнными транзакциями, где длинная транзакция разбивается на последовательность локальных транзакций в разных сервисах. Каждая локальная транзакция обновляет данные в своём сервисе и публикует событие, запускающее следующий шаг. При ошибке выполняются компенсирующие транзакции в обратном порядке. Виды Saga: 1) Хореография (Choreography): каждый сервис слушает события и решает, что делать дальше. Нет центрального координатора. Просто для малого числа шагов, но сложно отслеживать общий прогресс и отлаживать. 2) Оркестрация (Orchestration): центральный оркестратор управляет последовательностью шагов, отправляя команды сервисам. Логика в одном месте, легче отслеживать, но оркестратор может стать единой точкой отказа. Недостатки Saga: нет изоляции (промежуточные состояния видны другим транзакциям), компенсирующие транзакции сложно реализовать (как «отменить» отправленный email?), сложность отладки, eventual consistency.',
    explanation:
      'Saga -- альтернатива двухфазному коммиту (2PC), который плохо работает в микросервисах из-за блокирующей природы и зависимости от координатора. Пример Saga для заказа: 1) Создать заказ -> 2) Зарезервировать товар -> 3) Списать деньги -> 4) Подтвердить заказ. Если шаг 3 не удался: компенсация шага 2 (вернуть товар на склад) -> компенсация шага 1 (отменить заказ). На практике используется в e-commerce, банковских системах, бронировании.',
  },
  {
    id: 'sd-ms-004',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое API Gateway в микросервисной архитектуре? Какие функции он выполняет?',
    sampleAnswer:
      'API Gateway -- это единая точка входа для всех клиентских запросов в микросервисной архитектуре. Он выступает обратным прокси, маршрутизируя запросы к соответствующим микросервисам. Основные функции: 1) Маршрутизация запросов к нужным сервисам на основе URL, заголовков или содержимого. 2) Аутентификация и авторизация -- централизованная проверка токенов (JWT, OAuth). 3) Rate limiting -- ограничение частоты запросов. 4) Агрегация ответов -- объединение данных от нескольких сервисов в один ответ. 5) Протокольная трансляция -- преобразование REST в gRPC и наоборот. 6) Кэширование на уровне gateway. 7) Логирование и мониторинг. 8) SSL-терминация. Примеры: Kong, AWS API Gateway, Nginx, Envoy + Istio.',
    explanation:
      'API Gateway реализует паттерн «фасад» для микросервисов. Без него клиенту пришлось бы знать адреса всех сервисов, управлять аутентификацией в каждом запросе и делать множественные вызовы для сборки одной страницы. Однако gateway может стать узким местом и единой точкой отказа, поэтому его нужно масштабировать и обеспечивать высокую доступность.',
  },
  {
    id: 'sd-ms-005',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн позволяет каждому микросервису иметь собственную базу данных, обеспечивая при этом консистентность данных между сервисами?',
    options: [
      'Shared Database -- все сервисы используют общую БД',
      'Database per Service + Event-Driven Architecture с eventual consistency',
      'Two-Phase Commit (2PC) между всеми сервисами',
      'Distributed Lock Manager для синхронизации доступа к данным',
    ],
    correctIndex: 1,
    explanation:
      'Паттерн Database per Service предполагает, что каждый микросервис владеет своими данными и не обращается напрямую к базам данных других сервисов. Консистентность обеспечивается через событийную архитектуру (Event-Driven): при изменении данных сервис публикует событие, другие сервисы подписываются и обновляют свои локальные данные. Это обеспечивает eventual consistency. Shared Database нарушает принцип изолированности, 2PC плохо масштабируется, а Distributed Lock Manager создаёт узкое место.',
  },
  {
    id: 'sd-microservices-006',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Service Discovery (обнаружение сервисов) в микросервисной архитектуре?',
    options: [
      'Процесс тестирования новых микросервисов',
      'Механизм, позволяющий сервисам автоматически находить сетевые адреса других сервисов',
      'Инструмент для документирования API микросервисов',
      'Процедура ручной настройки IP-адресов в конфигурационных файлах',
    ],
    correctIndex: 1,
    explanation:
      'Service Discovery -- механизм, позволяющий микросервисам автоматически находить сетевые адреса (IP:port) других сервисов. В динамической среде (контейнеры, автоскейлинг) адреса сервисов постоянно меняются, и жёсткое кодирование адресов невозможно. Два подхода: 1) Client-side discovery -- клиент запрашивает реестр сервисов (Consul, Eureka) и сам выбирает экземпляр. 2) Server-side discovery -- клиент обращается к load balancer/DNS, который знает о доступных экземплярах (Kubernetes Services, AWS ELB). Kubernetes использует встроенный DNS для service discovery.',
  },
  {
    id: 'sd-microservices-007',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой подход к коммуникации между микросервисами является асинхронным?',
    options: [
      'HTTP REST вызов с ожиданием ответа',
      'gRPC вызов с ожиданием ответа',
      'Обмен сообщениями через брокер (RabbitMQ, Kafka)',
      'GraphQL запрос к другому сервису',
    ],
    correctIndex: 2,
    explanation:
      'Обмен сообщениями через брокер (message broker) -- основной способ асинхронной коммуникации между микросервисами. Сервис-отправитель публикует сообщение в очередь или топик и продолжает работу, не ожидая ответа. Сервис-получатель обрабатывает сообщение, когда готов. Преимущества: развязка сервисов, буферизация нагрузки, отказоустойчивость. HTTP REST и gRPC -- синхронные подходы (request-response), где вызывающий сервис блокируется до получения ответа. Популярные брокеры: RabbitMQ, Apache Kafka, AWS SQS.',
  },
  {
    id: 'sd-microservices-008',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой антипаттерн возникает, когда микросервисы слишком сильно зависят друг от друга и требуют синхронных вызовов между собой?',
    options: [
      'Event Sourcing',
      'Distributed Monolith (распределённый монолит)',
      'Sidecar Pattern',
      'Database per Service',
    ],
    correctIndex: 1,
    explanation:
      'Distributed Monolith (распределённый монолит) -- антипаттерн, при котором система формально разделена на микросервисы, но они настолько тесно связаны (tight coupling), что должны деплоиться, масштабироваться и изменяться вместе. Это сочетает недостатки монолита (невозможность независимых изменений) и микросервисов (сложность распределённой системы, сетевые задержки, трудность отладки). Признаки: синхронные цепочки вызовов, общая база данных, совместный деплой, каскадные отказы.',
  },
  {
    id: 'sd-microservices-009',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Sidecar-паттерн в микросервисной архитектуре?',
    options: [
      'Резервный экземпляр каждого сервиса для failover',
      'Вспомогательный процесс/контейнер, развёрнутый рядом с основным сервисом для обеспечения инфраструктурных функций',
      'Механизм синхронизации данных между базами данных сервисов',
      'Паттерн для маршрутизации трафика между дата-центрами',
    ],
    correctIndex: 1,
    explanation:
      'Sidecar-паттерн предполагает размещение вспомогательного процесса (sidecar) рядом с основным сервисом в одном pod (Kubernetes) или на одном хосте. Sidecar берёт на себя инфраструктурные задачи: проксирование трафика (Envoy), логирование, мониторинг, service mesh функции (mTLS, retry, circuit breaking), обнаружение сервисов. Преимущества: основной сервис не содержит инфраструктурного кода, sidecar может быть написан на любом языке, единообразие инфраструктурных функций для всех сервисов. Это основа архитектуры Service Mesh (Istio, Linkerd).',
  },
  {
    id: 'sd-microservices-010',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое Strangler Fig Pattern и как он используется для миграции с монолита на микросервисы?',
    sampleAnswer:
      'Strangler Fig Pattern (паттерн «Душитель») -- стратегия постепенной миграции монолитного приложения на микросервисы, названная по аналогии с тропическим растением, которое постепенно обвивает и замещает дерево-хозяина. Процесс: 1) Новая функциональность реализуется как микросервис, а не добавляется в монолит. 2) Существующая функциональность постепенно выносится из монолита в микросервисы. 3) Proxy/API Gateway маршрутизирует запросы: часть -- к микросервисам, часть -- к монолиту. 4) Со временем монолит уменьшается и в итоге полностью замещается. Преимущества: нет «большого взрыва» (big bang migration), система всегда работоспособна, возможность отката, команда постепенно набирает опыт с микросервисами. Пример: Amazon перешёл от монолита к микросервисам в течение нескольких лет, вынося компоненты по одному.',
    explanation:
      'Strangler Fig Pattern предложен Мартином Фаулером. Ключевые рекомендации: начинать с наименее связанных модулей монолита, использовать anti-corruption layer для изоляции нового кода от legacy, определять чёткие границы (bounded contexts по DDD) перед выносом. Типичная ошибка -- пытаться мигрировать всё сразу, что приводит к распределённому монолиту.',
  },
  {
    id: 'sd-microservices-011',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Service Mesh?',
    options: [
      'Специальная база данных для хранения конфигураций микросервисов',
      'Инфраструктурный слой, управляющий межсервисной коммуникацией через sidecar-прокси с поддержкой mTLS, observability и traffic management',
      'Метод декомпозиции монолита на микросервисы',
      'API для тестирования микросервисов в изоляции',
    ],
    correctIndex: 1,
    explanation:
      'Service Mesh -- инфраструктурный слой для управления коммуникацией между микросервисами. Состоит из: 1) Data plane -- sidecar-прокси (обычно Envoy), установленные рядом с каждым сервисом, перехватывающие весь входящий/исходящий трафик. 2) Control plane -- централизованное управление (Istiod в Istio, Linkerd control plane). Функции: mTLS (шифрование и аутентификация межсервисного трафика), observability (метрики, трейсинг, логи), traffic management (canary releases, fault injection, retries, circuit breaking), authorization policies. Популярные реализации: Istio, Linkerd, Consul Connect. Service Mesh выносит сетевую логику из кода приложения в инфраструктуру.',
  },
  {
    id: 'sd-microservices-012',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн API Composition. Как агрегировать данные из нескольких микросервисов для одного запроса клиента?',
    sampleAnswer:
      'API Composition -- паттерн, при котором специальный компонент (API Composer/Aggregator) собирает данные из нескольких микросервисов в один ответ для клиента. Например, страница товара требует данных из сервисов: каталога (описание), ценообразования (цена), склада (остатки), отзывов (рейтинг). Варианты реализации: 1) API Gateway как composer: gateway делает параллельные запросы к сервисам и объединяет ответы. Подходит для простой агрегации. 2) BFF (Backend for Frontend): отдельный сервис для каждого типа клиента, выполняющий агрегацию. 3) GraphQL: schema stitching или federation позволяют прозрачно объединять данные из разных сервисов. Apollo Federation -- стандартный подход. Проблемы: 1) Как обрабатывать частичные ошибки (один сервис не ответил)? Отдать частичный ответ или ошибку? 2) Задержка определяется самым медленным сервисом. 3) Транзакционная консистентность не гарантируется. Решения: параллельные запросы, таймауты, fallback-значения, кэширование.',
    explanation:
      'API Composition -- альтернатива CQRS для запросов, затрагивающих данные нескольких сервисов. При высокой нагрузке рекомендуется использовать CQRS с предварительно построенными read-моделями (materialized views), чтобы избежать множественных запросов в runtime. Netflix активно использует GraphQL Federation для агрегации данных из десятков микросервисов.',
  },
  {
    id: 'sd-microservices-013',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое принцип «Database per Service» и зачем он нужен?',
    sampleAnswer:
      'Database per Service -- принцип, при котором каждый микросервис имеет собственную базу данных (или как минимум собственную схему), недоступную напрямую другим сервисам. Данные доступны только через API сервиса. Зачем: 1) Слабая связанность (loose coupling) -- изменение схемы БД одного сервиса не ломает другие. 2) Независимый деплой -- можно мигрировать БД одного сервиса без остановки других. 3) Свобода выбора технологии -- каждый сервис может использовать оптимальную БД (PostgreSQL для финансов, MongoDB для каталога, Redis для кэша). 4) Независимое масштабирование -- горячие сервисы масштабируют свою БД без влияния на другие. Недостатки: сложность join-запросов между сервисами (решается через API Composition или CQRS), eventual consistency вместо ACID-транзакций между сервисами, дублирование данных.',
    explanation:
      'Database per Service -- один из ключевых принципов микросервисной архитектуры. Альтернатива -- Shared Database -- проще в реализации, но создаёт сильную связанность между сервисами и является одной из главных причин появления «распределённого монолита».',
  },
  {
    id: 'sd-microservices-014',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Contract Testing (контрактное тестирование) в микросервисах?',
    options: [
      'Тестирование юридических аспектов использования API',
      'Тестирование, проверяющее, что взаимодействие между сервисами соответствует согласованному контракту (формату запросов и ответов)',
      'Тестирование производительности каждого микросервиса',
      'Тестирование совместимости разных версий базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Contract Testing -- подход к тестированию, при котором проверяется, что consumer (вызывающий сервис) и provider (вызываемый сервис) согласованы по формату взаимодействия (контракту). Consumer пишет тесты, описывающие ожидаемый формат ответа от provider. Provider проверяет, что его реализация соответствует этим ожиданиям. Инструменты: Pact, Spring Cloud Contract. Преимущества: раннее обнаружение breaking changes, тестирование без поднятия всех зависимых сервисов, уверенность при независимом деплое. Contract testing дополняет, но не заменяет unit и integration тесты.',
  },
  {
    id: 'sd-microservices-015',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните стратегии деплоя микросервисов: Blue-Green, Canary и Rolling deployment.',
    sampleAnswer:
      '1) Blue-Green Deployment: поддерживаются два идентичных окружения (Blue -- текущее, Green -- новое). Новая версия деплоится в Green, тестируется, затем трафик мгновенно переключается с Blue на Green. Плюсы: мгновенный откат (переключение обратно на Blue), нет downtime, полное тестирование перед переключением. Минусы: двойные ресурсы, сложности с БД-миграциями (обе версии должны быть совместимы с одной БД). 2) Canary Deployment: новая версия разворачивается на небольшой части инфраструктуры (1-5% трафика). Метрики мониторятся, и при отсутствии проблем процент трафика постепенно увеличивается до 100%. Плюсы: минимальный risk blast radius, реальное тестирование на продакшн-трафике. Минусы: сложная маршрутизация, длительный процесс, необходимость хорошего мониторинга. 3) Rolling Deployment: экземпляры обновляются по одному (или группами). В любой момент часть экземпляров работает на старой версии, часть на новой. Плюсы: не требует двойных ресурсов, встроен в Kubernetes. Минусы: во время деплоя работают две версии одновременно, откат медленнее.',
    explanation:
      'Выбор стратегии зависит от требований к надёжности, скорости деплоя и доступных ресурсов. В Kubernetes rolling deployment -- стратегия по умолчанию (RollingUpdate). Canary часто реализуется через Istio, Flagger или Argo Rollouts. Blue-Green хорошо подходит для критических сервисов с низкой частотой деплоя.',
  },
  {
    id: 'sd-microservices-016',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Distributed Tracing и какую проблему он решает?',
    options: [
      'Метод шифрования данных при передаче между сервисами',
      'Механизм отслеживания запроса через цепочку микросервисов с помощью уникального trace ID для диагностики задержек и ошибок',
      'Способ распределения данных по разным базам данных',
      'Инструмент для автоматического масштабирования сервисов',
    ],
    correctIndex: 1,
    explanation:
      'Distributed Tracing (распределённая трассировка) позволяет отслеживать путь одного запроса через цепочку микросервисов. Каждый запрос получает уникальный trace ID, который передаётся между сервисами. Каждый сервис создаёт span (отрезок) с информацией о времени обработки, метаданных и ошибках. Это позволяет визуализировать полную цепочку вызовов, находить узкие места (bottlenecks) и диагностировать ошибки в распределённой системе. Стандарт: OpenTelemetry (объединяет OpenTracing и OpenCensus). Инструменты: Jaeger, Zipkin, Datadog APM, AWS X-Ray.',
  },
  {
    id: 'sd-microservices-017',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Какие основные недостатки микросервисной архитектуры по сравнению с монолитом?',
    sampleAnswer:
      'Основные недостатки микросервисов: 1) Операционная сложность: необходимы CI/CD пайплайны для каждого сервиса, оркестрация контейнеров (Kubernetes), мониторинг десятков/сотен сервисов. 2) Сетевая сложность: вызовы между сервисами идут по сети, что добавляет задержку, возможность ошибок, необходимость retry и circuit breaker. 3) Распределённые транзакции: ACID-транзакции между сервисами невозможны, нужны Saga, eventual consistency. 4) Отладка и тестирование: сложно отследить проблему через цепочку сервисов, нужен distributed tracing. E2E тесты требуют поднятия множества сервисов. 5) Дублирование данных: данные из одного сервиса часто нужны другим, что приводит к дублированию и рассинхронизации. 6) Организационная сложность: нужны DevOps-практики, зрелые команды, чёткое определение границ сервисов. 7) Overhead в производительности: сериализация/десериализация, сетевые вызовы вместо вызовов функций в памяти.',
    explanation:
      'Микросервисы не являются «серебряной пулей». Мартин Фаулер рекомендует «Monolith First» подход: начинать с монолита и переходить на микросервисы только когда появляются реальные проблемы масштабирования команды или системы. Для небольших команд (до 10-15 человек) монолит часто является лучшим выбором.',
  },
  {
    id: 'sd-microservices-018',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое Shared Nothing Architecture и как она применяется в микросервисах?',
    sampleAnswer:
      'Shared Nothing Architecture -- архитектурный подход, при котором каждый узел системы полностью автономен: имеет собственные вычислительные ресурсы, память, хранилище данных и не разделяет их с другими узлами. В контексте микросервисов это означает: 1) Каждый сервис имеет собственную базу данных (Database per Service). 2) Нет общих библиотек с бизнес-логикой (shared libraries ограничиваются утилитами). 3) Нет общего состояния в памяти (shared memory/cache). 4) Каждый сервис может масштабироваться и деплоиться независимо. 5) Коммуникация только через чётко определённые API или события. Преимущества: линейная масштабируемость (добавление узлов увеличивает мощность пропорционально), изоляция отказов, независимость команд. Недостатки: сложность координации, дублирование данных и логики, eventual consistency. Shared Nothing -- противоположность Shared Everything (монолит с общей БД).',
    explanation:
      'Shared Nothing Architecture -- фундамент горизонтального масштабирования. Его используют Google (Bigtable, Spanner), Amazon (DynamoDB, микросервисы), Facebook. В реальности идеальный «shared nothing» редко достижим: сервисы всё равно разделяют сеть, Service Discovery, конфигурацию. Важно минимизировать общие зависимости и стремиться к максимальной автономности каждого сервиса.',
  },
  {
    id: 'sd-microservices-019',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн наблюдаемости (observability) включает три основных компонента: метрики, логи и трейсы?',
    options: [
      'Circuit Breaker pattern',
      'Three Pillars of Observability (Три столпа наблюдаемости)',
      'Event Sourcing pattern',
      'Health Check pattern',
    ],
    correctIndex: 1,
    explanation:
      'Three Pillars of Observability (три столпа наблюдаемости) -- концепция, определяющая три ключевых источника данных для понимания состояния распределённой системы: 1) Метрики (Metrics) -- числовые показатели (CPU, память, latency, error rate, RPS). Инструменты: Prometheus, Datadog, CloudWatch. 2) Логи (Logs) -- записи событий с деталями. Инструменты: ELK stack (Elasticsearch, Logstash, Kibana), Loki. 3) Трейсы (Traces) -- путь запроса через цепочку сервисов. Инструменты: Jaeger, Zipkin, Tempo. Вместе они позволяют: обнаруживать проблемы (метрики и алерты), локализовать причину (трейсы), детально анализировать (логи). OpenTelemetry стремится унифицировать сбор всех трёх типов данных.',
  },
  {
    id: 'sd-microservices-020',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн рекомендуется для обеспечения атомарности записи в базу данных и публикации события в микросервисах?',
    options: [
      'Two-Phase Commit (2PC) между базой данных и брокером сообщений',
      'Transactional Outbox -- запись события в специальную таблицу outbox в той же транзакции, что и бизнес-данные',
      'Двойная запись (dual write) -- запись и в базу, и в брокер последовательно',
      'Periodic batch export -- периодическая выгрузка всех изменений в брокер',
    ],
    correctIndex: 1,
    explanation:
      'Transactional Outbox -- паттерн, решающий проблему атомарности записи в БД и публикации события. Вместо прямой публикации в брокер сообщений, сервис записывает событие в таблицу outbox в той же транзакции, что и бизнес-данные. Отдельный процесс (relay/poller) читает события из outbox и публикует их в брокер, затем помечает как отправленные. Альтернатива -- Change Data Capture (CDC): Debezium считывает WAL базы данных и автоматически публикует изменения. Dual write (запись в БД + брокер отдельно) -- антипаттерн, так как при сбое между двумя операциями данные рассинхронизируются.',
  },
  {
    id: 'sd-microservices-021',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое монолитная архитектура?',
    options: [
      'Архитектура с одной базой данных',
      'Архитектура, где всё приложение развёртывается как единый модуль, все компоненты тесно связаны',
      'Архитектура с одним сервером',
      'Архитектура без использования облака',
    ],
    correctIndex: 1,
    explanation:
      'Монолитная архитектура -- это подход, при котором всё приложение разрабатывается и развёртывается как единый модуль. Все компоненты (UI, бизнес-логика, доступ к данным) находятся в одной кодовой базе и деплоятся вместе. Преимущества: простота разработки и отладки, нет сетевых вызовов между компонентами, простой деплой. Недостатки: сложность масштабирования отдельных компонентов, любое изменение требует передеплоя всего приложения, технологический lock-in.',
  },
  {
    id: 'sd-microservices-022',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Когда следует выбирать монолит, а когда микросервисы?',
    sampleAnswer:
      'Выбор монолита: 1) Небольшая команда (до 10-15 человек). 2) Начальная стадия проекта, когда границы доменов ещё не ясны. 3) Простое приложение с низкой сложностью. 4) Ограниченные DevOps-ресурсы. 5) Нет требований к независимому масштабированию компонентов. Выбор микросервисов: 1) Большая организация с несколькими командами. 2) Зрелый продукт с понятными границами доменов. 3) Разные компоненты имеют разные требования к масштабированию. 4) Необходимость независимого деплоя. 5) Различные технологические требования для разных частей системы. Мартин Фаулер рекомендует "Monolith First": начинать с монолита и переходить на микросервисы при появлении реальных проблем.',
    explanation:
      'Преждевременный переход на микросервисы -- частая ошибка. Микросервисы решают организационные проблемы (масштабирование команд), а не технические. Для стартапа с 3-5 разработчиками микросервисы создадут больше проблем, чем решат.',
  },
  {
    id: 'sd-microservices-023',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой принцип DDD помогает определить границы микросервисов?',
    options: [
      'Single Responsibility Principle',
      'Bounded Context (ограниченный контекст)',
      'Open/Closed Principle',
      'Dependency Injection',
    ],
    correctIndex: 1,
    explanation:
      'Bounded Context (ограниченный контекст) из Domain-Driven Design -- ключевая концепция для определения границ микросервисов. Bounded Context определяет границы, в пределах которых определённая модель домена применима и консистентна. Каждый микросервис обычно соответствует одному Bounded Context. Например: Order Context, Inventory Context, Payment Context. Внутри контекста термины и модели однозначны; между контекстами они могут различаться (Customer в Sales vs Customer в Support).',
  },
  {
    id: 'sd-microservices-024',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Какие стратегии декомпозиции монолита на микросервисы существуют?',
    sampleAnswer:
      'Стратегии декомпозиции: 1) По бизнес-возможностям (business capabilities): выделение сервисов по функциональным областям бизнеса -- Orders, Payments, Inventory, Shipping. 2) По поддоменам DDD: использование Bounded Contexts для определения границ. 3) По командам (Conway Law): структура системы отражает структуру организации. Команда владеет сервисом. 4) По изменяемости: компоненты, которые часто меняются вместе, группируются в один сервис. 5) По масштабируемости: компоненты с разными требованиями к нагрузке выделяются в отдельные сервисы. 6) По технологическому стеку: компоненты, требующие разных технологий. Strangler Fig Pattern: постепенное вынесение функционала из монолита в микросервисы без big bang миграции.',
    explanation:
      'Нет универсального рецепта декомпозиции. Ключевые принципы: loose coupling (слабая связанность между сервисами), high cohesion (высокая связность внутри сервиса). Ошибка -- слишком мелкие сервисы (nano-services), создающие overhead без пользы. Рекомендуемый размер: один сервис может поддерживать одна команда из 5-9 человек.',
  },
  {
    id: 'sd-microservices-025',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Event Sourcing?',
    options: [
      'Паттерн отправки событий в очередь сообщений',
      'Паттерн, при котором состояние хранится как последовательность событий, а не как текущий снимок',
      'Механизм подписки на события других сервисов',
      'Инструмент для трассировки событий в системе',
    ],
    correctIndex: 1,
    explanation:
      'Event Sourcing -- паттерн, при котором состояние агрегата (сущности) хранится не как текущий снимок, а как последовательность событий, которые привели к этому состоянию. Пример: вместо хранения "баланс счёта = 500" хранятся события: "открыт счёт", "внесено 1000", "списано 500". Преимущества: полная история изменений (audit log), возможность восстановить состояние на любой момент, natural fit для event-driven архитектуры. Недостатки: сложность запросов (нужен CQRS), eventual consistency, управление схемой событий.',
  },
  {
    id: 'sd-microservices-026',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое CQRS (Command Query Responsibility Segregation)?',
    options: [
      'Паттерн разделения команд по приоритету выполнения',
      'Паттерн разделения моделей для чтения и записи данных',
      'Метод распределения запросов между микросервисами',
      'Алгоритм балансировки нагрузки',
    ],
    correctIndex: 1,
    explanation:
      'CQRS -- паттерн, разделяющий модель данных на две: Command Model (для записи) и Query Model (для чтения). Команды изменяют состояние, запросы только читают. Преимущества: оптимизация каждой модели под свои задачи (write model нормализована, read model денормализована для быстрых запросов), независимое масштабирование, упрощение сложных доменов. Часто используется вместе с Event Sourcing: события записываются в event store, проецируются в read-оптимизированные представления.',
  },
  {
    id: 'sd-microservices-027',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Как тестировать микросервисы? Опишите пирамиду тестирования для микросервисной архитектуры.',
    sampleAnswer:
      'Пирамида тестирования микросервисов: 1) Unit tests (основание, больше всего): тестирование бизнес-логики в изоляции, моки для внешних зависимостей. Быстрые, много. 2) Integration tests: тестирование взаимодействия с БД, внешними API (через test containers, in-memory БД). 3) Contract tests: проверка контрактов между consumer и provider сервисами (Pact, Spring Cloud Contract). Критично для независимого деплоя. 4) Component tests: тестирование сервиса целиком в изоляции, внешние сервисы замокированы. 5) E2E tests (вершина, меньше всего): тестирование всей системы с реальными сервисами. Медленные, хрупкие, но необходимы для критических путей. Дополнительно: Chaos testing (Chaos Monkey), Performance testing, Security testing. Принцип: чем выше в пирамиде, тем меньше тестов и они дороже в поддержке.',
    explanation:
      'Contract testing -- ключевое отличие от тестирования монолита. Оно позволяет команде уверенно деплоить свой сервис без поднятия всех зависимостей. Spotify, Netflix инвестируют в contract testing как critical practice для микросервисов.',
  },
  {
    id: 'sd-microservices-028',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Change Data Capture (CDC) и как он используется в микросервисах?',
    options: [
      'Механизм отслеживания изменений в коде сервисов',
      'Техника захвата изменений в БД и публикации их как событий для других сервисов',
      'Инструмент для версионирования схемы базы данных',
      'Метод кэширования данных между сервисами',
    ],
    correctIndex: 1,
    explanation:
      'Change Data Capture (CDC) -- техника захвата изменений в базе данных (INSERT, UPDATE, DELETE) и публикации их как событий. Debezium -- популярный инструмент, читающий WAL (Write-Ahead Log) БД и отправляющий изменения в Kafka. Применение в микросервисах: 1) Синхронизация данных между сервисами без Dual Write. 2) Построение read models для CQRS. 3) Data replication в аналитические системы. 4) Аудит изменений. Преимущество перед Transactional Outbox: не требует изменения кода приложения.',
  },
  {
    id: 'sd-microservices-029',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Какие паттерны управления конфигурацией используются в микросервисах?',
    sampleAnswer:
      'Паттерны управления конфигурацией: 1) Environment Variables: простейший подход, переменные окружения для каждого environment. Kubernetes ConfigMaps/Secrets. 2) External Configuration Store: централизованное хранилище (Consul, etcd, Spring Cloud Config, AWS Parameter Store). Сервисы загружают конфигурацию при старте или подписываются на изменения. 3) Configuration as Code: конфигурация в Git, применяется через CI/CD. GitOps подход. 4) Feature Flags: динамическое включение/выключение функций без деплоя (LaunchDarkly, Unleash). 5) Service Mesh configuration: конфигурация сетевых политик через control plane (Istio). Best practices: разделение секретов и конфигурации, версионирование, аудит изменений, different configs per environment, secrets encryption at rest.',
    explanation:
      '12-Factor App рекомендует хранить конфигурацию в environment variables. Для микросервисов важна возможность менять конфигурацию без передеплоя (hot reload). Feature flags особенно полезны для canary releases и A/B testing.',
  },
  {
    id: 'sd-microservices-030',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой протокол чаще всего используется для синхронной коммуникации между микросервисами?',
    options: [
      'FTP',
      'HTTP/REST или gRPC',
      'SMTP',
      'WebSocket',
    ],
    correctIndex: 1,
    explanation:
      'HTTP/REST и gRPC -- основные протоколы для синхронной (request-response) коммуникации между микросервисами. REST (HTTP + JSON) прост, универсален, легко отлаживается. gRPC (HTTP/2 + Protocol Buffers) обеспечивает более высокую производительность, строгую типизацию, поддержку streaming. Выбор зависит от требований: REST для публичных API и простых сценариев, gRPC для высоконагруженной межсервисной коммуникации. WebSocket используется для real-time, но не для типичного service-to-service взаимодействия.',
  },
  {
    id: 'sd-microservices-031',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Saga Orchestration и чем она отличается от Saga Choreography?',
    options: [
      'Orchestration быстрее, Choreography надёжнее',
      'В Orchestration центральный оркестратор управляет шагами, в Choreography сервисы реагируют на события без центрального координатора',
      'Orchestration использует синхронные вызовы, Choreography -- асинхронные',
      'Это разные названия одного паттерна',
    ],
    correctIndex: 1,
    explanation:
      'Saga Orchestration: центральный оркестратор (отдельный сервис) управляет последовательностью шагов, отправляя команды участникам и обрабатывая ответы. Плюсы: логика в одном месте, легко отслеживать состояние. Минусы: single point of failure, coupling к оркестратору. Saga Choreography: каждый сервис подписывается на события и решает, что делать дальше, публикуя свои события. Плюсы: loose coupling, нет центральной точки отказа. Минусы: сложно отследить общий прогресс, distributed logic. Выбор: choreography для простых саг (2-3 шага), orchestration для сложных с множеством шагов и ветвлений.',
  },
  {
    id: 'sd-microservices-032',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Как обеспечить консистентность данных между микросервисами при использовании Database per Service?',
    sampleAnswer:
      'Стратегии обеспечения консистентности: 1) Saga Pattern: распределённая транзакция через последовательность локальных транзакций с компенсирующими действиями при ошибке. 2) Eventual Consistency + Events: сервис публикует событие об изменении, другие сервисы обновляют свои данные асинхронно. Принимаем задержку синхронизации. 3) CQRS с Event Sourcing: единый источник правды (events), read models строятся асинхронно. 4) API Composition: для чтения агрегируем данные из нескольких сервисов в реальном времени через API calls. 5) Shared Database (антипаттерн, но иногда pragmatic choice): для тесно связанных сервисов временно. 6) Transactional Outbox + CDC: атомарная запись в БД и публикация события. Важно: eventual consistency требует изменения мышления -- не все данные должны быть консистентны немедленно. Бизнес часто толерантен к задержкам.',
    explanation:
      'Распределённые ACID-транзакции (2PC) не рекомендуются в микросервисах из-за blocking nature и проблем с доступностью. BASE (Basically Available, Soft state, Eventually consistent) -- альтернативная модель для микросервисов.',
  },
  {
    id: 'sd-microservices-033',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Anti-Corruption Layer (ACL) в микросервисах?',
    options: [
      'Слой защиты от SQL-инъекций',
      'Слой-адаптер, изолирующий домен сервиса от внешних систем или legacy-кода с отличающейся моделью',
      'Firewall между микросервисами',
      'Слой шифрования данных',
    ],
    correctIndex: 1,
    explanation:
      'Anti-Corruption Layer (ACL) -- паттерн из DDD, создающий изолирующий слой между доменом сервиса и внешней системой (legacy-монолит, сторонний API) с отличающейся или "грязной" моделью. ACL транслирует модели, защищая чистоту внутреннего домена. Пример: новый микросервис работает с современной моделью Order, а ACL преобразует запросы к/от legacy-системы с её устаревшей моделью. Особенно важен при Strangler Fig миграции с монолита.',
  },
  {
    id: 'sd-microservices-034',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Какие операционные вызовы (operational challenges) создают микросервисы и как с ними справляться?',
    sampleAnswer:
      'Операционные вызовы микросервисов: 1) Deployment complexity: решение -- CI/CD pipelines, Infrastructure as Code (Terraform), GitOps. 2) Monitoring & Observability: распределённый tracing (Jaeger, Zipkin), централизованные логи (ELK, Loki), метрики (Prometheus, Grafana). Three pillars of observability. 3) Service Discovery: Consul, etcd, Kubernetes DNS. 4) Configuration Management: централизованное хранилище, feature flags. 5) Security: service-to-service authentication (mTLS), API Gateway, secrets management (Vault). 6) Testing: contract testing, synthetic monitoring, chaos engineering. 7) Debugging: correlation IDs через все сервисы, structured logging. 8) Data consistency: eventual consistency patterns, Saga. 9) Network reliability: Circuit Breaker, Retry, Timeout, Bulkhead. Платформенный подход: выделенная Platform Team, предоставляющая инфраструктуру как продукт для продуктовых команд.',
    explanation:
      'Переход на микросервисы требует зрелых DevOps-практик. Netflix, Amazon инвестировали годы в создание внутренних платформ (Netflix OSS, AWS). Для небольших компаний managed services (Kubernetes на облаке, managed observability) снижают операционную нагрузку.',
  },
  {
    id: 'sd-microservices-035',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое Docker и какую роль он играет в микросервисной архитектуре?',
    sampleAnswer:
      'Docker -- платформа контейнеризации, позволяющая упаковать приложение со всеми зависимостями в изолированный контейнер. Роль в микросервисах: 1) Консистентная среда: "работает на моей машине" -- контейнер одинаков везде (dev, staging, prod). 2) Изоляция: каждый сервис в своём контейнере с собственными зависимостями. 3) Лёгковесность: контейнеры легче виртуальных машин, быстрый старт. 4) Масштабирование: легко запустить несколько экземпляров контейнера. 5) CI/CD: Docker image как артефакт сборки. 6) Микросервисы могут использовать разные языки/версии -- каждый в своём контейнере. Dockerfile описывает сборку image, docker-compose -- локальную оркестрацию нескольких сервисов.',
    explanation:
      'Docker стал де-факто стандартом для упаковки микросервисов. Kubernetes -- следующий уровень, оркестрирующий контейнеры в production. Альтернативы Docker: containerd, Podman.',
  },
  {
    id: 'sd-microservices-036',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какую роль играет Kubernetes в микросервисной архитектуре?',
    options: [
      'Язык программирования для микросервисов',
      'Платформа оркестрации контейнеров: управление деплоем, масштабированием, self-healing, service discovery',
      'База данных для хранения состояния сервисов',
      'Инструмент для написания unit-тестов',
    ],
    correctIndex: 1,
    explanation:
      'Kubernetes (K8s) -- платформа оркестрации контейнеров, ставшая стандартом для запуска микросервисов. Возможности: 1) Automated deployment & rollback: декларативное описание желаемого состояния. 2) Scaling: автоматическое масштабирование по CPU/memory/custom metrics. 3) Self-healing: автоматический перезапуск упавших контейнеров, замена unhealthy nodes. 4) Service Discovery & Load Balancing: встроенный DNS, Services. 5) Configuration & Secrets management: ConfigMaps, Secrets. 6) Storage orchestration: Persistent Volumes. K8s абстрагирует инфраструктуру, позволяя фокусироваться на приложениях.',
  },
  {
    id: 'sd-microservices-037',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Idempotent Consumer в контексте обработки сообщений?',
    options: [
      'Потребитель, который обрабатывает сообщения в строгом порядке',
      'Потребитель, способный безопасно обработать одно и то же сообщение несколько раз без побочных эффектов',
      'Потребитель, который может обрабатывать сообщения параллельно',
      'Потребитель с гарантированной доставкой',
    ],
    correctIndex: 1,
    explanation:
      'Idempotent Consumer -- паттерн, при котором обработчик сообщений может безопасно получить и обработать одно сообщение несколько раз. Это критично, потому что message brokers обычно гарантируют at-least-once delivery, а не exactly-once. Реализация: 1) Хранение processed message IDs в БД и проверка перед обработкой. 2) Использование UPSERT вместо INSERT. 3) Идемпотентные операции в бизнес-логике. 4) Deduplication table с message_id и timestamp. Без idempotency дублирующее сообщение может привести к двойному списанию денег, дублированию заказа и т.д.',
  },
  {
    id: 'sd-microservices-038',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Как организовать логирование в микросервисной архитектуре?',
    sampleAnswer:
      'Стратегия логирования в микросервисах: 1) Structured logging: логи в JSON-формате с полями (timestamp, level, service, trace_id, message, context). Легко парсить и искать. 2) Correlation ID: уникальный идентификатор запроса, передаваемый через все сервисы в цепочке. Позволяет собрать все логи одного бизнес-процесса. 3) Централизованный сбор: все логи отправляются в единое хранилище (ELK Stack: Elasticsearch + Logstash + Kibana, или Loki + Grafana). 4) Log aggregation: fluentd, filebeat, promtail собирают логи с контейнеров. 5) Log levels: ERROR для ошибок, WARN для потенциальных проблем, INFO для бизнес-событий, DEBUG для отладки. 6) Retention policy: старые логи архивируются или удаляются. 7) PII redaction: маскирование персональных данных.',
    explanation:
      'Без централизованного логирования отладка в микросервисах превращается в кошмар -- приходится подключаться к каждому контейнеру. Correlation ID -- must have для трассировки запроса через десятки сервисов. OpenTelemetry стандартизирует логи, метрики и трейсы.',
  },
  {
    id: 'sd-microservices-039',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое паттерн Ambassador в микросервисах?',
    options: [
      'Главный сервис, координирующий работу других',
      'Вспомогательный контейнер-прокси, обрабатывающий сетевой трафик сервиса (retry, circuit breaking, TLS)',
      'Сервис для межсервисной аутентификации',
      'Паттерн для миграции с монолита',
    ],
    correctIndex: 1,
    explanation:
      'Ambassador -- паттерн, при котором рядом с основным контейнером сервиса размещается proxy-контейнер, обрабатывающий исходящий сетевой трафик. Ambassador берёт на себя: retry logic, circuit breaking, timeouts, TLS termination, service discovery, load balancing. Это позволяет вынести cross-cutting concerns из кода приложения в инфраструктуру. Ambassador -- частный случай Sidecar pattern. Envoy Proxy часто используется как Ambassador. Service Mesh (Istio) использует этот паттерн для всех сервисов.',
  },
  {
    id: 'sd-microservices-040',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое RabbitMQ и для чего он используется?',
    options: [
      'База данных для хранения сообщений',
      'Message broker для асинхронной коммуникации между сервисами через очереди сообщений',
      'Инструмент для мониторинга микросервисов',
      'Платформа для деплоя контейнеров',
    ],
    correctIndex: 1,
    explanation:
      'RabbitMQ -- message broker, реализующий протокол AMQP. Используется для асинхронной коммуникации между микросервисами. Ключевые концепции: Producer отправляет сообщения в Exchange, Exchange маршрутизирует их в Queue по правилам (routing key, binding), Consumer читает из Queue. Паттерны: Point-to-Point (одна очередь, один потребитель), Pub/Sub (fanout exchange), Topic routing. Преимущества: надёжная доставка, acknowledgments, persistence, clustering. Альтернативы: Apache Kafka (для event streaming), AWS SQS (managed).',
  },
  {
    id: 'sd-microservices-041',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'В чём разница между RabbitMQ и Apache Kafka? Когда использовать каждый?',
    sampleAnswer:
      'RabbitMQ: 1) Traditional message broker с очередями. 2) Сообщение удаляется после обработки (по умолчанию). 3) Smart broker, dumb consumers -- брокер маршрутизирует. 4) Лучше для: task queues, RPC, сложная маршрутизация сообщений, когда порядок не критичен. Apache Kafka: 1) Distributed event streaming platform. 2) Сообщения хранятся в топике (log) и не удаляются после чтения (retention period). 3) Dumb broker, smart consumers -- consumer отслеживает offset. 4) Высокая пропускная способность, горизонтальное масштабирование. 5) Лучше для: event sourcing, event streaming, аналитика в реальном времени, когда нужна история событий и replay. Выбор: RabbitMQ для классического messaging (task distribution), Kafka для event streaming и когда важна история событий.',
    explanation:
      'Kafka изначально создавался LinkedIn для высоконагруженного event streaming. RabbitMQ -- более традиционный message broker. Современные системы часто используют оба: RabbitMQ для command/task processing, Kafka для event streaming и аналитики.',
  },
  {
    id: 'sd-microservices-042',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать graceful shutdown в микросервисе?',
    sampleAnswer:
      'Graceful shutdown -- корректное завершение работы сервиса без потери запросов. Шаги: 1) Перехват сигналов завершения (SIGTERM, SIGINT): ОС/Kubernetes отправляет сигнал при остановке. 2) Прекращение приёма новых запросов: отметить сервис как unhealthy в readiness probe, чтобы load balancer перестал направлять трафик. 3) Ожидание завершения текущих запросов: дождаться обработки in-flight requests (с таймаутом). 4) Закрытие соединений: graceful close для HTTP connections, database connections, message consumers. 5) Завершение background jobs: дождаться или сохранить состояние для restart. 6) Освобождение ресурсов: закрыть файлы, очистить временные данные. В Kubernetes: preStop hook для задержки перед SIGTERM, terminationGracePeriodSeconds для таймаута. Без graceful shutdown при деплое часть запросов может получить ошибки connection reset.',
    explanation:
      'Kubernetes отправляет SIGTERM, ждёт terminationGracePeriodSeconds (по умолчанию 30с), затем SIGKILL. preStop hook позволяет добавить задержку, чтобы load balancer успел обновить endpoints. Это критично для zero-downtime deployments.',
  },
  {
    id: 'sd-microservices-043',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Feature Flags и как они используются в микросервисах?',
    options: [
      'Флаги для отладки в production',
      'Механизм включения/выключения функций без деплоя, используемый для canary releases, A/B testing, kill switches',
      'Индикаторы состояния health check',
      'Параметры командной строки при запуске сервиса',
    ],
    correctIndex: 1,
    explanation:
      'Feature Flags (Feature Toggles) -- механизм динамического включения/выключения функциональности без изменения кода и деплоя. Применения: 1) Canary releases: новая функция включена для 5% пользователей. 2) A/B testing: разные варианты для разных сегментов. 3) Kill switch: мгновенное отключение проблемной функции. 4) Trunk-based development: незавершённый код за флагом в main branch. Инструменты: LaunchDarkly, Unleash, Flagsmith, самописные на Redis. Важно: удалять старые флаги после полного раската, иначе накапливается технический долг.',
  },
  {
    id: 'sd-microservices-044',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Dead Letter Queue (DLQ) и зачем она нужна?',
    options: [
      'Очередь для хранения архивных сообщений',
      'Очередь для сообщений, которые не удалось обработать после нескольких попыток, для последующего анализа',
      'Приоритетная очередь для срочных сообщений',
      'Очередь для broadcast-сообщений',
    ],
    correctIndex: 1,
    explanation:
      'Dead Letter Queue (DLQ) -- специальная очередь, куда перенаправляются сообщения, которые не удалось обработать после заданного количества попыток (retries). Причины попадания в DLQ: ошибка десериализации, exception в обработчике, таймаут, отсутствующий consumer. Зачем нужна: 1) Предотвращает "poison message" от блокировки очереди. 2) Позволяет анализировать проблемные сообщения. 3) Можно повторно обработать после исправления бага. 4) Мониторинг и алертинг на сообщения в DLQ. RabbitMQ, Kafka, SQS поддерживают DLQ.',
  },
  {
    id: 'sd-microservices-045',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое API Versioning в микросервисах и какие стратегии существуют?',
    sampleAnswer:
      'API Versioning необходимо для изменения API без поломки существующих клиентов. Стратегии: 1) URL path versioning: /api/v1/users, /api/v2/users. Просто, наглядно, легко маршрутизировать. Наиболее популярен. 2) Query parameter: /api/users?version=2. Менее очевидно. 3) Header versioning: Accept: application/vnd.api.v2+json или X-API-Version: 2. Чище URL, но сложнее тестировать. 4) No versioning (evolution): только backward-compatible изменения, deprecation вместо удаления. Подходит для GraphQL. В микросервисах: внутренние API могут использовать header versioning или evolution (все сервисы деплоятся вместе). Публичные API требуют explicit versioning и deprecation policy.',
    explanation:
      'Google, Stripe, Twitter используют URL path versioning для публичных API. Важно документировать deprecation timeline (например, v1 поддерживается 2 года после выхода v2) и уведомлять клиентов о предстоящих изменениях.',
  },
  {
    id: 'sd-microservices-046',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Load Balancer в контексте микросервисов?',
    options: [
      'Инструмент для оптимизации базы данных',
      'Компонент, распределяющий входящий трафик между несколькими экземплярами сервиса',
      'Система мониторинга нагрузки',
      'Механизм кэширования ответов',
    ],
    correctIndex: 1,
    explanation:
      'Load Balancer распределяет входящий трафик между несколькими инстансами сервиса для: равномерной нагрузки, высокой доступности (при падении одного инстанса трафик идёт на другие), горизонтального масштабирования. Алгоритмы: Round Robin, Least Connections, IP Hash, Weighted. Виды: L4 (транспортный уровень, TCP/UDP), L7 (application level, HTTP, может маршрутизировать по URL, headers). Примеры: Nginx, HAProxy, AWS ALB/NLB, Kubernetes Service.',
  },
  {
    id: 'sd-microservices-047',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Как спроектировать систему для обработки высокой нагрузки в микросервисной архитектуре?',
    sampleAnswer:
      'Стратегии для высокой нагрузки: 1) Horizontal scaling: увеличение количества инстансов сервиса. Stateless design необходим. 2) Asynchronous processing: вынести тяжёлые операции в background jobs через очереди. Immediate response + async completion. 3) Caching: Redis/Memcached для hot data, CDN для статики, local cache для read-heavy данных. 4) Database optimization: read replicas, sharding, appropriate indexes, connection pooling. 5) Rate limiting: защита от перегрузки, graceful degradation. 6) Circuit Breaker: изоляция failing dependencies. 7) Load shedding: отклонение excess нагрузки при приближении к лимиту. 8) Auto-scaling: HPA в Kubernetes на основе CPU/custom metrics. 9) Event-driven architecture: decouple producers и consumers через Kafka/RabbitMQ. 10) Performance testing: load testing (k6, Locust) для выявления bottlenecks до production.',
    explanation:
      'Ключевой принцип: design for failure и design for scale с самого начала. Netflix, Amazon проектируют системы, способные gracefully деградировать под нагрузкой. Capacity planning и регулярный load testing -- обязательные практики.',
  },
  {
    id: 'sd-microservices-048',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой принцип описывает правило "один сервис -- одна команда"?',
    options: [
      'Single Responsibility Principle',
      'Conway Law (закон Конвея)',
      'DRY (Dont Repeat Yourself)',
      'KISS (Keep It Simple, Stupid)',
    ],
    correctIndex: 1,
    explanation:
      'Закон Конвея: "Организации проектируют системы, которые копируют структуру коммуникаций в организации". В контексте микросервисов это означает, что структура сервисов должна отражать структуру команд. Один сервис должен принадлежать одной команде (ownership). Inverse Conway Maneuver: изменить структуру команд для получения желаемой архитектуры системы. Amazon Two-Pizza Teams (команда, которую можно накормить двумя пиццами) -- практическое применение.',
  },
  {
    id: 'sd-microservices-049',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое Data Mesh и как он связан с микросервисами?',
    sampleAnswer:
      'Data Mesh -- архитектурный подход к управлению данными, применяющий принципы микросервисов к аналитическим данным. Принципы: 1) Domain-oriented ownership: данные принадлежат доменным командам (те же, что владеют микросервисами), а не централизованной data team. 2) Data as a Product: каждый домен публикует свои данные как продукт с SLA, документацией, качеством. 3) Self-serve data platform: платформа предоставляет инструменты для публикации и потребления данных без bottleneck на data engineers. 4) Federated governance: общие стандарты (форматы, security) при автономии доменов. Связь с микросервисами: та же команда, владеющая Order Service, владеет и Order Data Product. Это устраняет проблему, когда данные застревают в монолитном Data Warehouse/Lake, управляемом отдельной командой.',
    explanation:
      'Data Mesh предложен Zhamak Dehghani (ThoughtWorks) как ответ на проблемы централизованных data platforms. Как микросервисы децентрализовали разработку, Data Mesh децентрализует управление данными. Требует зрелой инженерной культуры и платформы.',
  },
  {
    id: 'sd-microservices-050',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Compensating Transaction в Saga?',
    options: [
      'Транзакция, увеличивающая производительность',
      'Транзакция, отменяющая эффект предыдущей успешной транзакции при ошибке в последующих шагах Saga',
      'Транзакция между двумя базами данных',
      'Резервная транзакция при падении основной',
    ],
    correctIndex: 1,
    explanation:
      'Compensating Transaction -- транзакция, отменяющая (компенсирующая) эффект ранее успешно выполненной локальной транзакции в Saga. Пример: если Saga "Создание заказа" прошла шаги "Создать заказ" и "Зарезервировать товар", но "Списать деньги" не удалось, выполняются компенсации: "Отменить резерв товара" и "Отменить заказ". Особенности: компенсация не всегда тривиальна (как отменить отправленный email?), порядок компенсаций обратный порядку основных шагов, компенсирующие транзакции тоже должны быть idempotent и могут fail (требуют retry).',
  },
];
