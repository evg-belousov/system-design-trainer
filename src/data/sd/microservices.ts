import type { Question } from '../types';

export const microservicesQuestions: Question[] = [
  {
    id: 'sd-ms-001',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какое основное преимущество микросервисной архитектуры перед монолитной?',
    options: [
      'Микросервисы всегда работают быстрее монолита',
      'Микросервисы проще разрабатывать, чем монолит',
      'Каждый микросервис можно разрабатывать, деплоить и масштабировать независимо',
      'Микросервисы не требуют мониторинга',
    ],
    correctIndex: 2,
    explanation:
      'Главное преимущество микросервисной архитектуры -- независимость компонентов. Каждый сервис может разрабатываться отдельной командой, использовать подходящий технологический стек, деплоиться по собственному расписанию и масштабироваться в зависимости от нагрузки. Это позволяет большим организациям двигаться быстрее. Однако микросервисы привносят значительную операционную сложность: распределённые транзакции, сетевая коммуникация, мониторинг, отладка, согласованность данных.',
  },
  {
    id: 'sd-ms-002',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое паттерн Circuit Breaker в микросервисной архитектуре?',
    options: [
      'Механизм маршрутизации запросов между сервисами',
      'Паттерн, предотвращающий каскадные отказы путём прекращения вызовов к недоступному сервису',
      'Способ разделения данных между микросервисами',
      'Инструмент для автоматического масштабирования сервисов',
    ],
    correctIndex: 1,
    explanation:
      'Circuit Breaker (автоматический выключатель) -- паттерн, заимствованный из электротехники. Он отслеживает количество ошибок при вызове внешнего сервиса. Когда ошибки превышают порог, «выключатель» размыкается и последующие запросы немедленно возвращают ошибку без попытки вызова (fail fast). Через заданное время выключатель переходит в полуоткрытое состояние, пропуская пробный запрос. Если он успешен -- выключатель замыкается. Это предотвращает каскадные отказы, экономит ресурсы и даёт время на восстановление. Реализации: Netflix Hystrix (устарел), Resilience4j, Polly.',
  },
  {
    id: 'sd-ms-003',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн Saga для управления распределёнными транзакциями в микросервисной архитектуре. Какие виды Saga существуют и какие у них недостатки?',
    sampleAnswer:
      'Saga -- паттерн управления распределёнными транзакциями, где длинная транзакция разбивается на последовательность локальных транзакций в разных сервисах. Каждая локальная транзакция обновляет данные в своём сервисе и публикует событие, запускающее следующий шаг. При ошибке выполняются компенсирующие транзакции в обратном порядке. Виды Saga: 1) Хореография (Choreography): каждый сервис слушает события и решает, что делать дальше. Нет центрального координатора. Просто для малого числа шагов, но сложно отслеживать общий прогресс и отлаживать. 2) Оркестрация (Orchestration): центральный оркестратор управляет последовательностью шагов, отправляя команды сервисам. Логика в одном месте, легче отслеживать, но оркестратор может стать единой точкой отказа. Недостатки Saga: нет изоляции (промежуточные состояния видны другим транзакциям), компенсирующие транзакции сложно реализовать (как «отменить» отправленный email?), сложность отладки, eventual consistency.',
    explanation:
      'Saga -- альтернатива двухфазному коммиту (2PC), который плохо работает в микросервисах из-за блокирующей природы и зависимости от координатора. Пример Saga для заказа: 1) Создать заказ -> 2) Зарезервировать товар -> 3) Списать деньги -> 4) Подтвердить заказ. Если шаг 3 не удался: компенсация шага 2 (вернуть товар на склад) -> компенсация шага 1 (отменить заказ). На практике используется в e-commerce, банковских системах, бронировании.',
  },
  {
    id: 'sd-ms-004',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое API Gateway в микросервисной архитектуре? Какие функции он выполняет?',
    sampleAnswer:
      'API Gateway -- это единая точка входа для всех клиентских запросов в микросервисной архитектуре. Он выступает обратным прокси, маршрутизируя запросы к соответствующим микросервисам. Основные функции: 1) Маршрутизация запросов к нужным сервисам на основе URL, заголовков или содержимого. 2) Аутентификация и авторизация -- централизованная проверка токенов (JWT, OAuth). 3) Rate limiting -- ограничение частоты запросов. 4) Агрегация ответов -- объединение данных от нескольких сервисов в один ответ. 5) Протокольная трансляция -- преобразование REST в gRPC и наоборот. 6) Кэширование на уровне gateway. 7) Логирование и мониторинг. 8) SSL-терминация. Примеры: Kong, AWS API Gateway, Nginx, Envoy + Istio.',
    explanation:
      'API Gateway реализует паттерн «фасад» для микросервисов. Без него клиенту пришлось бы знать адреса всех сервисов, управлять аутентификацией в каждом запросе и делать множественные вызовы для сборки одной страницы. Однако gateway может стать узким местом и единой точкой отказа, поэтому его нужно масштабировать и обеспечивать высокую доступность.',
  },
  {
    id: 'sd-ms-005',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн позволяет каждому микросервису иметь собственную базу данных, обеспечивая при этом консистентность данных между сервисами?',
    options: [
      'Shared Database -- все сервисы используют общую БД',
      'Database per Service + Event-Driven Architecture с eventual consistency',
      'Two-Phase Commit (2PC) между всеми сервисами',
      'Distributed Lock Manager для синхронизации доступа к данным',
    ],
    correctIndex: 1,
    explanation:
      'Паттерн Database per Service предполагает, что каждый микросервис владеет своими данными и не обращается напрямую к базам данных других сервисов. Консистентность обеспечивается через событийную архитектуру (Event-Driven): при изменении данных сервис публикует событие, другие сервисы подписываются и обновляют свои локальные данные. Это обеспечивает eventual consistency. Shared Database нарушает принцип изолированности, 2PC плохо масштабируется, а Distributed Lock Manager создаёт узкое место.',
  },
  {
    id: 'sd-microservices-006',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое Service Discovery (обнаружение сервисов) в микросервисной архитектуре?',
    options: [
      'Процесс тестирования новых микросервисов',
      'Механизм, позволяющий сервисам автоматически находить сетевые адреса других сервисов',
      'Инструмент для документирования API микросервисов',
      'Процедура ручной настройки IP-адресов в конфигурационных файлах',
    ],
    correctIndex: 1,
    explanation:
      'Service Discovery -- механизм, позволяющий микросервисам автоматически находить сетевые адреса (IP:port) других сервисов. В динамической среде (контейнеры, автоскейлинг) адреса сервисов постоянно меняются, и жёсткое кодирование адресов невозможно. Два подхода: 1) Client-side discovery -- клиент запрашивает реестр сервисов (Consul, Eureka) и сам выбирает экземпляр. 2) Server-side discovery -- клиент обращается к load balancer/DNS, который знает о доступных экземплярах (Kubernetes Services, AWS ELB). Kubernetes использует встроенный DNS для service discovery.',
  },
  {
    id: 'sd-microservices-007',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой подход к коммуникации между микросервисами является асинхронным?',
    options: [
      'HTTP REST вызов с ожиданием ответа',
      'gRPC вызов с ожиданием ответа',
      'Обмен сообщениями через брокер (RabbitMQ, Kafka)',
      'GraphQL запрос к другому сервису',
    ],
    correctIndex: 2,
    explanation:
      'Обмен сообщениями через брокер (message broker) -- основной способ асинхронной коммуникации между микросервисами. Сервис-отправитель публикует сообщение в очередь или топик и продолжает работу, не ожидая ответа. Сервис-получатель обрабатывает сообщение, когда готов. Преимущества: развязка сервисов, буферизация нагрузки, отказоустойчивость. HTTP REST и gRPC -- синхронные подходы (request-response), где вызывающий сервис блокируется до получения ответа. Популярные брокеры: RabbitMQ, Apache Kafka, AWS SQS.',
  },
  {
    id: 'sd-microservices-008',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой антипаттерн возникает, когда микросервисы слишком сильно зависят друг от друга и требуют синхронных вызовов между собой?',
    options: [
      'Event Sourcing',
      'Distributed Monolith (распределённый монолит)',
      'Sidecar Pattern',
      'Database per Service',
    ],
    correctIndex: 1,
    explanation:
      'Distributed Monolith (распределённый монолит) -- антипаттерн, при котором система формально разделена на микросервисы, но они настолько тесно связаны (tight coupling), что должны деплоиться, масштабироваться и изменяться вместе. Это сочетает недостатки монолита (невозможность независимых изменений) и микросервисов (сложность распределённой системы, сетевые задержки, трудность отладки). Признаки: синхронные цепочки вызовов, общая база данных, совместный деплой, каскадные отказы.',
  },
  {
    id: 'sd-microservices-009',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Sidecar-паттерн в микросервисной архитектуре?',
    options: [
      'Резервный экземпляр каждого сервиса для failover',
      'Вспомогательный процесс/контейнер, развёрнутый рядом с основным сервисом для обеспечения инфраструктурных функций',
      'Механизм синхронизации данных между базами данных сервисов',
      'Паттерн для маршрутизации трафика между дата-центрами',
    ],
    correctIndex: 1,
    explanation:
      'Sidecar-паттерн предполагает размещение вспомогательного процесса (sidecar) рядом с основным сервисом в одном pod (Kubernetes) или на одном хосте. Sidecar берёт на себя инфраструктурные задачи: проксирование трафика (Envoy), логирование, мониторинг, service mesh функции (mTLS, retry, circuit breaking), обнаружение сервисов. Преимущества: основной сервис не содержит инфраструктурного кода, sidecar может быть написан на любом языке, единообразие инфраструктурных функций для всех сервисов. Это основа архитектуры Service Mesh (Istio, Linkerd).',
  },
  {
    id: 'sd-microservices-010',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое Strangler Fig Pattern и как он используется для миграции с монолита на микросервисы?',
    sampleAnswer:
      'Strangler Fig Pattern (паттерн «Душитель») -- стратегия постепенной миграции монолитного приложения на микросервисы, названная по аналогии с тропическим растением, которое постепенно обвивает и замещает дерево-хозяина. Процесс: 1) Новая функциональность реализуется как микросервис, а не добавляется в монолит. 2) Существующая функциональность постепенно выносится из монолита в микросервисы. 3) Proxy/API Gateway маршрутизирует запросы: часть -- к микросервисам, часть -- к монолиту. 4) Со временем монолит уменьшается и в итоге полностью замещается. Преимущества: нет «большого взрыва» (big bang migration), система всегда работоспособна, возможность отката, команда постепенно набирает опыт с микросервисами. Пример: Amazon перешёл от монолита к микросервисам в течение нескольких лет, вынося компоненты по одному.',
    explanation:
      'Strangler Fig Pattern предложен Мартином Фаулером. Ключевые рекомендации: начинать с наименее связанных модулей монолита, использовать anti-corruption layer для изоляции нового кода от legacy, определять чёткие границы (bounded contexts по DDD) перед выносом. Типичная ошибка -- пытаться мигрировать всё сразу, что приводит к распределённому монолиту.',
  },
  {
    id: 'sd-microservices-011',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Service Mesh?',
    options: [
      'Специальная база данных для хранения конфигураций микросервисов',
      'Инфраструктурный слой, управляющий межсервисной коммуникацией через sidecar-прокси с поддержкой mTLS, observability и traffic management',
      'Метод декомпозиции монолита на микросервисы',
      'API для тестирования микросервисов в изоляции',
    ],
    correctIndex: 1,
    explanation:
      'Service Mesh -- инфраструктурный слой для управления коммуникацией между микросервисами. Состоит из: 1) Data plane -- sidecar-прокси (обычно Envoy), установленные рядом с каждым сервисом, перехватывающие весь входящий/исходящий трафик. 2) Control plane -- централизованное управление (Istiod в Istio, Linkerd control plane). Функции: mTLS (шифрование и аутентификация межсервисного трафика), observability (метрики, трейсинг, логи), traffic management (canary releases, fault injection, retries, circuit breaking), authorization policies. Популярные реализации: Istio, Linkerd, Consul Connect. Service Mesh выносит сетевую логику из кода приложения в инфраструктуру.',
  },
  {
    id: 'sd-microservices-012',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите паттерн API Composition. Как агрегировать данные из нескольких микросервисов для одного запроса клиента?',
    sampleAnswer:
      'API Composition -- паттерн, при котором специальный компонент (API Composer/Aggregator) собирает данные из нескольких микросервисов в один ответ для клиента. Например, страница товара требует данных из сервисов: каталога (описание), ценообразования (цена), склада (остатки), отзывов (рейтинг). Варианты реализации: 1) API Gateway как composer: gateway делает параллельные запросы к сервисам и объединяет ответы. Подходит для простой агрегации. 2) BFF (Backend for Frontend): отдельный сервис для каждого типа клиента, выполняющий агрегацию. 3) GraphQL: schema stitching или federation позволяют прозрачно объединять данные из разных сервисов. Apollo Federation -- стандартный подход. Проблемы: 1) Как обрабатывать частичные ошибки (один сервис не ответил)? Отдать частичный ответ или ошибку? 2) Задержка определяется самым медленным сервисом. 3) Транзакционная консистентность не гарантируется. Решения: параллельные запросы, таймауты, fallback-значения, кэширование.',
    explanation:
      'API Composition -- альтернатива CQRS для запросов, затрагивающих данные нескольких сервисов. При высокой нагрузке рекомендуется использовать CQRS с предварительно построенными read-моделями (materialized views), чтобы избежать множественных запросов в runtime. Netflix активно использует GraphQL Federation для агрегации данных из десятков микросервисов.',
  },
  {
    id: 'sd-microservices-013',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое принцип «Database per Service» и зачем он нужен?',
    sampleAnswer:
      'Database per Service -- принцип, при котором каждый микросервис имеет собственную базу данных (или как минимум собственную схему), недоступную напрямую другим сервисам. Данные доступны только через API сервиса. Зачем: 1) Слабая связанность (loose coupling) -- изменение схемы БД одного сервиса не ломает другие. 2) Независимый деплой -- можно мигрировать БД одного сервиса без остановки других. 3) Свобода выбора технологии -- каждый сервис может использовать оптимальную БД (PostgreSQL для финансов, MongoDB для каталога, Redis для кэша). 4) Независимое масштабирование -- горячие сервисы масштабируют свою БД без влияния на другие. Недостатки: сложность join-запросов между сервисами (решается через API Composition или CQRS), eventual consistency вместо ACID-транзакций между сервисами, дублирование данных.',
    explanation:
      'Database per Service -- один из ключевых принципов микросервисной архитектуры. Альтернатива -- Shared Database -- проще в реализации, но создаёт сильную связанность между сервисами и является одной из главных причин появления «распределённого монолита».',
  },
  {
    id: 'sd-microservices-014',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое Contract Testing (контрактное тестирование) в микросервисах?',
    options: [
      'Тестирование юридических аспектов использования API',
      'Тестирование, проверяющее, что взаимодействие между сервисами соответствует согласованному контракту (формату запросов и ответов)',
      'Тестирование производительности каждого микросервиса',
      'Тестирование совместимости разных версий базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Contract Testing -- подход к тестированию, при котором проверяется, что consumer (вызывающий сервис) и provider (вызываемый сервис) согласованы по формату взаимодействия (контракту). Consumer пишет тесты, описывающие ожидаемый формат ответа от provider. Provider проверяет, что его реализация соответствует этим ожиданиям. Инструменты: Pact, Spring Cloud Contract. Преимущества: раннее обнаружение breaking changes, тестирование без поднятия всех зависимых сервисов, уверенность при независимом деплое. Contract testing дополняет, но не заменяет unit и integration тесты.',
  },
  {
    id: 'sd-microservices-015',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните стратегии деплоя микросервисов: Blue-Green, Canary и Rolling deployment.',
    sampleAnswer:
      '1) Blue-Green Deployment: поддерживаются два идентичных окружения (Blue -- текущее, Green -- новое). Новая версия деплоится в Green, тестируется, затем трафик мгновенно переключается с Blue на Green. Плюсы: мгновенный откат (переключение обратно на Blue), нет downtime, полное тестирование перед переключением. Минусы: двойные ресурсы, сложности с БД-миграциями (обе версии должны быть совместимы с одной БД). 2) Canary Deployment: новая версия разворачивается на небольшой части инфраструктуры (1-5% трафика). Метрики мониторятся, и при отсутствии проблем процент трафика постепенно увеличивается до 100%. Плюсы: минимальный risk blast radius, реальное тестирование на продакшн-трафике. Минусы: сложная маршрутизация, длительный процесс, необходимость хорошего мониторинга. 3) Rolling Deployment: экземпляры обновляются по одному (или группами). В любой момент часть экземпляров работает на старой версии, часть на новой. Плюсы: не требует двойных ресурсов, встроен в Kubernetes. Минусы: во время деплоя работают две версии одновременно, откат медленнее.',
    explanation:
      'Выбор стратегии зависит от требований к надёжности, скорости деплоя и доступных ресурсов. В Kubernetes rolling deployment -- стратегия по умолчанию (RollingUpdate). Canary часто реализуется через Istio, Flagger или Argo Rollouts. Blue-Green хорошо подходит для критических сервисов с низкой частотой деплоя.',
  },
  {
    id: 'sd-microservices-016',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Distributed Tracing и какую проблему он решает?',
    options: [
      'Метод шифрования данных при передаче между сервисами',
      'Механизм отслеживания запроса через цепочку микросервисов с помощью уникального trace ID для диагностики задержек и ошибок',
      'Способ распределения данных по разным базам данных',
      'Инструмент для автоматического масштабирования сервисов',
    ],
    correctIndex: 1,
    explanation:
      'Distributed Tracing (распределённая трассировка) позволяет отслеживать путь одного запроса через цепочку микросервисов. Каждый запрос получает уникальный trace ID, который передаётся между сервисами. Каждый сервис создаёт span (отрезок) с информацией о времени обработки, метаданных и ошибках. Это позволяет визуализировать полную цепочку вызовов, находить узкие места (bottlenecks) и диагностировать ошибки в распределённой системе. Стандарт: OpenTelemetry (объединяет OpenTracing и OpenCensus). Инструменты: Jaeger, Zipkin, Datadog APM, AWS X-Ray.',
  },
  {
    id: 'sd-microservices-017',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'junior',
    type: 'open',
    question: 'Какие основные недостатки микросервисной архитектуры по сравнению с монолитом?',
    sampleAnswer:
      'Основные недостатки микросервисов: 1) Операционная сложность: необходимы CI/CD пайплайны для каждого сервиса, оркестрация контейнеров (Kubernetes), мониторинг десятков/сотен сервисов. 2) Сетевая сложность: вызовы между сервисами идут по сети, что добавляет задержку, возможность ошибок, необходимость retry и circuit breaker. 3) Распределённые транзакции: ACID-транзакции между сервисами невозможны, нужны Saga, eventual consistency. 4) Отладка и тестирование: сложно отследить проблему через цепочку сервисов, нужен distributed tracing. E2E тесты требуют поднятия множества сервисов. 5) Дублирование данных: данные из одного сервиса часто нужны другим, что приводит к дублированию и рассинхронизации. 6) Организационная сложность: нужны DevOps-практики, зрелые команды, чёткое определение границ сервисов. 7) Overhead в производительности: сериализация/десериализация, сетевые вызовы вместо вызовов функций в памяти.',
    explanation:
      'Микросервисы не являются «серебряной пулей». Мартин Фаулер рекомендует «Monolith First» подход: начинать с монолита и переходить на микросервисы только когда появляются реальные проблемы масштабирования команды или системы. Для небольших команд (до 10-15 человек) монолит часто является лучшим выбором.',
  },
  {
    id: 'sd-microservices-018',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'open',
    question: 'Что такое Shared Nothing Architecture и как она применяется в микросервисах?',
    sampleAnswer:
      'Shared Nothing Architecture -- архитектурный подход, при котором каждый узел системы полностью автономен: имеет собственные вычислительные ресурсы, память, хранилище данных и не разделяет их с другими узлами. В контексте микросервисов это означает: 1) Каждый сервис имеет собственную базу данных (Database per Service). 2) Нет общих библиотек с бизнес-логикой (shared libraries ограничиваются утилитами). 3) Нет общего состояния в памяти (shared memory/cache). 4) Каждый сервис может масштабироваться и деплоиться независимо. 5) Коммуникация только через чётко определённые API или события. Преимущества: линейная масштабируемость (добавление узлов увеличивает мощность пропорционально), изоляция отказов, независимость команд. Недостатки: сложность координации, дублирование данных и логики, eventual consistency. Shared Nothing -- противоположность Shared Everything (монолит с общей БД).',
    explanation:
      'Shared Nothing Architecture -- фундамент горизонтального масштабирования. Его используют Google (Bigtable, Spanner), Amazon (DynamoDB, микросервисы), Facebook. В реальности идеальный «shared nothing» редко достижим: сервисы всё равно разделяют сеть, Service Discovery, конфигурацию. Важно минимизировать общие зависимости и стремиться к максимальной автономности каждого сервиса.',
  },
  {
    id: 'sd-microservices-019',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой паттерн наблюдаемости (observability) включает три основных компонента: метрики, логи и трейсы?',
    options: [
      'Circuit Breaker pattern',
      'Three Pillars of Observability (Три столпа наблюдаемости)',
      'Event Sourcing pattern',
      'Health Check pattern',
    ],
    correctIndex: 1,
    explanation:
      'Three Pillars of Observability (три столпа наблюдаемости) -- концепция, определяющая три ключевых источника данных для понимания состояния распределённой системы: 1) Метрики (Metrics) -- числовые показатели (CPU, память, latency, error rate, RPS). Инструменты: Prometheus, Datadog, CloudWatch. 2) Логи (Logs) -- записи событий с деталями. Инструменты: ELK stack (Elasticsearch, Logstash, Kibana), Loki. 3) Трейсы (Traces) -- путь запроса через цепочку сервисов. Инструменты: Jaeger, Zipkin, Tempo. Вместе они позволяют: обнаруживать проблемы (метрики и алерты), локализовать причину (трейсы), детально анализировать (логи). OpenTelemetry стремится унифицировать сбор всех трёх типов данных.',
  },
  {
    id: 'sd-microservices-020',
    block: 'sd',
    topic: 'microservices',
    topicLabel: 'Микросервисы',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой паттерн рекомендуется для обеспечения атомарности записи в базу данных и публикации события в микросервисах?',
    options: [
      'Two-Phase Commit (2PC) между базой данных и брокером сообщений',
      'Transactional Outbox -- запись события в специальную таблицу outbox в той же транзакции, что и бизнес-данные',
      'Двойная запись (dual write) -- запись и в базу, и в брокер последовательно',
      'Periodic batch export -- периодическая выгрузка всех изменений в брокер',
    ],
    correctIndex: 1,
    explanation:
      'Transactional Outbox -- паттерн, решающий проблему атомарности записи в БД и публикации события. Вместо прямой публикации в брокер сообщений, сервис записывает событие в таблицу outbox в той же транзакции, что и бизнес-данные. Отдельный процесс (relay/poller) читает события из outbox и публикует их в брокер, затем помечает как отправленные. Альтернатива -- Change Data Capture (CDC): Debezium считывает WAL базы данных и автоматически публикует изменения. Dual write (запись в БД + брокер отдельно) -- антипаттерн, так как при сбое между двумя операциями данные рассинхронизируются.',
  },
];
