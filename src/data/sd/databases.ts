import type { Question } from '../types';

export const sdDatabasesQuestions: Question[] = [
  {
    id: 'sd-db-001',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'В чём ключевое различие между SQL и NoSQL базами данных?',
    options: [
      'SQL базы данных всегда быстрее NoSQL',
      'SQL базы данных используют фиксированную схему и язык SQL, NoSQL -- гибкие схемы и разные модели данных',
      'NoSQL базы данных не поддерживают репликацию',
      'SQL базы данных не подходят для горизонтального масштабирования',
    ],
    correctIndex: 1,
    explanation:
      'SQL (реляционные) базы данных используют фиксированные схемы с таблицами, строками и столбцами и язык SQL для запросов. Они обеспечивают ACID-транзакции и строгую консистентность. NoSQL базы данных предлагают гибкие модели данных (документные, колоночные, ключ-значение, графовые), не требуют фиксированной схемы и обычно лучше масштабируются горизонтально. Выбор зависит от структуры данных, требований к консистентности и масштабируемости.',
  },
  {
    id: 'sd-db-002',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое репликация Master-Slave (Primary-Replica) и какую проблему она решает?',
    options: [
      'Автоматическое резервное копирование данных на ленточные накопители',
      'Главная реплика принимает запись, а вторичные обслуживают чтение, что увеличивает пропускную способность и отказоустойчивость',
      'Разделение данных по горизонтали между несколькими серверами',
      'Шифрование данных при передаче между серверами',
    ],
    correctIndex: 1,
    explanation:
      'В схеме Master-Slave (Primary-Replica) один сервер (master/primary) принимает все операции записи и реплицирует изменения на один или несколько slave/replica серверов. Replica-серверы обслуживают запросы на чтение, что позволяет распределить нагрузку чтения (read scaling). При выходе из строя master-а один из slave может быть промотирован до нового master-а (failover). Важно учитывать задержку репликации (replication lag), которая может привести к чтению устаревших данных.',
  },
  {
    id: 'sd-db-003',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Когда стоит выбрать документную базу данных (например, MongoDB) вместо реляционной (например, PostgreSQL)? Приведите конкретные примеры.',
    sampleAnswer:
      'Документная БД предпочтительна в следующих случаях: 1) Данные имеют иерархическую или вложенную структуру, которая плохо ложится в реляционную модель (каталог товаров с разными атрибутами для разных категорий, профили пользователей с переменным набором полей). 2) Схема данных часто меняется на ранних стадиях разработки -- schema-less подход ускоряет итерации. 3) Нужна горизонтальная масштабируемость из коробки -- MongoDB поддерживает шардирование как встроенную функцию. 4) Паттерн доступа -- чтение/запись целых документов (не нужны сложные JOIN-ы). 5) Контентные системы (CMS), системы управления конфигурациями, IoT-платформы. Реляционная БД лучше подходит, когда важны: сложные связи между данными, ACID-транзакции, сложные аналитические запросы, строгая схема данных.',
    explanation:
      'Выбор между SQL и NoSQL -- не вопрос «что лучше», а вопрос «что подходит». На практике многие системы используют полиглотное хранение (polyglot persistence): реляционную БД для транзакционных данных, документную для каталогов, Redis для кэша, Elasticsearch для полнотекстового поиска. Важно выбирать СУБД исходя из паттернов доступа, требований к консистентности и масштабу.',
  },
  {
    id: 'sd-db-004',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните принцип ACID в контексте распределённых баз данных. Почему полноценные ACID-транзакции сложно реализовать в распределённых системах?',
    sampleAnswer:
      'ACID -- это набор свойств транзакций: Atomicity (атомарность -- транзакция выполняется полностью или не выполняется), Consistency (консистентность -- данные переходят из одного валидного состояния в другое), Isolation (изоляция -- параллельные транзакции не влияют друг на друга), Durability (долговечность -- результаты зафиксированной транзакции сохраняются). В распределённых системах ACID сложно реализовать потому что: 1) Атомарность требует координации между узлами (2PC -- two-phase commit протокол, который медленный и блокирующий). 2) Консистентность в условиях сетевых разделений невозможна одновременно с доступностью (CAP-теорема). 3) Изоляция на уровне Serializable в распределённой системе сильно снижает производительность. 4) Долговечность требует подтверждения записи от нескольких узлов (кворум). Поэтому многие NoSQL-системы предлагают ослабленные гарантии (BASE: Basically Available, Soft state, Eventually consistent).',
    explanation:
      'Компромисс между ACID и производительностью в распределённых системах -- одна из центральных тем системного дизайна. Современные БД предлагают различные уровни гарантий: Google Spanner обеспечивает глобальные ACID-транзакции через TrueTime API, CockroachDB использует Serializable изоляцию, а Cassandra предлагает настраиваемый уровень консистентности. Важно понимать, какие гарантии реально нужны вашему приложению.',
  },
  {
    id: 'sd-db-005',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL базы данных лучше всего подходит для хранения социального графа (друзья, подписки, рекомендации)?',
    options: [
      'Документная (MongoDB)',
      'Колоночная (Cassandra)',
      'Ключ-значение (Redis)',
      'Графовая (Neo4j)',
    ],
    correctIndex: 3,
    explanation:
      'Графовые базы данных (Neo4j, Amazon Neptune, JanusGraph) специально спроектированы для хранения и обработки связей между сущностями. Они представляют данные в виде узлов и рёбер, что позволяет эффективно выполнять запросы по связям: «друзья друзей», «кратчайший путь между пользователями», «рекомендации на основе связей». В реляционной БД такие запросы потребовали бы множественных JOIN-ов с экспоненциальным ростом сложности.',
  },
  {
    id: 'sd-db-006',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое индекс в базе данных и зачем он нужен?',
    options: [
      'Резервная копия таблицы для отказоустойчивости',
      'Структура данных, ускоряющая поиск строк в таблице за счёт дополнительных затрат памяти и замедления записи',
      'Инструмент для шифрования данных в таблице',
      'Механизм автоматического удаления устаревших данных',
    ],
    correctIndex: 1,
    explanation:
      'Индекс базы данных — это дополнительная структура данных (обычно B-tree или B+tree), которая ускоряет поиск строк по определённым столбцам. Без индекса БД выполняет full table scan (просмотр всех строк). С индексом поиск выполняется за O(log n). Компромиссы: индексы занимают дополнительное место на диске, замедляют операции INSERT/UPDATE/DELETE (нужно обновлять индекс) и требуют обслуживания (перестроение при фрагментации). Важно индексировать столбцы, по которым часто ищут, но не создавать индексов больше необходимого.',
  },
  {
    id: 'sd-db-007',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL базы данных хранит данные в формате «ключ-значение»?',
    options: [
      'MongoDB',
      'Cassandra',
      'Redis',
      'Neo4j',
    ],
    correctIndex: 2,
    explanation:
      'Redis — наиболее популярная key-value база данных. Key-value хранилища предоставляют простейшую модель данных: каждый элемент хранится как пара «ключ-значение». Операции ограничены: GET по ключу, PUT ключ-значение, DELETE по ключу. Преимущества: экстремально высокая производительность (O(1) доступ), простота, хорошая масштабируемость. Используются для: кэширования, хранения сессий, rate limiting, очередей. Другие примеры: DynamoDB, Memcached, Riak.',
  },
  {
    id: 'sd-db-008',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое connection pooling (пул соединений) в контексте баз данных?',
    options: [
      'Репликация данных между несколькими серверами БД',
      'Повторное использование предварительно созданных соединений к БД вместо создания нового для каждого запроса',
      'Шифрование соединений между приложением и БД',
      'Балансировка запросов между несколькими базами данных',
    ],
    correctIndex: 1,
    explanation:
      'Connection pooling — механизм повторного использования соединений к базе данных. Создание TCP-соединения и аутентификация в БД — дорогие операции (десятки миллисекунд). Пул поддерживает набор готовых соединений: приложение берёт соединение из пула, выполняет запрос и возвращает обратно. Это значительно снижает задержку и нагрузку на сервер БД. Ключевые настройки: minPoolSize (минимальное количество соединений), maxPoolSize (максимальное), connectionTimeout (время ожидания свободного соединения). Инструменты: HikariCP (Java), PgBouncer (PostgreSQL), ProxySQL (MySQL).',
  },
  {
    id: 'sd-db-009',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое column-family (колоночное семейство) хранилище и для каких задач оно оптимально?',
    options: [
      'Реляционная БД с оптимизацией для JOIN-операций',
      'Хранилище, организующее данные по столбцам вместо строк, оптимальное для аналитических запросов и обработки временных рядов',
      'База данных для хранения бинарных файлов',
      'Графовая БД с поддержкой семейств узлов',
    ],
    correctIndex: 1,
    explanation:
      'Column-family хранилища (Cassandra, HBase, ScyllaDB) организуют данные по столбцам, а не по строкам. Данные одного столбца хранятся последовательно на диске, что позволяет эффективно читать/агрегировать один столбец из миллионов строк. Оптимальны для: временных рядов (IoT, метрики), аналитических запросов (sum, avg по столбцу), данных с большим количеством столбцов, из которых запрашиваются немногие. Cassandra дополнительно обеспечивает линейную масштабируемость и высокую доступность через peer-to-peer архитектуру без единой точки отказа.',
  },
  {
    id: 'sd-db-010',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое паттерн «Database per Service» в микросервисной архитектуре?',
    options: [
      'Все сервисы используют одну общую базу данных для консистентности',
      'Каждый микросервис имеет свою собственную базу данных, недоступную напрямую другим сервисам',
      'База данных выделяется на каждого пользователя',
      'Каждая таблица хранится в отдельной базе данных',
    ],
    correctIndex: 1,
    explanation:
      'Database per Service — паттерн, при котором каждый микросервис владеет своей базой данных и является единственным, кто может читать и записывать в неё. Другие сервисы получают данные только через API сервиса-владельца. Преимущества: независимый деплой, свобода выбора СУБД для каждого сервиса (polyglot persistence), отсутствие связанности на уровне данных. Недостатки: сложность обеспечения консистентности между сервисами (нужны Saga, eventual consistency), невозможность выполнять JOIN между БД разных сервисов, дублирование данных.',
  },
  {
    id: 'sd-db-011',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните паттерн CQRS (Command Query Responsibility Segregation) с отдельными хранилищами для чтения и записи. Когда он оправдан?',
    sampleAnswer:
      'CQRS разделяет систему на две части: Command side (запись) и Query side (чтение) с разными моделями данных и, опционально, разными хранилищами. Command side использует нормализованную модель (например, PostgreSQL) для обеспечения консистентности записи. Query side использует денормализованную модель, оптимизированную для конкретных запросов чтения (Elasticsearch для поиска, Redis для быстрого доступа, materialized views). Синхронизация между сторонами происходит через события: при записи генерируется событие, проецирующее данные в read-модель. CQRS оправдан, когда: 1) Нагрузка на чтение значительно превышает запись (можно масштабировать стороны независимо). 2) Модели данных для чтения и записи сильно отличаются. 3) Нужны сложные представления данных для чтения (агрегации, полнотекстовый поиск). 4) Система использует Event Sourcing. Не оправдан для простых CRUD-приложений — добавляет сложность.',
    explanation:
      'CQRS часто применяется вместе с Event Sourcing, но это не обязательно. Ключевой компромисс — eventual consistency: read-модель может отставать от write-модели на время обработки событий (обычно миллисекунды-секунды). Это нужно учитывать в UX: например, после создания заказа показать подтверждение из write-стороны, не дожидаясь обновления read-модели.',
  },
  {
    id: 'sd-db-012',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое NewSQL базы данных и какую проблему они решают?',
    options: [
      'Новая версия языка SQL с расширенным синтаксисом',
      'NoSQL базы данных с поддержкой SQL-синтаксиса',
      'Реляционные БД нового поколения, совмещающие ACID-транзакции с горизонтальной масштабируемостью',
      'Инструменты для миграции данных между SQL и NoSQL',
    ],
    correctIndex: 2,
    explanation:
      'NewSQL — это класс реляционных СУБД, которые стремятся совместить ACID-гарантии традиционных SQL-систем с горизонтальной масштабируемостью NoSQL. Они решают дилемму «SQL (ACID, но плохо масштабируется) vs NoSQL (масштабируется, но нет ACID)». Примеры: Google Spanner (глобально распределённая, использует TrueTime для синхронизации), CockroachDB (open-source аналог Spanner), TiDB (совместима с MySQL), YugabyteDB (совместима с PostgreSQL). NewSQL подходит для приложений, которым нужны и строгие транзакции, и горизонтальное масштабирование.',
  },
  {
    id: 'sd-db-013',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните CAP-теорему и её практическое значение при выборе базы данных для распределённой системы. Приведите примеры CP и AP систем.',
    sampleAnswer:
      'CAP-теорема утверждает, что в распределённой системе невозможно одновременно обеспечить все три свойства: Consistency (все узлы видят одни и те же данные), Availability (каждый запрос получает ответ), Partition Tolerance (система работает при сетевых разделениях). Поскольку сетевые разделения неизбежны в распределённых системах, реальный выбор — между CP и AP. CP-системы (консистентность + устойчивость к разделению): при сетевом разделении отказывают в обслуживании для сохранения консистентности. Примеры: PostgreSQL (single-node), HBase, MongoDB (при настройке majority write concern), etcd, ZooKeeper. AP-системы (доступность + устойчивость к разделению): при разделении продолжают отвечать, но данные могут быть устаревшими. Примеры: Cassandra, DynamoDB, CouchDB, Riak. На практике это спектр, а не бинарный выбор: многие БД позволяют настраивать уровень консистентности (Cassandra: ONE, QUORUM, ALL). Важно: CAP описывает поведение при сетевых разделениях, в нормальном режиме большинство систем обеспечивают и C, и A.',
    explanation:
      'CAP-теорема — важная концептуальная рамка, но на практике более полезна модель PACELC (расширение CAP): при Partition — выбор между A и C, Else (нормальный режим) — выбор между Latency и Consistency. Это объясняет, почему Cassandra (PA/EL) и DynamoDB (PA/EL) жертвуют консистентностью ради скорости даже без разделений, а Spanner (PC/EC) обеспечивает строгую консистентность за счёт более высокой задержки.',
  },
  {
    id: 'sd-db-014',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Write-Ahead Log (WAL) и какую роль он играет в обеспечении durability?',
    options: [
      'Лог запросов на чтение для оптимизации кэша',
      'Журнал, в который изменения записываются до применения к основным файлам данных, обеспечивая восстановление после сбоя',
      'Лог медленных запросов для оптимизации производительности',
      'Механизм аудита действий пользователей базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Write-Ahead Log (WAL) — механизм, при котором все изменения записываются сначала в последовательный журнал на диске, и только затем применяются к файлам данных. Это обеспечивает durability (долговечность): при сбое системы БД может восстановить состояние, воспроизведя записи из WAL. WAL также повышает производительность: последовательная запись в журнал быстрее, чем случайные обновления файлов данных. WAL используется в PostgreSQL, MySQL (InnoDB redo log), SQLite, Kafka (commit log) и многих других системах. На основе WAL работает репликация: реплика получает и воспроизводит WAL master-а.',
  },
  {
    id: 'sd-db-015',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните подходы к денормализации данных. Когда денормализация оправдана и какие проблемы она создаёт?',
    sampleAnswer:
      'Денормализация — намеренное дублирование данных или группировка данных для оптимизации чтения за счёт усложнения записи. Подходы: 1) Добавление вычисляемых/дублирующих столбцов — хранить имя автора в таблице статей вместо JOIN с таблицей авторов. 2) Materialized views — предвычисленные и сохранённые результаты запросов. 3) Embedding (вложение) — в документных БД хранить связанные данные внутри документа (адрес внутри документа пользователя). 4) Таблицы-агрегаты — предвычисленные агрегации (количество лайков, средний рейтинг). Оправдана, когда: чтение значительно преобладает над записью, JOIN-ы становятся узким местом, нужна минимальная задержка чтения, данные редко обновляются. Проблемы: аномалии обновления (нужно обновлять данные в нескольких местах), увеличение объёма хранения, сложность поддержания консистентности, усложнение кода записи.',
    explanation:
      'Денормализация — один из ключевых инструментов масштабирования. Практически все высоконагруженные системы используют денормализацию в той или иной степени. Важно денормализовать осознанно, основываясь на реальных паттернах запросов, а не преждевременно. Хорошая практика — использовать CQRS, где write-модель нормализована, а read-модель денормализована.',
  },
  {
    id: 'sd-db-016',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое ORM (Object-Relational Mapping)?',
    options: [
      'Инструмент мониторинга производительности базы данных',
      'Технология автоматического маппинга объектов в программном коде на строки таблиц реляционной БД',
      'Протокол репликации данных между серверами',
      'Метод шифрования данных в базе данных',
    ],
    correctIndex: 1,
    explanation:
      'ORM (Object-Relational Mapping) — технология, позволяющая работать с данными реляционной БД через объекты в коде, без написания SQL-запросов вручную. ORM автоматически преобразует объекты в SQL и обратно. Примеры: Sequelize (Node.js), SQLAlchemy (Python), Hibernate (Java), Prisma (TypeScript). Преимущества: ускорение разработки, защита от SQL-инъекций, абстракция от конкретной СУБД. Недостатки: N+1 проблема, неоптимальные запросы, сложность при нестандартных операциях, скрытая сложность.',
  },
  {
    id: 'sd-db-017',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое document store (документная БД)? Приведите примеры типичных структур данных и паттернов запросов, для которых они оптимальны.',
    sampleAnswer:
      'Document store — тип NoSQL базы данных, хранящей данные в виде полуструктурированных документов (обычно JSON/BSON). Каждый документ является самодостаточной единицей данных с произвольной структурой. Примеры СУБД: MongoDB, CouchDB, Amazon DocumentDB, Firebase Firestore. Оптимальны для: 1) Каталоги товаров — товары разных категорий имеют разные атрибуты (электроника vs одежда). 2) Профили пользователей — различные наборы полей, вложенные списки (адреса, предпочтения). 3) Системы управления контентом (CMS) — статьи с разной структурой, метаданными, тегами. 4) Конфигурации — иерархические настройки приложений. 5) Логи и события — полуструктурированные данные с переменным набором полей. Типичные паттерны: чтение/запись целых документов по ID, вложенные запросы (find documents where nested.field = value), aggregation pipeline для аналитики, text search по содержимому документов.',
    explanation:
      'Документные БД лучше всего подходят, когда данные естественно представляются как «документ» — самодостаточная единица с вложенной структурой. Антипаттерн — использовать документную БД для сильно связанных данных, требующих частых JOIN-подобных операций между документами. В таких случаях реляционная БД будет эффективнее.',
  },
  {
    id: 'sd-db-018',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций по умолчанию использует PostgreSQL?',
    options: [
      'Read Uncommitted',
      'Read Committed',
      'Repeatable Read',
      'Serializable',
    ],
    correctIndex: 1,
    explanation:
      'PostgreSQL по умолчанию использует уровень изоляции Read Committed. На этом уровне транзакция видит только данные, зафиксированные до начала каждого оператора (statement) внутри транзакции. Это предотвращает «грязное чтение» (dirty read), но допускает «неповторяемое чтение» (non-repeatable read) и «фантомные чтения» (phantom read). Более строгие уровни (Repeatable Read, Serializable) обеспечивают лучшую изоляцию, но снижают производительность. Важно выбирать уровень изоляции осознанно: для финансовых операций может потребоваться Serializable, для большинства веб-приложений Read Committed достаточен.',
  },
  {
    id: 'sd-db-019',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое N+1 проблема при работе с базой данных?',
    options: [
      'Ограничение на максимальное количество соединений к БД',
      'Ситуация, когда для выборки N связанных объектов выполняется 1 основной запрос и N дополнительных вместо одного JOIN-запроса',
      'Ошибка при попытке создать более N+1 индексов на таблице',
      'Невозможность хранить более N+1 строк в одной таблице',
    ],
    correctIndex: 1,
    explanation:
      'N+1 проблема — классическая проблема производительности, особенно при использовании ORM. Пример: загрузить 100 пользователей (1 запрос), затем для каждого загрузить его заказы (100 запросов) = 101 запрос вместо одного JOIN-запроса. Решения: 1) Eager loading (JOIN) — загрузить данные одним запросом с JOIN. 2) Batch loading — загрузить связанные данные пакетом (WHERE user_id IN (1,2,3...)). 3) DataLoader-паттерн — автоматическое группирование запросов (используется в GraphQL). N+1 проблема может драматически снизить производительность: 1000 объектов = 1001 запрос к БД.',
  },
  {
    id: 'sd-db-020',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать паттерн Saga для управления распределёнными транзакциями между микросервисами с отдельными базами данных?',
    sampleAnswer:
      'Saga — паттерн управления распределёнными транзакциями, при котором бизнес-транзакция разбивается на последовательность локальных транзакций в разных сервисах. Каждый шаг имеет компенсирующую операцию (откат). Два подхода реализации: 1) Choreography (хореография) — каждый сервис, завершив свою локальную транзакцию, публикует событие, которое запускает следующий шаг. При ошибке публикуется событие отмены, запускающее компенсирующие операции. Плюсы: простота, отсутствие центрального координатора. Минусы: сложно отслеживать состояние, циклические зависимости. 2) Orchestration (оркестрация) — центральный оркестратор (Saga Execution Coordinator) управляет последовательностью шагов, вызывая каждый сервис и обрабатывая ошибки. Плюсы: явная логика, легко отслеживать состояние. Минусы: оркестратор — потенциальная единая точка отказа. Пример: создание заказа = (1) Резервировать товар → (2) Списать средства → (3) Создать доставку. При ошибке на шаге 3: компенсация = (2\') Вернуть средства → (1\') Отменить резерв. Инструменты: Temporal, Camunda, AWS Step Functions.',
    explanation:
      'Saga — это компромисс: вместо ACID-транзакции получаем ACD (без Isolation). Между шагами система находится в промежуточном состоянии, что нужно учитывать в бизнес-логике. Компенсирующие операции должны быть идемпотентными. На практике паттерн Saga значительно усложняет систему, поэтому стоит его применять только когда database-per-service действительно необходим.',
  },
];
