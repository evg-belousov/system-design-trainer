import type { Question } from '../types';

export const sdDatabasesQuestions: Question[] = [
  {
    id: 'sd-db-001',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'В чём ключевое различие между SQL и NoSQL базами данных?',
    options: [
      'SQL базы данных всегда быстрее NoSQL',
      'SQL базы данных используют фиксированную схему и язык SQL, NoSQL -- гибкие схемы и разные модели данных',
      'NoSQL базы данных не поддерживают репликацию',
      'SQL базы данных не подходят для горизонтального масштабирования',
    ],
    correctIndex: 1,
    explanation:
      'SQL (реляционные) базы данных используют фиксированные схемы с таблицами, строками и столбцами и язык SQL для запросов. Они обеспечивают ACID-транзакции и строгую консистентность. NoSQL базы данных предлагают гибкие модели данных (документные, колоночные, ключ-значение, графовые), не требуют фиксированной схемы и обычно лучше масштабируются горизонтально. Выбор зависит от структуры данных, требований к консистентности и масштабируемости.',
  },
  {
    id: 'sd-db-002',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое репликация Master-Slave (Primary-Replica) и какую проблему она решает?',
    options: [
      'Автоматическое резервное копирование данных на ленточные накопители',
      'Главная реплика принимает запись, а вторичные обслуживают чтение, что увеличивает пропускную способность и отказоустойчивость',
      'Разделение данных по горизонтали между несколькими серверами',
      'Шифрование данных при передаче между серверами',
    ],
    correctIndex: 1,
    explanation:
      'В схеме Master-Slave (Primary-Replica) один сервер (master/primary) принимает все операции записи и реплицирует изменения на один или несколько slave/replica серверов. Replica-серверы обслуживают запросы на чтение, что позволяет распределить нагрузку чтения (read scaling). При выходе из строя master-а один из slave может быть промотирован до нового master-а (failover). Важно учитывать задержку репликации (replication lag), которая может привести к чтению устаревших данных.',
  },
  {
    id: 'sd-db-003',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Когда стоит выбрать документную базу данных (например, MongoDB) вместо реляционной (например, PostgreSQL)? Приведите конкретные примеры.',
    sampleAnswer:
      'Документная БД предпочтительна в следующих случаях: 1) Данные имеют иерархическую или вложенную структуру, которая плохо ложится в реляционную модель (каталог товаров с разными атрибутами для разных категорий, профили пользователей с переменным набором полей). 2) Схема данных часто меняется на ранних стадиях разработки -- schema-less подход ускоряет итерации. 3) Нужна горизонтальная масштабируемость из коробки -- MongoDB поддерживает шардирование как встроенную функцию. 4) Паттерн доступа -- чтение/запись целых документов (не нужны сложные JOIN-ы). 5) Контентные системы (CMS), системы управления конфигурациями, IoT-платформы. Реляционная БД лучше подходит, когда важны: сложные связи между данными, ACID-транзакции, сложные аналитические запросы, строгая схема данных.',
    explanation:
      'Выбор между SQL и NoSQL -- не вопрос «что лучше», а вопрос «что подходит». На практике многие системы используют полиглотное хранение (polyglot persistence): реляционную БД для транзакционных данных, документную для каталогов, Redis для кэша, Elasticsearch для полнотекстового поиска. Важно выбирать СУБД исходя из паттернов доступа, требований к консистентности и масштабу.',
  },
  {
    id: 'sd-db-004',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните принцип ACID в контексте распределённых баз данных. Почему полноценные ACID-транзакции сложно реализовать в распределённых системах?',
    sampleAnswer:
      'ACID -- это набор свойств транзакций: Atomicity (атомарность -- транзакция выполняется полностью или не выполняется), Consistency (консистентность -- данные переходят из одного валидного состояния в другое), Isolation (изоляция -- параллельные транзакции не влияют друг на друга), Durability (долговечность -- результаты зафиксированной транзакции сохраняются). В распределённых системах ACID сложно реализовать потому что: 1) Атомарность требует координации между узлами (2PC -- two-phase commit протокол, который медленный и блокирующий). 2) Консистентность в условиях сетевых разделений невозможна одновременно с доступностью (CAP-теорема). 3) Изоляция на уровне Serializable в распределённой системе сильно снижает производительность. 4) Долговечность требует подтверждения записи от нескольких узлов (кворум). Поэтому многие NoSQL-системы предлагают ослабленные гарантии (BASE: Basically Available, Soft state, Eventually consistent).',
    explanation:
      'Компромисс между ACID и производительностью в распределённых системах -- одна из центральных тем системного дизайна. Современные БД предлагают различные уровни гарантий: Google Spanner обеспечивает глобальные ACID-транзакции через TrueTime API, CockroachDB использует Serializable изоляцию, а Cassandra предлагает настраиваемый уровень консистентности. Важно понимать, какие гарантии реально нужны вашему приложению.',
  },
  {
    id: 'sd-db-005',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL базы данных лучше всего подходит для хранения социального графа (друзья, подписки, рекомендации)?',
    options: [
      'Документная (MongoDB)',
      'Колоночная (Cassandra)',
      'Ключ-значение (Redis)',
      'Графовая (Neo4j)',
    ],
    correctIndex: 3,
    explanation:
      'Графовые базы данных (Neo4j, Amazon Neptune, JanusGraph) специально спроектированы для хранения и обработки связей между сущностями. Они представляют данные в виде узлов и рёбер, что позволяет эффективно выполнять запросы по связям: «друзья друзей», «кратчайший путь между пользователями», «рекомендации на основе связей». В реляционной БД такие запросы потребовали бы множественных JOIN-ов с экспоненциальным ростом сложности.',
  },
  {
    id: 'sd-db-006',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое индекс в базе данных и зачем он нужен?',
    options: [
      'Резервная копия таблицы для отказоустойчивости',
      'Структура данных, ускоряющая поиск строк в таблице за счёт дополнительных затрат памяти и замедления записи',
      'Инструмент для шифрования данных в таблице',
      'Механизм автоматического удаления устаревших данных',
    ],
    correctIndex: 1,
    explanation:
      'Индекс базы данных — это дополнительная структура данных (обычно B-tree или B+tree), которая ускоряет поиск строк по определённым столбцам. Без индекса БД выполняет full table scan (просмотр всех строк). С индексом поиск выполняется за O(log n). Компромиссы: индексы занимают дополнительное место на диске, замедляют операции INSERT/UPDATE/DELETE (нужно обновлять индекс) и требуют обслуживания (перестроение при фрагментации). Важно индексировать столбцы, по которым часто ищут, но не создавать индексов больше необходимого.',
  },
  {
    id: 'sd-db-007',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип NoSQL базы данных хранит данные в формате «ключ-значение»?',
    options: [
      'MongoDB',
      'Cassandra',
      'Redis',
      'Neo4j',
    ],
    correctIndex: 2,
    explanation:
      'Redis — наиболее популярная key-value база данных. Key-value хранилища предоставляют простейшую модель данных: каждый элемент хранится как пара «ключ-значение». Операции ограничены: GET по ключу, PUT ключ-значение, DELETE по ключу. Преимущества: экстремально высокая производительность (O(1) доступ), простота, хорошая масштабируемость. Используются для: кэширования, хранения сессий, rate limiting, очередей. Другие примеры: DynamoDB, Memcached, Riak.',
  },
  {
    id: 'sd-db-008',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое connection pooling (пул соединений) в контексте баз данных?',
    options: [
      'Репликация данных между несколькими серверами БД',
      'Повторное использование предварительно созданных соединений к БД вместо создания нового для каждого запроса',
      'Шифрование соединений между приложением и БД',
      'Балансировка запросов между несколькими базами данных',
    ],
    correctIndex: 1,
    explanation:
      'Connection pooling — механизм повторного использования соединений к базе данных. Создание TCP-соединения и аутентификация в БД — дорогие операции (десятки миллисекунд). Пул поддерживает набор готовых соединений: приложение берёт соединение из пула, выполняет запрос и возвращает обратно. Это значительно снижает задержку и нагрузку на сервер БД. Ключевые настройки: minPoolSize (минимальное количество соединений), maxPoolSize (максимальное), connectionTimeout (время ожидания свободного соединения). Инструменты: HikariCP (Java), PgBouncer (PostgreSQL), ProxySQL (MySQL).',
  },
  {
    id: 'sd-db-009',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое column-family (колоночное семейство) хранилище и для каких задач оно оптимально?',
    options: [
      'Реляционная БД с оптимизацией для JOIN-операций',
      'Хранилище, организующее данные по столбцам вместо строк, оптимальное для аналитических запросов и обработки временных рядов',
      'База данных для хранения бинарных файлов',
      'Графовая БД с поддержкой семейств узлов',
    ],
    correctIndex: 1,
    explanation:
      'Column-family хранилища (Cassandra, HBase, ScyllaDB) организуют данные по столбцам, а не по строкам. Данные одного столбца хранятся последовательно на диске, что позволяет эффективно читать/агрегировать один столбец из миллионов строк. Оптимальны для: временных рядов (IoT, метрики), аналитических запросов (sum, avg по столбцу), данных с большим количеством столбцов, из которых запрашиваются немногие. Cassandra дополнительно обеспечивает линейную масштабируемость и высокую доступность через peer-to-peer архитектуру без единой точки отказа.',
  },
  {
    id: 'sd-db-010',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое паттерн «Database per Service» в микросервисной архитектуре?',
    options: [
      'Все сервисы используют одну общую базу данных для консистентности',
      'Каждый микросервис имеет свою собственную базу данных, недоступную напрямую другим сервисам',
      'База данных выделяется на каждого пользователя',
      'Каждая таблица хранится в отдельной базе данных',
    ],
    correctIndex: 1,
    explanation:
      'Database per Service — паттерн, при котором каждый микросервис владеет своей базой данных и является единственным, кто может читать и записывать в неё. Другие сервисы получают данные только через API сервиса-владельца. Преимущества: независимый деплой, свобода выбора СУБД для каждого сервиса (polyglot persistence), отсутствие связанности на уровне данных. Недостатки: сложность обеспечения консистентности между сервисами (нужны Saga, eventual consistency), невозможность выполнять JOIN между БД разных сервисов, дублирование данных.',
  },
  {
    id: 'sd-db-011',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Объясните паттерн CQRS (Command Query Responsibility Segregation) с отдельными хранилищами для чтения и записи. Когда он оправдан?',
    sampleAnswer:
      'CQRS разделяет систему на две части: Command side (запись) и Query side (чтение) с разными моделями данных и, опционально, разными хранилищами. Command side использует нормализованную модель (например, PostgreSQL) для обеспечения консистентности записи. Query side использует денормализованную модель, оптимизированную для конкретных запросов чтения (Elasticsearch для поиска, Redis для быстрого доступа, materialized views). Синхронизация между сторонами происходит через события: при записи генерируется событие, проецирующее данные в read-модель. CQRS оправдан, когда: 1) Нагрузка на чтение значительно превышает запись (можно масштабировать стороны независимо). 2) Модели данных для чтения и записи сильно отличаются. 3) Нужны сложные представления данных для чтения (агрегации, полнотекстовый поиск). 4) Система использует Event Sourcing. Не оправдан для простых CRUD-приложений — добавляет сложность.',
    explanation:
      'CQRS часто применяется вместе с Event Sourcing, но это не обязательно. Ключевой компромисс — eventual consistency: read-модель может отставать от write-модели на время обработки событий (обычно миллисекунды-секунды). Это нужно учитывать в UX: например, после создания заказа показать подтверждение из write-стороны, не дожидаясь обновления read-модели.',
  },
  {
    id: 'sd-db-012',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое NewSQL базы данных и какую проблему они решают?',
    options: [
      'Новая версия языка SQL с расширенным синтаксисом',
      'NoSQL базы данных с поддержкой SQL-синтаксиса',
      'Реляционные БД нового поколения, совмещающие ACID-транзакции с горизонтальной масштабируемостью',
      'Инструменты для миграции данных между SQL и NoSQL',
    ],
    correctIndex: 2,
    explanation:
      'NewSQL — это класс реляционных СУБД, которые стремятся совместить ACID-гарантии традиционных SQL-систем с горизонтальной масштабируемостью NoSQL. Они решают дилемму «SQL (ACID, но плохо масштабируется) vs NoSQL (масштабируется, но нет ACID)». Примеры: Google Spanner (глобально распределённая, использует TrueTime для синхронизации), CockroachDB (open-source аналог Spanner), TiDB (совместима с MySQL), YugabyteDB (совместима с PostgreSQL). NewSQL подходит для приложений, которым нужны и строгие транзакции, и горизонтальное масштабирование.',
  },
  {
    id: 'sd-db-013',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните CAP-теорему и её практическое значение при выборе базы данных для распределённой системы. Приведите примеры CP и AP систем.',
    sampleAnswer:
      'CAP-теорема утверждает, что в распределённой системе невозможно одновременно обеспечить все три свойства: Consistency (все узлы видят одни и те же данные), Availability (каждый запрос получает ответ), Partition Tolerance (система работает при сетевых разделениях). Поскольку сетевые разделения неизбежны в распределённых системах, реальный выбор — между CP и AP. CP-системы (консистентность + устойчивость к разделению): при сетевом разделении отказывают в обслуживании для сохранения консистентности. Примеры: PostgreSQL (single-node), HBase, MongoDB (при настройке majority write concern), etcd, ZooKeeper. AP-системы (доступность + устойчивость к разделению): при разделении продолжают отвечать, но данные могут быть устаревшими. Примеры: Cassandra, DynamoDB, CouchDB, Riak. На практике это спектр, а не бинарный выбор: многие БД позволяют настраивать уровень консистентности (Cassandra: ONE, QUORUM, ALL). Важно: CAP описывает поведение при сетевых разделениях, в нормальном режиме большинство систем обеспечивают и C, и A.',
    explanation:
      'CAP-теорема — важная концептуальная рамка, но на практике более полезна модель PACELC (расширение CAP): при Partition — выбор между A и C, Else (нормальный режим) — выбор между Latency и Consistency. Это объясняет, почему Cassandra (PA/EL) и DynamoDB (PA/EL) жертвуют консистентностью ради скорости даже без разделений, а Spanner (PC/EC) обеспечивает строгую консистентность за счёт более высокой задержки.',
  },
  {
    id: 'sd-db-014',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое Write-Ahead Log (WAL) и какую роль он играет в обеспечении durability?',
    options: [
      'Лог запросов на чтение для оптимизации кэша',
      'Журнал, в который изменения записываются до применения к основным файлам данных, обеспечивая восстановление после сбоя',
      'Лог медленных запросов для оптимизации производительности',
      'Механизм аудита действий пользователей базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Write-Ahead Log (WAL) — механизм, при котором все изменения записываются сначала в последовательный журнал на диске, и только затем применяются к файлам данных. Это обеспечивает durability (долговечность): при сбое системы БД может восстановить состояние, воспроизведя записи из WAL. WAL также повышает производительность: последовательная запись в журнал быстрее, чем случайные обновления файлов данных. WAL используется в PostgreSQL, MySQL (InnoDB redo log), SQLite, Kafka (commit log) и многих других системах. На основе WAL работает репликация: реплика получает и воспроизводит WAL master-а.',
  },
  {
    id: 'sd-db-015',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Сравните подходы к денормализации данных. Когда денормализация оправдана и какие проблемы она создаёт?',
    sampleAnswer:
      'Денормализация — намеренное дублирование данных или группировка данных для оптимизации чтения за счёт усложнения записи. Подходы: 1) Добавление вычисляемых/дублирующих столбцов — хранить имя автора в таблице статей вместо JOIN с таблицей авторов. 2) Materialized views — предвычисленные и сохранённые результаты запросов. 3) Embedding (вложение) — в документных БД хранить связанные данные внутри документа (адрес внутри документа пользователя). 4) Таблицы-агрегаты — предвычисленные агрегации (количество лайков, средний рейтинг). Оправдана, когда: чтение значительно преобладает над записью, JOIN-ы становятся узким местом, нужна минимальная задержка чтения, данные редко обновляются. Проблемы: аномалии обновления (нужно обновлять данные в нескольких местах), увеличение объёма хранения, сложность поддержания консистентности, усложнение кода записи.',
    explanation:
      'Денормализация — один из ключевых инструментов масштабирования. Практически все высоконагруженные системы используют денормализацию в той или иной степени. Важно денормализовать осознанно, основываясь на реальных паттернах запросов, а не преждевременно. Хорошая практика — использовать CQRS, где write-модель нормализована, а read-модель денормализована.',
  },
  {
    id: 'sd-db-016',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое ORM (Object-Relational Mapping)?',
    options: [
      'Инструмент мониторинга производительности базы данных',
      'Технология автоматического маппинга объектов в программном коде на строки таблиц реляционной БД',
      'Протокол репликации данных между серверами',
      'Метод шифрования данных в базе данных',
    ],
    correctIndex: 1,
    explanation:
      'ORM (Object-Relational Mapping) — технология, позволяющая работать с данными реляционной БД через объекты в коде, без написания SQL-запросов вручную. ORM автоматически преобразует объекты в SQL и обратно. Примеры: Sequelize (Node.js), SQLAlchemy (Python), Hibernate (Java), Prisma (TypeScript). Преимущества: ускорение разработки, защита от SQL-инъекций, абстракция от конкретной СУБД. Недостатки: N+1 проблема, неоптимальные запросы, сложность при нестандартных операциях, скрытая сложность.',
  },
  {
    id: 'sd-db-017',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое document store (документная БД)? Приведите примеры типичных структур данных и паттернов запросов, для которых они оптимальны.',
    sampleAnswer:
      'Document store — тип NoSQL базы данных, хранящей данные в виде полуструктурированных документов (обычно JSON/BSON). Каждый документ является самодостаточной единицей данных с произвольной структурой. Примеры СУБД: MongoDB, CouchDB, Amazon DocumentDB, Firebase Firestore. Оптимальны для: 1) Каталоги товаров — товары разных категорий имеют разные атрибуты (электроника vs одежда). 2) Профили пользователей — различные наборы полей, вложенные списки (адреса, предпочтения). 3) Системы управления контентом (CMS) — статьи с разной структурой, метаданными, тегами. 4) Конфигурации — иерархические настройки приложений. 5) Логи и события — полуструктурированные данные с переменным набором полей. Типичные паттерны: чтение/запись целых документов по ID, вложенные запросы (find documents where nested.field = value), aggregation pipeline для аналитики, text search по содержимому документов.',
    explanation:
      'Документные БД лучше всего подходят, когда данные естественно представляются как «документ» — самодостаточная единица с вложенной структурой. Антипаттерн — использовать документную БД для сильно связанных данных, требующих частых JOIN-подобных операций между документами. В таких случаях реляционная БД будет эффективнее.',
  },
  {
    id: 'sd-db-018',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой уровень изоляции транзакций по умолчанию использует PostgreSQL?',
    options: [
      'Read Uncommitted',
      'Read Committed',
      'Repeatable Read',
      'Serializable',
    ],
    correctIndex: 1,
    explanation:
      'PostgreSQL по умолчанию использует уровень изоляции Read Committed. На этом уровне транзакция видит только данные, зафиксированные до начала каждого оператора (statement) внутри транзакции. Это предотвращает «грязное чтение» (dirty read), но допускает «неповторяемое чтение» (non-repeatable read) и «фантомные чтения» (phantom read). Более строгие уровни (Repeatable Read, Serializable) обеспечивают лучшую изоляцию, но снижают производительность. Важно выбирать уровень изоляции осознанно: для финансовых операций может потребоваться Serializable, для большинства веб-приложений Read Committed достаточен.',
  },
  {
    id: 'sd-db-019',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое N+1 проблема при работе с базой данных?',
    options: [
      'Ограничение на максимальное количество соединений к БД',
      'Ситуация, когда для выборки N связанных объектов выполняется 1 основной запрос и N дополнительных вместо одного JOIN-запроса',
      'Ошибка при попытке создать более N+1 индексов на таблице',
      'Невозможность хранить более N+1 строк в одной таблице',
    ],
    correctIndex: 1,
    explanation:
      'N+1 проблема — классическая проблема производительности, особенно при использовании ORM. Пример: загрузить 100 пользователей (1 запрос), затем для каждого загрузить его заказы (100 запросов) = 101 запрос вместо одного JOIN-запроса. Решения: 1) Eager loading (JOIN) — загрузить данные одним запросом с JOIN. 2) Batch loading — загрузить связанные данные пакетом (WHERE user_id IN (1,2,3...)). 3) DataLoader-паттерн — автоматическое группирование запросов (используется в GraphQL). N+1 проблема может драматически снизить производительность: 1000 объектов = 1001 запрос к БД.',
  },
  {
    id: 'sd-db-020',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать паттерн Saga для управления распределёнными транзакциями между микросервисами с отдельными базами данных?',
    sampleAnswer:
      'Saga — паттерн управления распределёнными транзакциями, при котором бизнес-транзакция разбивается на последовательность локальных транзакций в разных сервисах. Каждый шаг имеет компенсирующую операцию (откат). Два подхода реализации: 1) Choreography (хореография) — каждый сервис, завершив свою локальную транзакцию, публикует событие, которое запускает следующий шаг. При ошибке публикуется событие отмены, запускающее компенсирующие операции. Плюсы: простота, отсутствие центрального координатора. Минусы: сложно отслеживать состояние, циклические зависимости. 2) Orchestration (оркестрация) — центральный оркестратор (Saga Execution Coordinator) управляет последовательностью шагов, вызывая каждый сервис и обрабатывая ошибки. Плюсы: явная логика, легко отслеживать состояние. Минусы: оркестратор — потенциальная единая точка отказа. Пример: создание заказа = (1) Резервировать товар → (2) Списать средства → (3) Создать доставку. При ошибке на шаге 3: компенсация = (2\') Вернуть средства → (1\') Отменить резерв. Инструменты: Temporal, Camunda, AWS Step Functions.',
    explanation:
      'Saga — это компромисс: вместо ACID-транзакции получаем ACD (без Isolation). Между шагами система находится в промежуточном состоянии, что нужно учитывать в бизнес-логике. Компенсирующие операции должны быть идемпотентными. На практике паттерн Saga значительно усложняет систему, поэтому стоит его применять только когда database-per-service действительно необходим.',
  },
  {
    id: 'sd-db-021',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое первичный ключ (Primary Key) в реляционной базе данных?',
    options: [
      'Ключ шифрования для защиты данных таблицы',
      'Уникальный идентификатор каждой строки в таблице',
      'Первый столбец в таблице',
      'Ключ для соединения двух таблиц',
    ],
    correctIndex: 1,
    explanation:
      'Primary Key — это столбец (или комбинация столбцов), который уникально идентифицирует каждую строку в таблице. Свойства: уникальность (нет дубликатов), not null (обязательно значение), один на таблицу. Может быть natural (email, SSN) или surrogate (auto-increment ID, UUID). Primary Key автоматически индексируется.',
  },
  {
    id: 'sd-db-022',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое внешний ключ (Foreign Key)?',
    options: [
      'Ключ для доступа к базе данных извне',
      'Ссылка на первичный ключ другой таблицы, обеспечивающая связь между таблицами',
      'Резервный первичный ключ',
      'Ключ для шифрования внешних соединений',
    ],
    correctIndex: 1,
    explanation:
      'Foreign Key — столбец, ссылающийся на Primary Key другой таблицы. Обеспечивает ссылочную целостность (referential integrity): нельзя создать заказ для несуществующего клиента. СУБД может автоматически применять действия при удалении/обновлении связанной записи: CASCADE, SET NULL, RESTRICT. Foreign Key — основа реляционной модели данных.',
  },
  {
    id: 'sd-db-023',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Какой тип базы данных лучше всего подходит для хранения временных рядов (time series) данных?',
    options: [
      'Реляционная (PostgreSQL)',
      'Документная (MongoDB)',
      'Специализированная time-series (InfluxDB, TimescaleDB)',
      'Графовая (Neo4j)',
    ],
    correctIndex: 2,
    explanation:
      'Time-series базы данных (InfluxDB, TimescaleDB, Prometheus) оптимизированы для: append-only записи с timestamp, агрегаций по временным интервалам, автоматического сжатия и retention старых данных, downsampling (агрегация для долгосрочного хранения). Используются для: метрик, IoT-данных, финансовых котировок, логов. TimescaleDB — расширение PostgreSQL, совместимое с SQL.',
  },
  {
    id: 'sd-db-024',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'open',
    question: 'Объясните, что такое нормализация базы данных и зачем она нужна. Назовите основные нормальные формы.',
    sampleAnswer:
      'Нормализация — процесс организации данных для уменьшения дублирования и обеспечения целостности. Основные нормальные формы: 1NF — атомарные значения (нет массивов в ячейках), уникальные строки. 2NF — 1NF + все неключевые атрибуты зависят от всего первичного ключа (не от части). 3NF — 2NF + нет транзитивных зависимостей (неключевой атрибут не зависит от другого неключевого). BCNF — более строгая версия 3NF. Зачем: уменьшает дублирование, предотвращает аномалии при UPDATE/DELETE, упрощает поддержку консистентности. Компромисс: больше JOIN-ов, сложнее запросы. Денормализация — обратный процесс для оптимизации чтения.',
    explanation:
      'На практике большинство OLTP-систем нормализованы до 3NF. Денормализуют для производительности чтения на основе реальных паттернов запросов. Data warehouses (OLAP) часто денормализованы (star schema) для быстрой аналитики.',
  },
  {
    id: 'sd-db-025',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое eventual consistency и когда она допустима?',
    options: [
      'Данные всегда консистентны во всех узлах',
      'Данные станут консистентными через некоторое время, если не будет новых обновлений',
      'Данные никогда не будут консистентны',
      'Консистентность гарантируется только для транзакций',
    ],
    correctIndex: 1,
    explanation:
      'Eventual consistency — модель консистентности, при которой система гарантирует, что данные станут согласованными во всех репликах через некоторое время (обычно миллисекунды-секунды), если не будет новых обновлений. Допустима, когда: небольшая задержка синхронизации приемлема (социальные сети, лайки), высокая доступность важнее мгновенной консистентности, система географически распределена. Не подходит для: финансовых транзакций, систем резервирования.',
  },
  {
    id: 'sd-db-026',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое database migration и зачем она нужна?',
    options: [
      'Перемещение базы данных на другой сервер',
      'Версионируемые изменения схемы базы данных, применяемые автоматически',
      'Миграция данных между разными СУБД',
      'Резервное копирование базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Database migration — это версионированное изменение схемы БД (добавление таблиц, столбцов, индексов) с возможностью отката. Зачем: синхронизация схемы между разработчиками и окружениями, отслеживание истории изменений, автоматизация деплоя, возможность rollback. Инструменты: Flyway, Liquibase (Java), Alembic (Python), Knex (Node.js), Rails Migrations (Ruby). Важно: миграции должны быть idempotent и backward compatible.',
  },
  {
    id: 'sd-db-027',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Как выбрать между PostgreSQL и MongoDB для нового проекта? Какие критерии следует учитывать?',
    sampleAnswer:
      'Критерии выбора: 1) Структура данных: PostgreSQL — фиксированная схема, сложные связи между сущностями, JOIN-ы. MongoDB — гибкая схема, вложенные документы, частые изменения структуры. 2) Требования к консистентности: PostgreSQL — ACID, строгие транзакции. MongoDB — eventual consistency по умолчанию (ACID для single document). 3) Паттерны запросов: PostgreSQL — сложные аналитические запросы, aggregations. MongoDB — CRUD по документам, flexible queries. 4) Масштабирование: PostgreSQL — вертикальное + read replicas (шардирование сложнее). MongoDB — встроенное шардирование. 5) Экосистема: PostgreSQL — зрелая, расширения (PostGIS, pg_vector). MongoDB — хорошая интеграция с JS-стеком. Примеры: PostgreSQL — финансы, ERP, CRM. MongoDB — CMS, каталоги товаров, IoT.',
    explanation:
      'Нет универсально «лучшей» базы данных. Выбор зависит от конкретных требований. На практике многие проекты используют обе: PostgreSQL для транзакционных данных, MongoDB для контента и логов. Важно не выбирать NoSQL только потому, что это «модно».',
  },
  {
    id: 'sd-db-028',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое connection pool exhaustion и как его предотвратить?',
    options: [
      'Заполнение пула соединений, после чего новые запросы ожидают или получают ошибку',
      'Утечка соединений из пула',
      'Переполнение буфера соединений',
      'Исчерпание места на диске БД',
    ],
    correctIndex: 0,
    explanation:
      'Connection pool exhaustion происходит, когда все соединения в пуле заняты и новые запросы не могут получить соединение. Причины: медленные запросы, утечки соединений (не возвращаются в пул), слишком маленький пул, транзакции держат соединения долго. Предотвращение: настройка maxPoolSize адекватно нагрузке, таймауты на получение соединения, мониторинг активных соединений, оптимизация медленных запросов, использование connection timeout.',
  },
  {
    id: 'sd-db-029',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое multi-model database?',
    options: [
      'База данных с несколькими серверами',
      'База данных, поддерживающая несколько моделей данных (документы, графы, ключ-значение) в одной системе',
      'База данных с несколькими схемами',
      'Распределённая база данных',
    ],
    correctIndex: 1,
    explanation:
      'Multi-model database поддерживает несколько моделей данных в одной системе. Примеры: ArangoDB (документы, графы, ключ-значение), CosmosDB (документы, графы, колонки, ключ-значение), PostgreSQL с расширениями (реляционная + JSON + graph с pgRouting). Преимущества: один инструмент для разных задач, меньше операционной сложности, единые транзакции между моделями. Недостатки: может быть не оптимален для каждой модели по сравнению со специализированной БД.',
  },
  {
    id: 'sd-db-030',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Что такое database federation и когда она применяется?',
    sampleAnswer:
      'Database federation — разделение базы данных по функциональности (вертикальное партиционирование): разные группы таблиц хранятся в разных базах/серверах. Пример: БД пользователей, БД продуктов, БД заказов — каждая на своём сервере. Отличие от шардирования: шардирование делит одну таблицу горизонтально, federation делит таблицы вертикально по доменам. Преимущества: независимое масштабирование доменов, изоляция нагрузки, разные СУБД для разных задач. Применяется: при переходе от монолита к микросервисам (database per service), когда домены имеют разные требования к масштабированию, для изоляции критичных данных. Сложности: нет JOIN между базами, distributed transactions.',
    explanation:
      'Federation — первый шаг масштабирования базы данных до шардирования. Часто применяется при decomposition монолита: каждый microservice получает свою базу данных. Важно правильно определить границы доменов (bounded contexts из DDD).',
  },
  {
    id: 'sd-db-031',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое distributed SQL (или NewSQL) база данных?',
    options: [
      'SQL база данных в облаке',
      'Распределённая СУБД с SQL-интерфейсом, ACID-транзакциями и горизонтальным масштабированием',
      'База данных с репликацией master-slave',
      'SQL база данных без транзакций',
    ],
    correctIndex: 1,
    explanation:
      'Distributed SQL (NewSQL) — класс СУБД, сочетающих SQL-интерфейс и ACID-гарантии реляционных БД с горизонтальным масштабированием NoSQL. Примеры: Google Spanner, CockroachDB, YugabyteDB, TiDB. Особенности: автоматическое шардирование, распределённые транзакции, SQL-совместимость, strong consistency. Подходит, когда нужны и транзакции, и масштабирование (финансы, retail). Trade-off: выше latency из-за координации между узлами.',
  },
  {
    id: 'sd-db-032',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Какой механизм использует CockroachDB для обеспечения serializable isolation в распределённой системе?',
    options: [
      'Two-Phase Locking (2PL)',
      'Optimistic Concurrency Control с Hybrid Logical Clocks',
      'Pessimistic Locking',
      'Read Committed isolation',
    ],
    correctIndex: 1,
    explanation:
      'CockroachDB использует оптимистичный контроль параллелизма (OCC) с Hybrid Logical Clocks (HLC) для обеспечения serializable isolation без глобальной синхронизации времени. HLC комбинирует физическое время с логическими счётчиками для определения порядка событий. Транзакции выполняются оптимистично, конфликты обнаруживаются при коммите. Google Spanner использует TrueTime (GPS + atomic clocks), что недоступно вне Google, CockroachDB — программную альтернативу.',
  },
  {
    id: 'sd-db-033',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать soft delete в базе данных и какие последствия для производительности и архитектуры это имеет?',
    sampleAnswer:
      'Soft delete — помечать записи как удалённые вместо физического удаления (DELETE). Реализация: столбец deleted_at (NULL = активна, timestamp = удалена) или is_deleted boolean. Последствия: 1) Все SELECT должны фильтровать WHERE deleted_at IS NULL — забыть = показать удалённые данные. 2) Индексы растут — удалённые записи занимают место. Partial index помогает: CREATE INDEX ON users (id) WHERE deleted_at IS NULL. 3) Unique constraints усложняются — email должен быть уникален среди активных, но может дублироваться среди удалённых. 4) Foreign keys — удалённая родительская запись с активными детьми. 5) Аудит и восстановление — soft delete упрощает восстановление. Архитектурно: вместо soft delete часто лучше event sourcing или отдельная archive-таблица. ORM (Django, Rails) поддерживают soft delete через middleware.',
    explanation:
      'Soft delete кажется простым, но создаёт множество edge cases. Альтернативы: event sourcing (полная история), audit log (отдельная таблица изменений), архивная таблица (move вместо delete). Выбор зависит от требований: compliance, восстановление, аудит.',
  },
  {
    id: 'sd-db-034',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Объясните, как работает MVCC (Multi-Version Concurrency Control) и почему он важен для производительности базы данных.',
    sampleAnswer:
      'MVCC — механизм, при котором каждая транзакция видит snapshot данных на момент своего начала, а не текущее состояние. При UPDATE создаётся новая версия строки, старая сохраняется для активных транзакций. Читатели не блокируют писателей и наоборот. Как работает в PostgreSQL: каждая строка имеет xmin (ID создавшей транзакции) и xmax (ID удалившей/обновившей). Транзакция видит строку, если xmin committed и меньше её snapshot, и xmax не committed или больше snapshot. Преимущества MVCC: высокий параллелизм (читатели не блокируют), consistent reads без блокировок, эффективные long-running queries. Недостатки: накопление старых версий (bloat), необходимость VACUUM в PostgreSQL, overhead хранения версий. MVCC используется: PostgreSQL, MySQL InnoDB, Oracle, CockroachDB.',
    explanation:
      'MVCC — основа высокой производительности современных СУБД. Без MVCC каждое чтение блокировало бы запись и наоборот. В PostgreSQL важно настроить autovacuum для очистки старых версий, иначе таблицы раздуваются (table bloat).',
  },
  {
    id: 'sd-db-035',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое CRUD-операции в контексте баз данных?',
    options: [
      'Операции шифрования данных',
      'Create, Read, Update, Delete — базовые операции с данными',
      'Операции резервного копирования',
      'Операции репликации',
    ],
    correctIndex: 1,
    explanation:
      'CRUD — акроним для четырёх базовых операций с данными: Create (INSERT), Read (SELECT), Update (UPDATE), Delete (DELETE). Эти операции составляют основу большинства приложений. REST API часто маппится на CRUD: POST → Create, GET → Read, PUT/PATCH → Update, DELETE → Delete. Понимание CRUD важно для проектирования API и схемы БД.',
  },
  {
    id: 'sd-db-036',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое составной индекс (composite index)?',
    options: [
      'Индекс, созданный из нескольких таблиц',
      'Индекс, включающий несколько столбцов',
      'Резервная копия индекса',
      'Индекс с функцией сжатия',
    ],
    correctIndex: 1,
    explanation:
      'Composite index — индекс, построенный по нескольким столбцам. Например: CREATE INDEX ON orders (user_id, created_at). Порядок столбцов важен: индекс эффективен для запросов, фильтрующих по первым столбцам (user_id) или по всем. Запрос только по created_at не использует этот индекс эффективно. Правило: располагать столбцы от высокой кардинальности к низкой и по частоте использования в WHERE.',
  },
  {
    id: 'sd-db-037',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое query execution plan и зачем его анализировать?',
    options: [
      'План резервного копирования запросов',
      'Пошаговый план выполнения запроса, показывающий как СУБД будет получать данные',
      'Расписание выполнения запросов',
      'Документация API базы данных',
    ],
    correctIndex: 1,
    explanation:
      'Query execution plan — план, который оптимизатор СУБД строит для выполнения запроса. Показывает: какие индексы используются (или sequential scan), порядок JOIN, методы соединения (hash, nested loop, merge), estimated cost и actual rows. Команды: EXPLAIN (план), EXPLAIN ANALYZE (план + фактическое выполнение). Зачем: найти неэффективные запросы (sequential scan на большой таблице), понять использование индексов, оптимизировать производительность.',
  },
  {
    id: 'sd-db-038',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Какие факторы нужно учитывать при выборе между UUID и auto-increment ID как первичного ключа?',
    sampleAnswer:
      'Auto-increment ID: Преимущества: компактный (4-8 байт vs 16 байт UUID), эффективные B-tree индексы (последовательная вставка), читаемый. Недостатки: предсказуемый (security risk для public API), проблемы при шардировании (коллизии), не генерируется на клиенте. UUID: Преимущества: глобально уникален без координации (идеален для распределённых систем), генерируется на клиенте, не раскрывает информацию. Недостатки: больше места (16 байт), фрагментация B-tree индекса (случайная вставка), менее читаемый. Компромиссы: UUIDv7 (time-ordered UUID) — сохраняет сортируемость, ULID — sortable, URL-safe. Snowflake ID (Twitter) — 64-bit, time-based, distributed. Выбор: распределённая система → UUID/ULID. Монолит с одной БД → auto-increment. Public API → UUID (скрывает количество записей).',
    explanation:
      'Выбор ID — архитектурное решение с долгосрочными последствиями. Миграция с одного типа на другой болезненна. При шардировании auto-increment требует дополнительной координации (ticket server, ranges). UUID безопаснее для будущего масштабирования.',
  },
  {
    id: 'sd-db-039',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое database partitioning и чем оно отличается от sharding?',
    options: [
      'Это одно и то же',
      'Partitioning — разделение внутри одной БД, sharding — распределение между несколькими серверами',
      'Partitioning для NoSQL, sharding для SQL',
      'Sharding — это вид partitioning для индексов',
    ],
    correctIndex: 1,
    explanation:
      'Partitioning — разделение таблицы на части (партиции) внутри одной СУБД. Данные физически хранятся отдельно, но логически — одна таблица. PostgreSQL: partition by range, list, hash. Sharding — распределение данных между несколькими независимыми серверами БД. Каждый шард — отдельная база данных. Partitioning: проще, один сервер, встроенная поддержка СУБД. Sharding: масштабирование за пределы одного сервера, но сложнее (координация, routing).',
  },
  {
    id: 'sd-db-040',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое CDC (Change Data Capture)?',
    options: [
      'Механизм резервного копирования',
      'Захват изменений данных в БД для репликации или синхронизации с другими системами',
      'Протокол шифрования данных',
      'Система мониторинга базы данных',
    ],
    correctIndex: 1,
    explanation:
      'CDC (Change Data Capture) — технология отслеживания и захвата изменений в базе данных (INSERT, UPDATE, DELETE) для репликации или интеграции с другими системами. Способы: log-based (чтение WAL/binlog — Debezium, Maxwell), trigger-based (триггеры на таблицах), timestamp-based (polling по updated_at). Применения: синхронизация с Elasticsearch, event-driven architecture, data warehouse ETL, кэш-инвалидация. Debezium + Kafka — популярный стек для CDC.',
  },
  {
    id: 'sd-db-041',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Как реализовать полнотекстовый поиск в базе данных? Сравните встроенные решения СУБД с Elasticsearch.',
    sampleAnswer:
      'Встроенный полнотекстовый поиск: PostgreSQL: tsvector/tsquery, GIN-индексы. Поддерживает: stemming, ranking, phrase search. Для русского — pg_trgm, hunspell словари. Проще интегрировать, транзакционно согласован с данными. Ограничения: масштабирование только с БД, меньше возможностей анализа. MySQL: FULLTEXT index (InnoDB). Базовый функционал, менее гибкий чем PostgreSQL. MongoDB: text index. Простой поиск, ограниченный функционал. Elasticsearch: Преимущества: мощный анализ текста, фасеты, агрегации, relevance tuning, горизонтальное масштабирование, near real-time search. Недостатки: отдельная инфраструктура, синхронизация данных (dual write или CDC), eventual consistency с основной БД, операционная сложность. Рекомендации: простой поиск, небольшие данные → встроенный поиск СУБД. Сложный поиск, масштаб, faceted search → Elasticsearch. Часто комбинируют: СУБД для CRUD, Elasticsearch для поиска.',
    explanation:
      'Выбор решения для поиска зависит от требований. Для MVP встроенный поиск PostgreSQL часто достаточен. При росте и усложнении требований (автодополнение, fuzzy search, аналитика) — миграция на Elasticsearch. Важно продумать синхронизацию данных заранее.',
  },
  {
    id: 'sd-db-042',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое database replication lag и как его мониторить?',
    options: [
      'Задержка между запросом и ответом БД',
      'Задержка между применением изменений на master и replica',
      'Время создания резервной копии',
      'Задержка сетевого соединения',
    ],
    correctIndex: 1,
    explanation:
      'Replication lag — задержка между применением транзакции на master (primary) и её появлением на replica. Причины: нагрузка на replica, сетевая задержка, большие транзакции, медленные диски. Последствия: чтение устаревших данных с реплик. Мониторинг: PostgreSQL — pg_stat_replication, MySQL — SHOW SLAVE STATUS (Seconds_Behind_Master). Решения: read-your-writes consistency (читать с master после записи), синхронная репликация (за счёт latency), мониторинг и алерты на lag.',
  },
  {
    id: 'sd-db-043',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'quiz',
    question: 'Что такое NULL в базах данных и какие проблемы он создаёт?',
    options: [
      'Пустая строка',
      'Специальное значение, означающее отсутствие данных',
      'Ноль',
      'Ошибка в данных',
    ],
    correctIndex: 1,
    explanation:
      'NULL — специальное значение, означающее отсутствие или неизвестность данных. Это не пустая строка и не ноль. Проблемы: NULL = NULL возвращает NULL (не true), нужен IS NULL для проверки; агрегатные функции игнорируют NULL (AVG не учитывает); индексы могут не включать NULL; сложная логика (three-valued logic). Best practices: NOT NULL constraints где возможно, COALESCE для замены NULL значением по умолчанию.',
  },
  {
    id: 'sd-db-044',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'open',
    question: 'Как организовать хранение иерархических данных (деревьев) в реляционной базе данных?',
    sampleAnswer:
      'Способы хранения деревьев в RDBMS: 1) Adjacency List — каждая строка хранит parent_id. Просто, но рекурсивные запросы медленные. PostgreSQL WITH RECURSIVE помогает. 2) Nested Sets — каждый узел имеет left и right числа, определяющие границы поддерева. Быстрое чтение поддерева, но медленные вставки (перенумерация). 3) Materialized Path — хранить полный путь: «/1/2/5/». Быстрый поиск потомков (LIKE «/1/2/%»), но путь может быть длинным. 4) Closure Table — отдельная таблица со всеми связями ancestor-descendant. Быстрые запросы любых отношений, но много места и сложные вставки. 5) ltree (PostgreSQL) — встроенный тип для path, GiST индексы. Выбор: частые чтения, редкие изменения → Nested Sets, Closure Table. Частые изменения → Adjacency List + CTE. PostgreSQL → ltree.',
    explanation:
      'Иерархические данные (организационные структуры, категории, комментарии) — частая задача. Каждый способ имеет trade-offs. Для небольших деревьев Adjacency List достаточен. Для больших и глубоких — специализированные решения или графовые БД.',
  },
  {
    id: 'sd-db-045',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Что такое deadlock в базе данных?',
    options: [
      'Переполнение буфера транзакций',
      'Взаимная блокировка, когда две транзакции ждут друг друга',
      'Долгая транзакция, блокирующая таблицу',
      'Ошибка подключения к базе данных',
    ],
    correctIndex: 1,
    explanation:
      'Deadlock — ситуация, когда транзакция A держит lock на ресурс X и ждёт ресурс Y, а транзакция B держит lock на Y и ждёт X. Ни одна не может продолжить. СУБД автоматически обнаруживает deadlock и отменяет одну транзакцию (victim). Предотвращение: всегда блокировать ресурсы в одном порядке, минимизировать время блокировки, использовать оптимистичную блокировку где возможно. Мониторинг: pg_stat_activity, логи deadlock.',
  },
  {
    id: 'sd-db-046',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Как организовать online schema migration для таблицы с миллиардами строк без даунтайма?',
    sampleAnswer:
      'Online schema migration для больших таблиц: 1) pt-online-schema-change (Percona, MySQL) — создаёт новую таблицу с новой схемой, копирует данные порциями, использует триггеры для синхронизации новых изменений, в конце atomic swap. 2) gh-ost (GitHub, MySQL) — аналогично, но без триггеров (использует binlog). 3) pgroll (PostgreSQL) — expand/contract pattern с версионированием views. 4) Ручной подход: добавить nullable столбец (быстро), backfill данными батчами, сделать NOT NULL, удалить старый столбец. 5) Blue-green tables — создать новую таблицу, dual-write во время миграции, переключить чтение. Принципы: backward compatible changes (добавление nullable столбца), forward compatible (приложение работает с обеими схемами), incremental rollout, мониторинг replication lag при миграции. Expand-contract: сначала расширить схему (add column), затем сократить (drop old column).',
    explanation:
      'Schema migrations на масштабе — одна из сложнейших задач. ALTER TABLE с блокировкой на миллиарде строк = часы даунтайма. Facebook, GitHub, Stripe публиковали подходы к zero-downtime migrations. Ключ — backward/forward compatibility и постепенность.',
  },
  {
    id: 'sd-db-047',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'quiz',
    question: 'Что такое vector database и для чего она используется?',
    options: [
      'База данных для хранения изображений',
      'База данных для хранения и поиска по векторным представлениям (embeddings)',
      'База данных для временных рядов',
      'Графовая база данных',
    ],
    correctIndex: 1,
    explanation:
      'Vector database — специализированная БД для хранения и similarity search по векторным представлениям (embeddings). Embeddings — числовые представления данных (текст, изображения, аудио), где семантически близкие объекты имеют близкие векторы. Применения: semantic search, рекомендации, RAG (Retrieval-Augmented Generation) для LLM, дедупликация. Примеры: Pinecone, Weaviate, Milvus, Qdrant, pgvector (PostgreSQL extension). Алгоритмы: ANN (Approximate Nearest Neighbor), HNSW, IVF.',
  },
  {
    id: 'sd-db-048',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'junior',
    type: 'open',
    question: 'Что такое транзакция в базе данных и какие операции она включает?',
    sampleAnswer:
      'Транзакция — логическая единица работы с БД, которая либо выполняется полностью, либо не выполняется вообще. Основные операции: BEGIN/START TRANSACTION — начало транзакции. COMMIT — фиксация изменений (сохранение). ROLLBACK — откат изменений (отмена). SAVEPOINT — точка сохранения внутри транзакции для частичного отката. Пример: перевод денег — уменьшить баланс A, увеличить баланс B. Если вторая операция не удалась, первая откатывается. Без транзакции деньги могут «исчезнуть». Свойства транзакций — ACID: Atomicity, Consistency, Isolation, Durability.',
    explanation:
      'Транзакции — фундаментальная концепция СУБД. Они гарантируют целостность данных при сбоях и параллельном доступе. Важно: длинные транзакции держат блокировки, что снижает производительность. Транзакция должна быть максимально короткой.',
  },
  {
    id: 'sd-db-049',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'middle',
    type: 'quiz',
    question: 'Какой механизм PostgreSQL позволяет хранить и запрашивать JSON-данные с индексированием?',
    options: [
      'TEXT столбец с JSON строкой',
      'JSONB тип данных с GIN индексами',
      'XML тип данных',
      'ARRAY тип данных',
    ],
    correctIndex: 1,
    explanation:
      'JSONB — бинарный формат хранения JSON в PostgreSQL. В отличие от JSON (текстовый), JSONB: оптимизирован для чтения (не парсится каждый раз), поддерживает индексы (GIN для быстрого поиска по ключам и значениям), поддерживает операторы (containment @>, existence ?). Применения: схема-гибкие атрибуты, настройки, метаданные. Не заменяет реляционную модель для структурированных данных с частыми JOIN.',
  },
  {
    id: 'sd-db-050',
    block: 'sd',
    topic: 'databases',
    topicLabel: 'Базы данных (SD)',
    difficulty: 'senior',
    type: 'open',
    question: 'Опишите стратегию выбора базы данных для стартапа, который планирует быстрый рост. Какие факторы критичны?',
    sampleAnswer:
      'Стратегия выбора БД для растущего стартапа: 1) Начать просто — PostgreSQL покрывает 90% случаев. Не выбирать NoSQL «на будущее» без понимания паттернов данных. 2) Managed services — RDS, Cloud SQL, Atlas. Не тратить инженерное время на операции. 3) Схема данных — если структура неизвестна и меняется быстро, MongoDB может ускорить итерации. Если данные структурированы — SQL. 4) Транзакции — нужны ACID гарантии → реляционная БД. 5) Масштабирование — read replicas первый шаг. Планировать шардирование заранее (UUID вместо auto-increment). 6) Vendor lock-in — учитывать стоимость миграции. PostgreSQL-совместимые (CockroachDB, Aurora) проще, чем proprietary DynamoDB. 7) Команда — использовать то, что команда знает. Экспертиза важнее теоретических преимуществ. 8) Cost — бесплатные tier для старта, понятная модель роста стоимости. Рекомендация: PostgreSQL (RDS) + Redis (ElastiCache) покрывает большинство стартапов до серьёзного масштаба.',
    explanation:
      'Преждевременная оптимизация выбора БД — частая ошибка. Stack Overflow работал на SQL Server, Instagram начинал на PostgreSQL. Выбор экзотической БД создаёт операционную нагрузку. Лучше начать с проверенного решения и оптимизировать по мере роста и понимания реальных паттернов.',
  },
];
